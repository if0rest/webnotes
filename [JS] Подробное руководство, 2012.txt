JS. Подробное руководство, 2012

Переменная (var) - это символическое имя некоторого значения.

Объект - это коллекция пар имя/значение или отображение строки в значение.

Доступ к свойствам объекта выполняется с помощью . или []:
	book.topic
	book['topic']

Массив - список с числовыми индексами.


Спецификации содержат важнейшую информацию о том, как оно «должно работать».

Атрибут <script defer ...>
• Скрипты загрузятся "кто быстрее", но выполнятся в порядке очереди.
• Даже если внешние скрипты не нужно загружать, а браузер берёт их из кеша, он всё равно устроен так, что выполнит их после основных скриптов страницы.

ES5-shim
Браузер IE8 поддерживает только совсем старую версию стандарта JavaScript, а именно ES3.
К счастью, многие возможности современного стандарта можно добавить в этот браузер, подключив
библиотеку ES5 shim (https://github.com/es-shims/es5-shim), а именно — скрипты es5‐shim.js и es5‐sham.js.

Чтобы хранить информацию, используются переменные. Переменная состоит из имени и выделенной области памяти. После объявления, можно записать в переменную данные, кот. будут сохранены и доступны при обращении по имени.
Проще всего понять переменную, если представить ее как «коробку» для данных, с уникальным
именем.

Проверка if вне диапазона:
	if(!(age >= 14 && age <=90)) {...}
	if(age < 14 && age > 90) {...}

--------------------------------------------------

ПРЕОБРАЗОВАНИЕ ТИПОВ ДЛЯ ПРИМИТИВОВ

1. CТРОКОВОЕ - когда требуется представление чего-либо в виде строки. Например, его производит функция alert.
	var a = true;
	alert( a ); // "true"
• Преобразование явным вызовом String(val):
	alert(String(null) == 'null');	// true
• Унарный +, у которого один из аргументов строка.:
	alert(true + 'test');		// 'truetest'
	alert('123' + undefined);	// '123undefined'

2. ЧИСЛЕННОЕ происходит в математических функциях и выражениях, при сравнении данных различных типов (кроме сравнений ===, !==).
Для преобразования к числу:
• в явном виде можно вызвать Number(val):
	var a = Number("123");	// 123, тот же эффект
• поставить перед выражением унарный плюс "+":
	var a = +"123";			// 123
Сравнение разных типов — значит численное преобразование:
	alert( "\n0 " == 0 );	// true
	alert( "\n" == false );	// "\n" -> 0 и false -> 0
	alert( "1" == true );	// "1" -> 1 и true -> 1
3. К ЛОГИЧЕСКОМУ ЗНАЧЕНИЮ.
	null == undefined, но null != 0: 
	alert (null == undefined);	// true
	alert (null == 0);			// false

<!> Для более очевидной работы кода и во избежание ошибок лучше не давать специальным значениям участвовать в сравнениях > >= < <=. Используйте переменные-числа или приводите к числу явно.

--------------------------------------------------

Блоки if/else, switch, for, while, do..while не влияют на область видимости переменных.
При объявлении переменной в таких блоках, она всё равно будет видна во всей функции.
	function count() {
	  // переменные i,j не будут уничтожены по окончании цикла
	  for (var i = 0; i < 3; i++) {
	    var j = i * 2;
	  }
	  alert( i ); // i=3, последнее значение i, при нём цикл перестал работать
	  alert( j ); // j=4, последнее значение j, которое вычислил цикл
	}

Из функции можно вызывать внешние var. Если есть 2 одноименные var (одна внешнняя, другая - локальная), и мы вызовем ее из функции, то функция сначала поищет у себя внутри, а если не найдет, проверит на наличие в глобальной scope. 
При обращении к необъявленной переменной функция будет искать внешнюю переменную с таким
именем.

Переменные, объявленные на уровне всего скрипта, называют «ГЛОБАЛЬНЫМИ ПЕРЕМЕННЫМИ».

Если аргументов передано больше, чем надо, например showMessage("Маша", "привет", 1, 2, 3),
то ошибки не будет. Но, чтобы получить такие «лишние» аргументы, нужно будет прочитать их из
специального объекта arguments.

-------------------------------------------

function checkAge(age) {
	if (age > 18) {
		return true;
	} else {
		return confirm('Родители разрешили?');
	}
}

var age = prompt('Ваш возраст?', '');

if (checkAge(age)) {
	alert('Доступ разрешен');
} else {
	alert('В доступе отказано');
}
-------------------------------------------

return для Function, как break для switch/for.

-------------------------------------------

В JavaScript функция является значением, таким же как строка или число. Как и любое значение, объявленную функцию можно вывести, вот так:
	function sayHi() {
	  alert( "Привет" );
	}
	alert( sayHi );	// выведет код функции

-------------------------------------------

Функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода, поэтому их можно вызвать до объявления.
А если бы это было объявление Function Expression, то такой вызов бы не сработал. 
Это из-за того, что JavaScript перед запуском кода ищет в нём Function Declaration (их легко найти:
они не являются частью выражений и начинаются со слова function) и обрабатывает их.
А Function Expression создаются в процессе выполнении выражения, в котором созданы, в данном
случае — функция будет создана при операции присваивания sayHi = function...{}

Если нет явной причины использовать Function Expression — предпочитайте Function
Declaration.

РЕКУРСИЯ - когда функция вызывает саму себя, как правило, с другими аргументами.
БАЗИС РЕКУРСИИ - значение, на котором рекурсия заканчивается.
ГЛУБИНА РЕКУРСИИ - общее количество вложенных вызовов. Также = максимальному числу контекстов, одновременно хранимых в стеке.
Рекурсию используют, когда вычисление функции можно свести к её более простому вызову, а
его — еще к более простому, и так далее, пока значение не станет очевидно. 

pow(x, n) = x * pow(x, n ‐ 1)
1. pow(2, 4) = 2 * pow(2, 3)
2. pow(2, 3) = 2 * pow(2, 2)
3. pow(2, 2) = 2 * pow(2, 1)
4. pow(2, 1) = 2

КОНТЕКСТ ВЫПОЛНЕНИЯ есть у каждого вызова функции — это служебная информация о текущем запуске функции. Она включает локальные переменные функции и конкретное место в коде, на котором находится интерпретатор.
КОНТЕКСТ ВЫПОЛНЕНИЯ ФУНКЦИИ - это ее локальные переменные + текущее положение интерпретатора, указывающее на место Ф в общем коде.
СТЕКЕ КОНТЕКСТОВ. При любом вложенном вызове JS запоминает текущий контекст выполнения в специальной внутренней структуре данных — СК.
ГЛУБИНА РЕКУРСИИ равна максимальному числу контекстов, одновременно хранимых в стеке.

Обратим внимание на требования к памяти. Рекурсия приводит к хранению всех данных для неоконченных внешних вызовов в стеке, в данном случае это приводит к тому, что возведение в степень n хранит в памяти n различных контекстов. Реализация возведения в степень через цикл гораздо более экономна.

-------------------------------------------
function sumTo(n) {
	var result = n;
	for (var i = 1; i < n; i++) {
		result += n - i;
	}
		alert(result);
}

sumTo(100);
-------------------------------------------
function f(n) {
  return n ? n * f(n ‐ 1) : 1;
};
var g = f;
f = null;
alert( g(5) ); // запуск функции с новым именем ‐ ошибка при выполнении!

Ошибка возникла потому что функция из своего кода обращается к своему старому имени f. А этой функции уже нет, f = null.
-------------------------------------------
Сравнение === проверяет точное равенство, включая одинаковый тип. Это самый очевидный и надёжный способ сравнения.
Остальные сравнения == < <= > >= осуществляют числовое приведение типа
-------------------------------------------
Вместо:
	for (var i = 0; i < 10; i++) {
	  if (i подходит) {
	    ... // <‐ уровень вложенности 2
	  }
	}
Используйте:
	for (var i = 0; i < 10; i++) {
	  if (i не подходит) continue;
	  ...  // <‐ уровень вложенности 1
	}
-------------------------------------------
Цикл на 5 итераций:
	for (var x = 1; x <= 5; x++)
или
	for (var x = 0; x < 5; x++)
-------------------------------------------
Ошибка сложения дробей:
	var a = 0.1, b = 0.2;
	alert( (a + b).toFixed(1) + '$');

Внутреннее неточное представление чисел приводит к ошибке в вычислениях, которая проявляется при работе и с положительными и с отрицательными числами.

Увы, операции с десятичными дробями подразумевают некоторую потерю точности.
-------------------------------------------
Вместо 
	if(text == undefined | null | "") {}
исп. просто
	if(!text) {}
-------------------------------------------
Пример итерации по свойствам:
	var menu = {
	  width: 300,
	  height: 200,
	  title: "Menu"
	};
	for (var key in menu) {
	  // этот код будет вызван для каждого свойства объекта
	  // ..и выведет имя свойства и его значение
	  alert( "Ключ: " + key + " значение:" + menu[key] );
	}
Обратите внимание, мы использовали квадратные скобки menu[key]. Как уже говорилось, если имя свойства хранится в переменной, то обратиться к нему можно только так, не через точку.
-------------------------------------------
Для проверки на число используйте функцию:
	function isNumeric(n) {
		return !isNaN(parseFloat(n)) && isFinite(n)
	}
-------------------------------------------
Массив — это объект, где в качестве ключей выбраны цифры, с дополнительными методами и
свойством length. Т.к. это объект, то в функцию он передаётся по ссылке.

Длина length — не количество элементов массива, а последний индекс + 1.
	var arr = [];  arr[1000] = true;
	alert(arr.length); // 1001

При уменьшении length массив укорачивается необратимо.
Самый простой способ очистить массив — это arr.length=0.

Получить последний элемент массива:
	var goods = ["шпинат", "селедка", "йогурт", "хлеб", "макароны"];
	alert(goods[goods.length - 1]);

-------------------------------------------
Код для генерации случайного целого от min to max включительно:
	var rand = min + Math.floor(Math.random() * (max + 1 ‐ min));
Короткий вариант:
	var rand = Math.floor(Math.random() * arr.length);

-------------------------------------------

СОЗДАЙТЕ КАЛЬКУЛЯТОР ДЛЯ ВВЕДЁННЫХ ЗНАЧЕНИЙ
Напишите код, который:
• Запрашивает по очереди значения при помощи prompt и сохраняет их в массиве.
• Заканчивает ввод, как только посетитель введёт пустую строку, не число или нажмёт «Отмена».
• При этом ноль 0 не должен заканчивать ввод, это разрешённое число.
• Выводит сумму всех значений массива

var numbers = [];

while(true) {
	var value = prompt('Введите любое число', '0');
	if (value === null || value === "" || isNaN(value)) break;
	numbers.push(+value);
}

var sum = 0;
for (var i = 0; i < numbers.length; i++) {
	sum += numbers[i];
}
alert(sum);


-------------------------------------------

ПСЕВДОМАССИВ АРГУМЕНТОВ «ARGUMENTS»
В JavaScript любая функция может быть вызвана с произвольным количеством аргументов.


ARGUMENTS — ЭТО НЕ МАССИВ и к нему неприменимы методы Array. Это обычный объект, просто ключи числовые и есть length.
Впрочем, никто не мешает сделать обычный массив из arguments, например так:
	var args = [];
	for (var i = 0; i < arguments.length; i++) {
		args[i] = arguments[i];
}
Такие объекты иногда называют «коллекциями» или «псевдомассивами».

КОПИРОВАНИЕ СВОЙСТВ COPY(DST, SRC1, SRC2…)
Иногда встаёт задача — скопировать в существующий объект свойства из одного или нескольких других. Напишем для этого функцию copy. Она будет работать с любым числом аргументов благодаря использованию arguments.

АРГУМЕНТЫ ПО УМОЛЧАНИЮ ЧЕРЕЗ ||
Если функция вызвана с меньшим количеством аргументов, то отсутствующие будут = undefined. Отсутствующему аргументу можно присвоить значение по умолчанию:
	function showWarning(width, height, title, contents) {
		width = width || 200; 	// если не указана width, то width = 200
	}
Это отлично работает со значениями, которые в логическом контексте не false. При передаче width = 0 (или null), 0 приведется к false и будет исп. значение по умолчанию).  
	if (height === undefined) height = 100;
	if (title === undefined) title = "Предупреждение";


Работа с аргументами:
	function func(a, b, c = 4) {
		alert(c);
	}
	func(1,2,3);	// 3
	func(1,2);		// 4

Используется передача аргументов в виде объекта, а в его свойствах мы
передаём параметры: 
	function showWarning(options) {
		var width = options.width || 200;
	}

ИТОГО:
• Полный список аргументов, с которыми вызвана функция, доступен через arguments. Это объект, похожий на массив: в нём есть нумерованные свойства и length, но нет методов массива.
• Для указания аргументов по умолчанию, в тех случаях, когда они заведомо не false, удобен оператор ||.
• Когда аргументов много и большинство имеют значения по умолчанию, вместо работы с arguments организуют передачу данных через объект options.

-------------------------------------------
Функция внутри функции:

	function sayHiBye(firstName, lastName) {
		alert( 'Привет, ' + getFullName() );
		alert( 'Пока, ' + getFullName() );
		
		function getFullName() {
			return firstName + " " + lastName + "!";
		}
	}

	sayHiBye('Владимир', 'Хапров');
	
-------------------------------------------
Насколько я понял, интерпретатор сканирует функцию целиком, находит в блоке else объявление var value и создает в LE свойство value = undefined. Это не то же value, что во внешнем LE.

var value = 0;

function f() {
	if (true) {
		value = true;	// (2) эта строчка присваивает значение
	} else {
		var value = false;	// (1) эта строчка создает var, но не инициализирует
	}
	alert( value );	// true (3) вызывает ЛОКАЛЬНУЮ var со значением true
}
f();
-------------------------------------------
Класс - шаблон, по кот. будет построен объект.
-------------------------------------------
Есть объект. Для его численного преобразовния исп. метод valueOf, для строкового - toString. При этом оба метода могут возвращать примитивы разных типов. У большинства объектов нет valueOf (возвращается сам объект и потому игнорируется), при этом для численного преобразования исп. toString.
-------------------------------------------
Если { ... } находится вне выражений, то это не объект, а блок.
-------------------------------------------


Добавить класс HTML-элементу в JS:
	elem.classList.add('external');

-------------------------------------------

var ul = document.body.firstElementChild;
do {
	var content = prompt('Заполните содержимое пункта', 'Ваш текст');
	if (content !== null && content != '') {
		var li = document.createElement('li');
		ul.appendChild(li).textContent = content;
	}
} while (content);


var go = true;
while (go) {
	var li = document.createElement('li');
	var content = prompt('Заполните содержимое пункта', 'Ваш текст');
	if (content != '' && content !== null) {
		ul.appendChild(li).textContent = content;
	} else { go = false };
};


var ul = document.body.firstElementChild;
do {
	var content = prompt('Заполните содержимое пункта', 'Ваш текст');
	if (content !== null && content != '') {
		var li = document.createElement('li');
		li.appendChild(document.createTextNode(content));
		ul.appendChild(li);
	}
} while (content);

-------------------------------------------
Запрет на выделение:
	elem.onmousedown = elem.onselectstart = function() { return false }

Запрет на копирование:
	<div oncopy="alert('Копирование запрещено!'); return false">
		Уважаемый копирователь, почему‐то автор хочет заставить вас покопаться в исходном коде этой страницы. Если вы знаете JS или HTML, то скопировать текст не составит для вас проблемы,
		ну а если нет, то увы...
	</div>

-------------------------------------------
elem.hidden = !elem.hidden;

e != event

while (e.target != this) {
	/* поднимаемся по DOM-дереву до родителя, на котором висит обработчик */
	e.target = e.target.parentNode;
}
===============================================
while (target != this) {
	if (target.nodeName == 'A') {
		// у 'A' есть свои свойства, можно без target.getAttribute();
		showThumbnail(target.href, target.title);
		// вместо e.preventDefault()
		return false;
	}
	// поднимаемся по DOM-дереву
	target = target.parentNode;
}
-------------------------------------------
Инициирование события из кода:

  <div id="elem" onclick="alert('Click!')">Автоклик</div>
<script>
	var event = new Event('click');
	elem.dispatchEvent(event);
</script>
-------------------------------------------
СВОРАЧИВАНИЕ СПИСКОВ:

<script>
	tree.onclick = function(evt) {
		var evt = evt || event;
		var target = evt.target || evt.srcElement;

		/* раскрыть-закрыть детей */
		var node = target.getElementsByTagName('ul')[0];
		if (!node) return; // нет детей

		// здесь не разобрался
		node.style.display = node.style.display ? '' : 'none';
	}
</script>
-------------------------------------------
Кликаю где-попало, по координатам onclick опр. элемент LI и получаю его текст:

	alert(document.elementFromPoint(e.clientX, e.clientY).firstChild.data);

-------------------------------------------
Можно получить всех потомков, передав звездочку '*' вместо тега:
	// получить все элементы документа
	document.getElementsByTagName('*');
	// получить всех потомков элемента elem:
	elem.getElementsByTagName('*');
	
Метод elem.closest(css) ищет ближайший элемент выше по иерархии DOM, подходящий под CSS-селектор css. Сам элемент тоже включается в поиск.
Иначе говоря, метод closest бежит от текущего элемента вверх по цепочке родителей и проверяет, подходит ли элемент под указанный CSS-селектор. Если подходит - останавливается и возвращает его.

***  Проверка пустой ли объект?  ***
	function isObjectEmpty(obj) {
		for (var key in obj) return false;
		return true;
	}
-------------------------------------------
function getCoords(elem) { // кроме IE8-
  var box = elem.getBoundingClientRect();

  return {
    top: box.top + pageYOffset,
    left: box.left + pageXOffset
  };
}
-------------------------------------------

if (e.ctrlKey && e.keyCode == "E".charCodeAt(0) && !area.offsetHeight) {
	edit();
	return false;
}		

В примере выше, offsetHeight используется для того, чтобы проверить, отображается
элемент или нет. Это очень надежный способ для всех элементов, кроме <tr> в некоторых
старых браузерах.
В отличие от простой проверки display=='none', этот способ работает с элементом,
спрятанным с помощью стилей, а так же для элементов, у которых скрыты родители.

-------------------------------------------

elem.onclick = function(e) {
// НЕ ОЧ
	var li = e.target;
	if (target.tagName != "LI") return;
// ГОДНО
	var li = e.target.closest('li');
	if (!li) return;
}
-------------------------------------------
// Вместо этого:
	function deselectAll() {
		for (var i = 0; i < elem.children.length; i++) {
			elem.children[i].classList.remove('selected');
		}
	}
// Вот это:
	function deselectAll() {
		[].forEach.call(elem.children, function(child) {
			child.classList.remove('selected')
		});
	}
-------------------------------------------
// Не так:
	this.getSelected = function() {
		return [].map.call(elem.querySelectorAll('.selected'), function(li) {
			return li.textContent;
		})
	}
// А так:
	this.getSelected = function() {
		var arrLi = [].slice.call(elem.querySelectorAll('.selected'));
		var arrText = arrLi.map(function(item) {
			return item.textContent;
		})
		return arrText;
	}

	
============================================
	POST-запрос
============================================

<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
 <body style='text-align:center'>
 	<h1>Загрузка веб-страницы в контейнер DIV</h1>
 	<div id='info'>Это предложение будет заменено</div>
 	<script>
 		var params = "url=amazon.com/gp/aw ",
 			 request = new ajaxRequest();
 		request.open('POST', urlpost.php, true);
 		request.setRequestHeader("Content-type", "application/x-www-form-urlencode");
 		request.setRequestHeader("Content-length", params.length);
 		request.setRequestHeader("Connection", "close");
 		request.onreadystatechange = function() {
 			if (this.readyState == 4 && this.status == 200 && this.responseText != null) {
				document.getElementById('info').innerHTML = this.responseText;
 			} else alert("Ошибка AJAX: Данные не получены")
 		} else alert( "Ошибка AJAX: " + this.statusText)
 		request.send(params);

 		function ajaxRequest() {
 			try {
 				var request = new XMLHttpRequest();
 			} catch (e1) {
 				try {
					request = new ActiveXObject("Msxml2.XMLHTTP");
 				} catch (e2) {
 					try {
 						 request = new ActiveXObject("Microsoft.XMLHTTP");
 					} catch (e3) {
 						request = false;
 					}
 				}
 			}
 			return false;
 		}
 	</script>
</body>
</html>

============================================