"JS позволяет динамически влиять на содержимое документа: на HTML-разметку и стили". 

'Canvas' - это элемент, кот. мы можем добавить в тело документа и с помощью JS нарисовать в канвасе 2- или 3-мерную графику. Canvas дает возможность генерировать на странице растровое изображение. Активно применяется при разработке браузерных игр совместно с JS и HTML5 взамен устаревших Flash и SilverLight.

'Geolocation API' дает инфу о текущем местоположении пользователя, IP или сети.

'MathML' - набор элементов для отображения сложных формул.

'Microdata' - часть спецификации, направленная на добавление специальных метаданных в документ.

"Браузер отправляет запрос на сервер, тот выполняет некую функциональность и возвращает HTML-документ, js-код и стили. Браузер получает от сервера информацию только в случае запроса".

'XMLHttpRequest Level 2'. Кто работал с AJAX, слышал данном о типе данных, об объекте, доступном в JS-коде. Его задача обращаться к серверу, слать на сервер HTTP-запросы и обрабатывать ответы. Благодаря возможностям, появившимся в XHR-L2, сделать сайт на AJAX стало проще.

_____________________________________________________________

Изменения в HTML5:
1. DOCTYPE.
	<!DOCTYPE html>
2. Кодировка.
	<meta charset="utf-8" />
3. Подключение JS и CSS.
	<link rel="stylesheet" href="styles.css" />
	<script src="script.js"></script>
	// избавились от атрибута type="text/css", передавашего MIME
4. Атрибут contenteditable позволяет локально редактировать текстовое содержимое, т.е. на стороне сервера ничего не меняется. Если хотите, чтобы изменения отправились на сервер, необ. добавить JS-код, кот. будет собирать изменения из элемента article и отправлять эти изменения на сервер AJAX-ом.
5. Библиотека Modernizr
Modernizr [http://modernizr.com/] — это библиотека JavaScript. Она определяет поддержку различных HTML5 и СSS3 функций в браузере и позволяет создавать запасные варианты, если в настоящее время необходимая функция не поддерживается.
Библиотека Modernizr позволит приложениям корректно работать на старых браузерах.
------------------
С помощью Modernizr можно проверить поддержку необходимой функции и определить какой JavaScript сценарии необходим клиенту. Тот, который основан на возможностях браузера и использует новые возможности HTML5 и CSS3 или тот скрипт, который программно имитирует возможноси HTML5 и CSS3

_____________________________________________________________

Тег <br> не имеет содержимого, потому в конце видим символ '/'.
_____________________________________________________________

Если в таблице нужна пустая ячейка, в td пропиши &nbsp, иначе возможно некорректное отображение.
_____________________________________________________________

Селектор класса доминирует над селектором div или p.

#id приоритетнее .class

1. Вложенные селекторы: parent child {...}
	<parent>
		<child></child>
	</parent>
"Если мы встретим тег parent, содерж. в себе тег child, применим свойства"
2. Мультиклассы: .class1.class2 {...}
	<имя тега class="class1 class2">
3. Соседний селектор: selector1 + selector2
	<selector1></selector1> <selector2></selector2>
	
<!> Вложенные  селекторы имеют > приоритет, чем обычные.
<!> Мультиклассы имеют > приоритет, чем обычные.
<!> "Такого класса нет как самостоятельного, он есть в контексте мультикласса".
	

<!> При использовании псевдо-свойств в ссылках обязательно сохранять последовательность: сначала visited, потом hover.
	
_____________________________________________________________

Метатеги содержат различную служебную информацию.
_____________________________________________________________

В смешанной верстке для div указывается свойство max-width. Причем, при max-width не появляется горизантальная прокрутка, в отличие от просто width.
_____________________________________________________________

Овальное закругление с помощью border-radius.
Также можно задать не радиус закругления, а два радиуса овальной области, которая описывает закругление: { border-radius: 10px/20px }.
_____________________________________________________________

Масштабирование textarea можно запретить с помощью CSS-свойства 'resize: none'.
_____________________________________________________________

Чтобы семантически объединить radiobutton, нужно дать им одинаковый name.
_____________________________________________________________

<select name="select1">
	<option name="text-4-server">Text for User</option>
</select>
_____________________________________________________________

Canvas - его задача создавать растровую графику в HTML-документе.
_____________________________________________________________

"Определим элемент section и с помощью itemscope укажем, что этот элемент будет сущностью с типом 'http://shema.org/Person' ".
	<section itemscope itemtype="http://shema.org/Person"></section>

_____________________________________________________________

'data-' - префикс для создания пользовательских атрибутов.
	<li data-year="1992" data-color="green" ...>
_____________________________________________________________

Modernizr проверяет наличие поддержки старыми браузерами новых фич.
_____________________________________________________________

"Если var started неравна true"
	if (!started) {...}
_____________________________________________________________

Написать сложное приложение, исп. чистый canvas и JS, будет очень тяжело. Поэтому вместе с самописным JS придется применять библиотеки. Есть множество JS-Framework, упрощающих работу с canvas.
_____________________________________________________________

НОВЫЕ СЕЛЕКТОРНЫЕ ФУНКЦИИ: querySelector

	document.querySelector([селекторы])
	// получение первого элемента, кот. соответствует селектору.
	document.querySelectorAll([селекторы])
	//получение списка элементов, кот. соответствуют селектору.

	var e = document.querySelector("#helloWorld", ".test2");
	// если не найдет элемент #helloWold, перейдет к поиску элемента с .test

	//var e = document.querySelector(".menu > li");
	// найти первый li, вложенные в элемент с .menu

_____________________________________________________________

ВЕБ-ХРАНИЛИЩА

localStorage и sessionStorage - контейнеры для локального хранения информации (на стороне клиента). Напоминают cookies значения, но позволяют хранить больший объем данных (до 5 Мб) и не передаются по сети при запросах к серверу.

'Нарушение области действия данных' - когда мы работаем на 1 сайте с неск. вкладками, и каждая  явл., своего рода, независимым приложением, локально сохраняющая значения в cookies. Но получается, что каждая вкладка, работая с одними и теми же cookies, начинает затирать значения, созданные предыдущими вкладками.

"Если нам нужно сохранить инфу, кот. будет доступна после перегрузки страницы (если после перезагрузки, мы хотим заново получить доступ к временным значениям), мы эти значения можем сохр. не в cookies, кот. будут доступны всем вкладкам, а в Session Storage, просто чтобы временно попользоваться данными, а потом их уничтожить. Если мы открываем 2 вкладку, мы опять записываем данные не в cookies, а в Session Storage. Т.о. каждая вкладка будет работать со своим локальным значением. Мы модем сколько угодно обновлять вкладку, и та не потеряет своих значений".

Сериализация - преобразование JS-объект в строку. Когда в качестве параметра передается JS-объект, а в качестве результата метод stringify() возвращает строку, кот. можно передать по сети или сохранить как строку, содержащую JS-объект, кот. потом можно восстановить из этой строки.
	window.localStorage["data"] = JSON.stringify(person);
Десериализация - из строкового представления создается JS-объект.
	var data = JSON.parse(window.localStorage["data"]);

WebWorkers (многопоточное программирование) - технология, предоставляющая веб-приложениям возможность выполнять фоновые задачи в отдельных потоках.

"Вы знаете, что JS-функции - это, по сути, объекты".

"Проверяем, существует ли в свойстве cache по ключу [x] значение".
	// Меомизация - прием кэширования результатов функции.
	function calcFib(x) {
		// Проверка наличия результата для параметра x.
		if ( !calcFib.cache[x]) {...}	// если результат не найден, то производим...
	...
	}

	
WebWorker не может получать доступ к DOM, т.е. добавлять, изменять или удалять со страницы. Worker может только отправить сообщение главному окну, а уже ГО будет вносить изменения в DOM.

	
_____________________________________________________________

"Применить ко всем input, кроме тех, чей тип submit"
	input:not([type=submit]) { ... }	// ко всем, кроме...
	// правило для всех input, которые не используют атрибут type="submit"
	
C помощью :not исключим из выборки предыдущего селектора некий диапазон элементов. В данном случае: из всез input исключим input с типом submit. 
	
_____________________________________________________________

Чтобы центрировать текст внутри блока, пропиши в CSS:

	text-align: center;
	display: table-cell;
	vertical-align: middle;
	
_____________________________________________________________

"filter: opacity(50%)" производительней, чем просто "opacity: 50%"
_____________________________________________________________

Media Queries - метод применения стилей на основе инфы об устройстве.
_____________________________________________________________














JavaScript

Переменная - это область в памяти, исп. для хранения некоторого значения.

"Во можете создать var, т.е. выделить область памяти для некоторой инфы и соранить ее".

JS - динамически, а не строго, типизированный язык программирования. Т.е. интерпретатор самостоятельно определяет тип данных в var.

Функция - это действие. И тип данных.

	var a = 10;	// целочисленное или integer
	var b = 0.8	// вещественное или float

null - этот тип данных указывает на отсутствие значения. Аналогично значениям "ничего" или "значение неизвестно".

Если alert(b), но b не определена, возникнет ошибка, кот. прервет выполнение дальнейшего кода.

Любой неициализированной var интерпретатор присваивает undefined.
Кодер видит:		var a;
Интепретатор:		var a = undefined;

AJAX позволяет посылать запросы на сервер и загружать данные без перезагрузки страницы.

_____________________________________________________________

	var a = prompt("1 или 0?",);
	alert(a);
	// если 1, то: 1
	// если 0, то: 0
	// если пустое поле, то: ""
	// если Отмена, то: null
	
	var a = confirm("Вы уверены?");	// OK (true), Отмена (false)

Конвертация строкового значения в числовое:
	parseFloat() - конвертация в вещественное значение
	parseInt() - конвертация в целочисленное значение
Данные функции возвращают значение NaN если конвертация не удалась.
	var x = parseInt(prompt("Input x value ", "0"));
	var y = parseInt(prompt("Input y value ", "0"));
	var result = x + y;
	document.write(result + "<hr/>");
	
Парсинг - когда мы проходимся (анализируем) текст в поисках опр. значений. 

-------------------------------------------------------------------------------------
	var a = -8;
	var string = "10";
	
Унарный минус (-)
	// операция смены знака на противоположный
	result = -a; 
Унарный плюс (+)
	// не изменяет знака при применении к числовому типу
	result = +a;		// -8
	// при применении к строковому типу, преобразовывает его в числовой
	result = +string + a;	// 2
-------------------------------------------------------------------------------------

Если одно значение true оно преобразуется в 1, если значение false оно преобразоваться в 0.

	var a = 1;		// простое число
	var b = true;	// логическое "истина"
	res = a == b;	// true
-------------------------------------------------------------------------------------

Преобразование строки в число:
	var a = +prompt("Введите первое число:", "сюда");

_____________________________________________________________

Конъюнкция - это логическое И  '&&'
Дизъюнкция - это логическое ИЛИ  '||'

_____________________________________________________________

Условные конструкции:
1. Условный оператор:
	if ... else
2. Тернарный оператор:
	... ? ... : ...
3. Оператор многозначного выбора (переключатель):
	switch-case-default	(default не обязателен)
Конструкция switch служит для сравнения значения на равенство с различными вариантами. Насколько понял, все они про одно, просто в разных ситуациях один удобнее другого.

switch (выражение-селектор) 

<script>
	var day = prompt("Введите день недели: ", "");
	switch (day.toLowerCase()) {
		case "понедельник":
		case "вторник":
		case "среда":
		case "четверг":
		case "пятница": {
			alert("Это рабочий день недели.");
		} break;
		case "суббота":
		case "воскресенье": {
			alert("Это выходной день.");
		} break;
		default: alert("Вы ввели несуществующий день недели");
	}
</script>

_____________________________________________________________

ЦИКЛЫ

1. while. Цикл с предусловием, который выполняется до тех пор, пока условие удовлетворяет истинности.
2. do-while. Цикл с постусловием, в кот. условие проверяется после выполнения тела цикла. Тело цикла выполняется хотя бы 1 раз.
3. for. Цикл, в кот. var - счетчик итераций цикла, с опр. шагом изменяет свое значение до заданного конечного значения.

_____________________________________________________________

Цикл for вложенный в цикл for.

	for (var i = 0; i < 10; i++) {
		// Выводим одну строку из 10 плиток.
		for (var j = 0; j < 10; j++) {
			document.write("<img src='tile.jpg' width='50' height='50'/>");
		}
		// Переход на новую строку.
		document.write("<br/>");
	}

_____________________________________________________________

МАССИВЫ

Используются, когда стоит задача сохранить множество однотипных значений, сложить их в 1 var.

МАССИВ - именованный набор нестрого типизированных var, расположенных в памяти непосредственно друг за другом, доступ к кот. осуществляется по индексу.

Вместо функции-конструктора Array() лучше исп. []: так более очевидно.



ОБЪЕКТ в JS - это ассоциативный массив. Более того, в JS объект и массив суть одно и то же, однако есть различия в синтаксисе создания и обращения к объектам.

Обращение к массиву по ключу. Данные выражения имеют одинаковое значение:
	document.write("<p>" + laptop.cpu);
	document.write("<p>" + laptop["cpu"]);

_____________________________________________________________

Методы массивов:

1. join() - преобразует все элементы массива в строки и объединяет их. Если метод принимает строковой аргумент, то аргумент станет разделителем вместо запятых.
	var arr = ["March", "April", "May", "June"];		// March,April,May,June
	var res = arr.join(" | ");	// March | April | May | June
	res = arr.join("<br/>");	// March<перенос строки>April<пс>May<пс>June
--------------------------------------------------------------------------------------
2. concat() - создает и возвращает новый массив, содержащий элементы исходного []. concat() дополняет [] указанными в параметрах элементами.
	var a = [1, 2, 3];
	a = a.concat(4, 5);				// 1,2,3,4,5
	a = a.concat(6, 7, [8, 9]);		// 1,2,3,4,5,6,7,8,9
--------------------------------------------------------------------------------------
3. reverse() - меняет порядок следования элементов массива на противоположный и возвращает переупорядоченный массив.
	var a = new Array(1, 2, 3, 4, 5, 6, 7);
	a.reverse();	// 7,6,5,4,3,2,1
--------------------------------------------------------------------------------------
4. slice() - Возвращает фрагмент или подмассив указанного массива.
	var a = [1, 2, 3, 4, 5, 6, 7];
	// slice(начальный индекс (включительно), конечный индекс (не включительно));
	var temp = a.slice(0, 3);	// возвращает первые три элемента 1, 2, 3

	// slice(начальный индекс); - возвращает подмассив от указанного индекса до конца массива.
	temp = a.slice(3);		// 4, 5, 6, 7

	// Если аргумент отрицательный - он задает позицию относительно конца массива.
	temp = a.slice(1, -2);		// 2, 3, 4, 5, 6
--------------------------------------------------------------------------------------
5. splice() - универсальный метод для вставки и удаления элементов из []. Метод возвращает массив из удаленных элементов.

	arrayObj.splice ( start, deleteCount, elem1, elem2, ... , elemN )
	// где start - индекс в массиве, с которого начинать удаление.
	// deleteCount - кол-во элементов, которое требуется удалить, начиная с индекса start.
	// elem1, elem2, ..., elemN - добавляемые элементы в []. Добавление начинается с позиции start.

Пример:
	var a = [1, 2, 3, 4, 5, 6, 7];

	// УДАЛЕНИЕ.
	// splice (начальный индекс, сколько элементов удалить)
	// Если второй аргумент опущен, удаляются все элементы до конца []
	var d = a.splice(1, 3);		// будут удалены: 2, 3, 4

	// ВСТАВКА.       
	// splice (начальный индекс = 1, сколько элементов удалить = 0, значения для вставки с начального индекса = 2, 3, 4);
	a.splice(1, 0, 2, 3, 4);		// 1,2,3,4,5,6,7
	
	
--------------------------------------------------------------------------------------
Еще push, pop, shift, unshift.

_____________________________________________________________

ФУНКЦИИ

Функция - это блок кода, кот. можно многократно вызывать для выполнения. Функция может принимать аргументы и возвращать значение.

Если есть блок кода, кот. повторяется в разных частях программы, его можно превратить в функцию и вызывать с помощью короткой записи.

Функция всегда возвращает значение. Если нет return, вернет undefined. Также return прекращает выполнение функции.

Функция в JS - это не просто синтаксическая единица, но тип данных. И любая функция, на самом деле, объект.

Переменные внутри функции - это, по сути, ключи/свойства объекта.

Внутри функции можно получить доступ ко всем аргументам, переданным при вызове функции, даже если число аргументов превышает число параметров. Для этого есть массив arguments.lenght. Массив arguments - это все значения, кот. пришли в функцию при вызове. Свойство arguments доступно только внутри функции.

Поскольку функция - это тип данных, ее можно присвоить var и получить функцию-литерал или анонимную функцию.
	var f = function () {
		document.write("<p>Hello!");
	};
	f();  // Вызов функции.
	
ИНКАПСУЛЯЦИЯ в JS - возможность прятать некую функциональность внутри функции. Посколько функция создает свою область видимости, в нее можно поместить другую функцию, кот. не будет доступна из основного кода приложения.

CALLBACK-функция или функция обратного вызова - это функция, передаваемая в качестве аругмента другой функции.

_____________________________________________________________

ОБЪЕКТ - это составной тип данных, кот. объединяет множество значений в единый модуль и позволяет сохранять и извлекать значения по именам.

Объект помимо свойств (ключей) может содержать функциональность/поведение (методы).
Даже пустой объект будет содержать свойства и методы, наследованные от родительского объекта (ПРОТОТИПА).

Помимо создания объекта через блок инициализации, можно создать через спец. конструктор Object(). Он не принимает никаких параметров, 
а перед ним обязательно должно указываться ключевое слово new.
Свойства объекта будут создаваться автоматически при первом обращении 
по имени будущего свойства и присвоения ему значения.

"Свойство f правильно называть методом, потому что это поведение, кот. хранится в объекте".

При обращении к свойству объекта внутри его метода, используй префикс this.
	var human = {
		firstName: "Alex",
		occupation: "Web Developer",
		show: function () {
			document.write("<p>First name: " + this.firstName);
			document.write(this.occupation + "<hr/>");
		}
	}

FOR IN

Циклическая конструкция for in, используется для перебора элементов массива или перебора свойств объекта. Как foreach в PHP.
Принцип работы конструкции:
	for ( переменная_итерации in массив_или_обьект) { ...тело конструкции ...}

Перебор значений свойств в обьекте house:
	for (property in house) {...}
или
	for (var element in house) {
		// создание var, кот. будет перебирать свойства в объекте house
	document.write(house[element]);
		//выводим на экран var, кот. перебирала свойство
	}

ЕСЛИ в объекте house имеется планировка третьего этажа thirdFloor:
	if ("thirdFloor" in house) {	// ТО строим 3 этаж с планировкой thirdFloor
		document.write(house["thirdFloor"]);
	} else { 			// ИНАЧЕ строим 3 этаж с планировкой secondFloor
		document.write(house["secondFloor"]);	// или house.secondFloor
	}

УДАЛЕНИЕ свойства secondFloor из объекта house:
	if ("secondFloor" in house) {
		delete house.secondFloor;
	}

_____________________________________________________________








JavaScript ДЛЯ ПРОФЕССИОНАЛОВ

Конструкторы - это специальные функции, которые заполняют пустой объект свойствами и методами.

"Ключевое слово new создает объект => Объект передается в функцию => Функция этот объект конфигурирует, и настроенный объект возвращается в var point".
	var point = new Object();
	
Виды конструкторов:
1. Object().
2. Date().
3. Array().
4. String().
5. Function().

Пару слов об использовании 'new'.
Системные конструкторы обычно реализованы таким образом, чтобы создавать объекты без исп. ключевого слова new. Но если вы пишете свои собственные конструкторы, то без new они будут работать неправильно.

Строку можно создать, исп. обычный литерал (var simpleStr = "Some text"), либо конструктор ( var objectStr = new String("Some text") ). Во 2 случае будет создан ОБЪЕКТ строкового типа. Разница между ними в том, что объект будет содержать стандартные для его типа свойства и методы.

-----------------------------------------------------------
	var simpleStr = "My String";			// переменая со строковым значеним
	var objectStr = new String("some String object");		// строковой объект
	
	// Добавлять новые свойства и методы можно только к объектам созданым через оператор new.
	objectStr.customProperty = 123;		// 123
	// Добавить свойство в simpleStr невозможно!
	simpleStr.customProperty2 = 123;		// undefined
-----------------------------------------------------------

Каждый раз, когда в JS-коде вы обращаетесь к простому значению (integer / string / boolean ), интерпретатор временно превращает это значение в объект, чтобы вы могли с этим значением взаимодействовать.

Особенность работы js-интерпретатора: каждый раз при работе в простым значением, будь то строка или число, примитив временно превращается в объект, чтобы у нас была возможность взаимодействовать с его методами и свойствами.

<!> Использование конструктора Function() нежелательно.
Конструктор Function позволяет динамически создавать и компилировать анонимные функции. Конструктор Function принимает неограниченное количество параметров, последний параметр всегда является телом создаваемой функции, параметры, которые передаются в начале списка аргументов Function, являются входными параметрами для генерируемой функции.
	// Создаем функцию, которая принимает два параметра с именем x и y и тело, которое возвращает их сумму.
	var func = new Function("x", "y", "return x + y;");
	var result = func(20, 10);	// 30

'Функция-конструктор' - это функция, кот. создает пустой объект и определяет его свойства и методы. Есть правило: ФК объявляются с заглавной буквы.

'Что отличается ФК от обычной функции?' Использованием keyword this.
В своем теле ФК исп. this, чтобы добавить объекту свойства.
Ключевое слово new создает пустой объект, передает этот объект функции, а внутри функции мы можем получать доступ к этому объекту посредством this.

Объявление:
	function Point(x, y) {
		this.x = x;		// добавляем свойство х
		this.y = y;
	}
"Создали пустой объект, бросили его в ФК, ФК добавила пустому объекты 2 свойства, и объект с 2 свойствами был записан в var p. Если мы продублируем эту строчку 10 раз, 10 раз вызовем new Point(), то мы создадим 10 объектов с одинаковой структурой, наполнением".	
Вызов:
	var p = new Point(10, 20);	// создается объект типа Point
	

Как мы отличаем 1 тип данных от другого? Мы смотрим на свойства, состояния и поведение объекта. Если объекты имеют одинаковые свойства и методы, значит, они относятся к 1 типу. Можно даже сказать, что в JS вместо типов исп. ВИДЫ.
	
this в коде блока функции указывает на то, что она конструктор.

this всегда ссылается на тот объект, с кот. вы работали, когда запускали метод.


Когда свойства и методы привязаны к конкретному объекту, мы можем сказать, что это свойства экземпляра и методы экземпляра.


"Мы рассмотрели, как, используя собственные конструкторы, можно создать что-то наподобие типов данных, сделать так, чтобы по к-то шаблону можно было создавать неск. объектов, имеющих одинаковые свойства и методы".

_____________________________________________________________

ПРОТОТИПЫ

Каждая ФК связана с прототипом. Каждая функция содержит в себе ссылку на прототип, а прототип 

"Создавая функцию, мы создаем объект, в кот. хранится поведение."

new устанавливает ссылку на специально спрятанное свойство '__proto__'. Т.е. в каждом объекте JS есть свойство __proto__, кот. связывает объект с прототипом. Когда мы ФК создаем объект, в этом объекте свойство __proto__ ссылается на прототип, с кот. была связана ФК.

Создаем в прототипе метод. Вызываем метод через экемпляр. Интерпретатор проверит экземпляр, не найдет нужного метода, тогда обратиться к свойству __proto__, которое направит его к прототипу. Если прототип содержит нужный метод, он будет вызван, если нет - возникнет ошибка.

this всегда ссылается на тот объект, с кот. вы работали, когда запускали метод.

ПРОТОТИП  =>  ФУНКЦИЯ-КОНСТРУКТОР  =>  ЭКЗЕМПЛЯР

object является прототипом для всех объектов в JS. Поэтому, например, на любом объекте мы можем вызвать метод hasOwnProperty.

<!>При сравнении объектов сравниваются их свойства.

<!> Методы всегда лучше помещать в прототип.


ИНКАПСУЛЯЦИЯ - сокрытие реализации и данных объекта. Получается, что объект может прятать от внешнего мира методы или свойства, чтобы другие не могли ими пользоваться.

_____________________________________________________________

РАБОТА С ДОКУМЕНТАМИ

'ОБЪЕКТ window' - это глобальный объект, который представлет из себя контейнер, выполняющий весь JS-код. Т.е. когда мы в своем коде создаем глобальную var или функцию, они будут представлять собой свойство и метод объекта window.

'DOM' - это дерево, которое строит браузер, когда качает разметку с сервера.

'Событийная модель' позволяет реагировать на опр. действия пользователя.


СПОСОБЫ ИНТЕГРАЦИИ JS-КОДА

1. В тэге Script в head страницы.
	<script type="text/javascript">
		// JavaScript код
	</script>
2. Из внешнего файла.
	<script type="text/javascript" src="script_file.js"></script>
</head>
3. В качестве обработчика события через html атрибут.
	<input type="button" value="Кнопка" onclick="alert('Hello')" />
4. Как тело URL адреса (псевдо-протокол).
	<a href="javascript:alert('Hello')">Ссылка</a>
5. В тэге Script в body страницы.
	<script type="text/javascript">
		// JavaScript код
    </script>
6. Из внешнего файла.
    <script type="text/javascript" src="script_file.js"></script>

	
ПРОСТРАНСТВО ИМЕН

Создать пространство имен можно 2 способами: объекты-модули и самоосуществляющиеся функции.

Разбирается ситуация, когда к документу подключаются 2 js-файла с одной глобальной var. В итоге возникает конфликт, и значение 1-ой var переписывается значением 2-ой.

Чтобы этого избежать, можно исп. объекты в качестве модулей. Эти модули создадут пространство имен для var. В результате var будут иметь одно имя, но находиться внутри разноименных объектов, и конфликта не произойдет. 

Можно исп. самоосуществляющуюся функцию. Внутри нее можно спокойно объявлять и вызывать любые var.
	( function () { /* ... */ } )();
Это функция безымянная, поэтому не добавляет никаких свойств объекту window. Кроме того, она не создает никаких глобальных имен. Объявленные внутри фнукции var никому не мешают и сущ. только внутри нее.

"Весь JS-код выполняется в контексте глобального объекта window."

Подробнее в видео "Урок 3. Работа с документами".

_____________________________________________________________

ИЕРАРХИЯ ОБЪЕКТОВ КЛИЕНТСКОГО JS

'window'
'navigator' - доступ к инфе о текущем браузере, можем исп. геолокационное API, чтобы узнать текущее месторасположение клиента и много чего.
'location' - можем узнать, на какой странице сейчас находится пользователь.
'frames' - можем опр. кол-во фреймов в текущем документе.
'history' - позволяет контроллировать историю посещения пользователя.
'screen' - инфа о текущем разрешении экрана.
'document' - мы получаем доступ к текущей разметке, к тому дереву элементов, кот. создал браузер, когда получал с сервера html-разметку.

Все вышеперечисленное - свойства объекта window, и каждое из свойств содержит в себе соответствующий объект. Например, свойство history содержит в себе объект History.

Самый простой способ взаимдействия с DOM - исп. свойства объекта Document:
elements[] - массив элементов формы; 
forms[] - массив объектов Form; коллекция всех элементов форм;
links[] - массив объектов Link; коллекция всех ссылок на странице;
images[] - массив объектов Image; коллекция всех картинок.
Эти свойств намного больше. Например, в коллекции forms[] находится коллекция elements[] (все input, кот. есть в формочке).

-----------------------------------------------------------
Использование метода document.write():
	<p style="padding: 8px; margin: 8px; color: Green; font-weight: bold; border: solid 1px black;">
		<script type="text/javascript">
			document.write("hello");
			document.write(" 1", "-", "2", "-", "3");
		</script>
	</p>
-----------------------------------------------------------
	
При вызове метода document.write() после формирования страницы происходит создание нового документа, поэтому данный метод не следует вызывать в обработчиках событий, чтобы не потерять содержимое текущей страницы.

Важно знать, что document.write() можно применять, только когда мы строим документ. После того, как документ был загругружен браузером и полностью сформирован, мы не имеем права вызывать document.write(), потому что это приведет к созданию нового пустого документа, в кот. заново будет генерироваться контент.
document.write() нормально использовать при первичной отрисовке страницы, например, внутри <p>. Но никогда не исп. данный метод для обработчиков событий: содержимое документа будет перезаписано.

_____________________________________________________________

'document' - это объект, в кот. с помощью свойств можно получить доступ к содержимому текущей страницы.

-----------------------------------------------------------
Создаем var paragraph и записываем в нее document.getElementById("output"). Т.о. мы говорим, что хотим получить элемент в id="output". Теперь при вызове js-кода браузер находит в дереве нужный элемент и ссылку на этот элемент записывает в параграф. Теперь, если мы в коде будем взаимодействовать с var paragraph, на самом деле мы будем работать с указанным объектом в документе.

	<p id="output">Hello world</p>
	<script>  var paragraph = document.getElementById("output");  </script>

-----------------------------------------------------------

_____________________________________________________________

Конструкция window.onload = function() { ... }

window - глобальный объект. onload - событие, кот. запускает браузер, когда полностью проанализирует HTML-код, загрузит с сервера все картинки, сценарии, css-файлы - т.е. когда вся страница будет полностью загружена и готова к работе.


"Браузер на событие onclick добавляет обработчик".
	document.getElementById("answerButton").onclick = function() { ... }

_____________________________________________________________

DOM - это дерево, кот. строит браузер на основе разметки, скаченной с сервера. Каждый тег превращается в соответствующий узел дерева, и с помощью JS мы можем находить, менять, удалять, добавлять свойства этим узлам. По сути, мы можем манипулировать содержимым всего документа с помощью JS-кода.

Все, что браузер скачал, вся HTML-разметка превращается в элементы, в узлы, которые заложены в 1 корневой узел document.


DOM МЕТОДЫ
-----------------------------------------------------------
	// Методы для работы с DOM
	// appendChild - добавить дочерний элемент
	// insertBefore - добавить элемент перед указанным
	// removeChild - удаление элемента
	// replaceChild - замена одного элемента на другой

	window.onload = function () {
		var div1 = document.getElementById("div1");

		var p1 = document.createElement("p");
		p1.innerHTML = "Paragraph 1";
		div1.appendChild(p1);

		var p2 = document.createElement("p");
		p2.innerHTML = "Paragraph 2";
		document.body.insertBefore(p2, div1);
	}
-----------------------------------------------------------

DOM АТРИБУТЫ
-----------------------------------------------------------
	window.onload = function () {
		var a1 = document.getElementById("a1");
		var a2 = document.getElementById("a2");
		var a3 = document.getElementById("a3");

		// установка атрибута
		a1.setAttribute("href", "http://edu.cbsystematics.com");

		// удаление атрибута
		a2.removeAttribute("href");

		// чтение атрибута
		alert(a3.getAttribute("href"));
	}
	
	<a id="a1">Text a1</a>
	<a id="a2" href="http://edu.cbsystematics.com">Text a2</a>
	<a id="a3" href="http://edu.cbsystematics.com">Text a3</a>

-----------------------------------------------------------

_____________________________________________________________

НЕСТАНДАРТНАЯ ЗАПИСЬ ЦИКЛА for

	for (var x = e.firstChild; x != null; x = x.nextSibling) {...};

1 компонент - указание, какую var будем исп. в качестве счетчика. 2 - опр. условия выполнения цикла. 3 - операция, кот. нужно сделать в конце каждой итерации.
Т.о., мы указываем, что нашим счетчикм будет var x. Она изначально будет содержать в себе значение firstChild, т.е. в var x будет записан первый дочерний элемент этого объекта. Далее мы будем крутить цикл до тех пор, пока var x не станет = null. И чтобы на каждой итерации мб получать дочерний узел, мы выполняем вот такое действие в конце каждой итерации: в var x заисываем x.nextSibling.


<!> Каждый раз, когда существующий узел дерева мы помещаем в это же дерево, со старого места он удаляется, а в новом появляется.

_____________________________________________________________

ТАЙМЕРЫ

1. setTimeout (функция, таймаут, параметры для функции) - планирует запуск функции через определенное количество миллисекунд.

2. setInterval (функция, интервал, параметры для функции) - похож на setTimeout, но автоматически заново планирует повторное использование
метода.

-----------------------------------------------------------
1 вариант.
	setTimeout(showMessage, 5000);	// функция запуститься через 5 секунд
	function showMessage() {
		alert("Hello world");
	}
2. вариант.
	setTimeout(function () {
		alert("Hello world");
	}, 5000);

Любая функция, кот. создает таймер, возвращает объект (в данном случае это timer), кот. записывается в var.
	timer = window.setTimeout(showMessage, 5000);
Таймер можно отключить с помощью:
	function cancel() {
		clearTimeout(timer);
	}

-----------------------------------------------------------
Пользовательская функция для получения элементов страницы по id:
	var get = function (id){
		return document.getElementById(id);
	}
Задача функции принимать идентификатор и возвращать объект, кот. найден в DOM-дереве страницы с помощью document.getElementById().
-----------------------------------------------------------
document.location - это весь URL-адрес.

Вызываем метод split() и передаем в качестве значения "&". Задача split() разбить строку на массив по опр. разделителю.
	var pairs = query.split("&");		// Разделение строки по амперсанду
-----------------------------------------------------------
var с = new String("my string");
	и
var d = String("my string");
	сработают одинаково.
-----------------------------------------------------------
РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ

Есть 4 метода, кот. принимают РВ:
1. search.
2. repalce.
3. match.
4. split.
_____________________________________________________________


CSS и JS

CSS - формальный язык описания внешнего вида HTML-документа.

Способы подключения CSS:
1. Связанный стиль:
	<link href=“StyleSheet.css” rel=“stylesheet” type=“text/css” />
2. Глобальный стиль
	<style type=“text/css”>
		p { color: red; }
	</style>
3. Внутренние стили:
	<p style=“color: Green; font-weight: bold; font-size: 25px;”>Hello world</p>
	
СВОЙСТВО POSITION
1. 'absolute' - позволяет задать абсолютное позиционирование элемента относительно содержащего его элемента.
Такие элементы позиционируются отдельно от остальных элементов. Абсолютное позиционирование элемента происходит либо относительно тела документа, либо, если он вложен в другой абсолютно позиционируемый элемент, относительно этого элемента. 
Значение по умолчанию - static. Элементы со static позиционированием не могут быть перемещены с помощью свойств left и top.
2. 'relative' - элемент располагается в соответствии с нормальным потоком вывода, а затем его положение смещается относительно его обычного положения в потоке.
3. 'fixed' - позволяет зафиксировать элемент относительно окна браузера. Элементы с таким позиционированием не прокручиваются с остальной частью документа, такие элементы не зависят от остальных.


Те стили, которые задаются через css и вычисляются браузер, называются Computed Styles. К этим стилям нельзя обратиться с в JS с помощью свойства style. В JS можно получить доступ к стилям, кот. были заданы через атрибуты либо непосредственно JS-кодом через свойство '.style='.

Вообще, 'COMPUTED STYLES' или 'Вычисляемые стили' может оказаться важной темой. Урок 5.

<!>Все методы, кот. создаются в объектах, желательно помещать в прототипы, потому что метод для всех объектов будет иметь одинаковую функциональность. Поэтому нет смысла дублировать метод в каждом объекте, лучше этот метод перенести в прототип.
_____________________________________________________________

Устанавливаем обработчикидля событий onmousemove и onmouseout. onmousemove - это событие, кот. неоднократно вызывается, пока курсор мыши двигается над поверхностью элемента. onmouseout - это событие, кот. вызывается, когда курсор мыши выходит за пределы документа.
Каждый раз, когда браузер запускает обработчик событий, браузер при запуске функции обработчика передает в нее спец. объект, кот. содержит основные сведения о событии: когда, почему и где событие произошло.

	// Ф принимает 1 параметр - это и есть данные, приходящие от браузера
	function mouseMoveHandler(e) {
		if (!e) e = window.event;	// если браузер прислал undefined...
	}

"Чтобы реализовать такое поведение, размещаем div, кот. и будет менять свой цвет. Далее после div создаем скрипт. Т.к. скрипт находится после элемента, кот. предстоит исп. и изменять, нам не нужно создавать обработчик на загрузку документа (window.onload)".


ИНТЕРЕСНЫЙ ПРИЕМ
-----------------------------------------------------------
	var colors = ["white", "yellow", "orange", "red"]
	var nextColor = 0;
	// Вызов следующей функции каждые 500 миллисекунд для анимации цвета.
	setInterval(function () {
		e.style.backgroundColor = colors[nextColor++ % colors.length];
	}, 500);
-----------------------------------------------------------

_____________________________________________________________

ПЛАВНОЕ ИЗМЕНЕНИЕ ЦВЕТА
-----------------------------------------------------------
	var e = document.getElementById("rect");		// где rect - это div

	e.style.width = "100px";
	e.style.height = "100px";
	e.style.border = "solid black 1px";

	var color = 0;

	setInterval(function () {
		color = color + 1 % 360;
		e.style.backgroundColor = "hsl(" + color + ", 100%, 50%)";
	}, 50);
-----------------------------------------------------------
_____________________________________________________________

СОБЫТИЕ

Это сообщение, кот. может возникнуть в различных точках исполняемого кода при опр. условиях. События в программировании нужны для того, чтобы программа могла реагировать на изменения.

Обработчик события - это функция, кот. запускается в момент возникновения события.


МОДЕЛИ ОБРАБОТКИ СОБЫТИЙ в DOM Level 0

1. Код в атрибуте элемента:
	<p onclick="alert(hello)"></p>
2. Код в отдельной функции:
	<p onclick="handler()"></p>
	<script>
		function handler(){}
	</script>
3. Ненавязчивый JS (когда JS-код исп. внутри <script>, а не в HTML-разметке. Такой код проще сопровождать):
	<p id="test"></p>
	<script>
		var p = document.getElementById("test");
		p.onclick = function(){}
	</script>


НЕКОТОРЫЕ СОБЫТИЯ
'onblur' - потеря фокуса. Когда сначала был активен 1 элемент, а после другой.
'DOMContentLoaded' - говорит, что HTML-разметка была скачена, превращена в DOM-дерево, и можно выполнять JS-код на странице, т.к. вы имеете все необходимые элементы, с кот. будет взаимодействовать JS-код. Но при этом еще не завершилась загрузка стилей, картинок, фреймов. Т.е. страница еще не полностью загружена, но HTML-разметка уже превратилась в DOM-дерево. Похож на 'onload'.


<!> undefined эквивалентно false.

<!> 'Урок 6. События и обработка событий' на 00:26:48 про скобки после имени функции.

-----------------------------------------------------------
C помощью this мы получаем доступ к элементу, кот. является инициатором/отправителем события.
-----------------------------------------------------------

МОДЕЛИ ОБРАБОТКИ СОБЫТИЙ в DOM Level 2

	addEventListener(event, handler, capture);
	где
	event - имя события. Без приставки "on".
	handler - функция-обработчик.
	сapture - параметр указывает, на каком этапе запустится функция-обработчик (true - на этапе перехвата, false - всплывания).

Установка и удаление обработчика:
	btn1.addEventListener("click", handler, false);
	btn1.removeEventListener("click", handler, false);

Одно из преимуществ DOM L2 над L0 - это возможность на 1 объект добавить неск. обработчиков.
-----------------------------------------------------------
ПРОВЕРКА, ЗАПОЛНИЛ ЛИ ПОЛЬЗОВАТЕЛЬ ПОЛЕ ВВОДА:

	window.addEventListener("load", function () {
		document.forms[0].addEventListener("submit", function (e) {
			if (document.getElementById("nameInput").value.length == 0) {
	// Если поле пустое - отменить действие по умолчанию
				e.preventDefault();
				alert("Введите имя");
			}
		}, false);
	}, false);
-----------------------------------------------------------

Задача 'preventDefault()' - отменить действие по умолчанию.
Задача 'stopPropagation()' - остановить выполнение события по DOM-дереву, распространение события от 1 узла к другому.
document.forms[0].addEventListener("submit", function (e) {
                if (document.getElementById("nameInput").value.length == 0)
                {
                    // Если поле ввода пустое - отменить действие по умолчанию, которое связанно с событием.
                    e.preventDefault();
                    alert("Введите имя");
                }
            }, false); 
"Событие будет идти вверх к корневому элементу <html>"
	
_____________________________________________________________

ОБЪЕКТ СОБЫТИЯ (event)

Чтобы хорошо обработать событие, могут понадобиться детали: координаты курсора, введённый символ и другие, в зависимости от события. Детали произошедшего браузер записывает в «объект события», который передаётся первым аргументом в обработчик.

	elem.onclick = function(event) {
		// вывести тип события, элемент и координаты клика
		alert(event.type + " на " + event.currentTarget);
		alert(event.clientX + ":" + event.clientY);
	}

event.type - тип события, в данном случае click.
event.currentTarget - элемент, на котором сработал обработчик.
Значение в точности такое же, как и у this, но бывают ситуации, когда обработчик является методом объекта и его this при помощи bind привязан к этому объекту, тогда мы можем использовать event.currentTarget.
event.clientX/Y - координаты курсора в момент клика (относительно окна).

Объект события содержит ценную информацию о деталях события. Он передается первым аргументом event в обработчик для всех браузеров, кроме IE8-, в которых используется глобальная переменная window.event.

Подробнее здесь: https://learn.javascript.ru/obtaining-event-object

_____________________________________________________________

ЕЩЕ ПРО СОБЫТИЕ

Шаблон, позволяющийй получить объект события:
-----------------------------------------------------------
	window.onload = handler;
	// параметр e будет передаваться в IE только при регистрации события через attachEvent
	function handler(e){
		if (!e) e = window.event; // получение информации о событии в IE
		// тело обработчика события
	}
	function handler2(event) {
		var e = event || window.event; // второй вариант.
	}
-----------------------------------------------------------

Свойство .target всегда содержит в себе тот объект, кот. был инициатором события.

_____________________________________________________________

ИНТЕРФЕЙС EVENT В МОДЕЛЕ DOM

function handler(e) {
	// тип события
	var message = "type = " + e.type + "\r\n";

	// узел документа, в котором произошло событие, может не совпадать currentTarget
	message += "target = " + e.target + "\r\n";

	// узел чей обработчик события работает в данный момент. На этапах перехвата и всплывания значение свойства отличается от target.
	message += "currentTarget = " + e.currentTarget + "\r\n";

	// число указывающее этап. Одна из констант Event.CAPTURING_PHASE=1, Event.AT_TARGET=2, Event.BUBBLING_PAHSE=3
	message += "eventPhase = " + e.eventPhase + "\r\n";

	// объект Date, указывающий, когда произошло событие.
	message += "timeStamp = " + e.timeStamp + "\r\n";

	// true если событие может всплывать по дереву элементов. События blur, focus, load, unload не высплывают.
	message += "bubbles = " + e.bubbles + "\r\n";

	// true если с этим событие связано действие по умолчанию и его можно отменить с помощью вызова метода preventDefault();
	message += "cancelable = " + e.cancelable + "\r\n";

	alert(message);
}

<!> События blur, focus, load, unload не высплывают.

Еще раз, чтобы закрепить:
	function handler(e) { ... }	// Ф handler принимает объект события


_____________________________________________________________

ИМИТАЦИЯ HOVER В JS

	window.onload = function () {
		var p = document.getElementsByTagName("p")[0];
		// курсор вошел в пределы элемента.
		p.onmouseover = function () {
			this.style.backgroundColor = "green";
		}
		// курсор вышел за пределы элемента.
		p.onmouseout = function () {
			this.style.backgroundColor = "yellow";
		}
	}
_____________________________________________________________

Свойство coords.
	clientX
	layerX
	offsetX
	screenX
_____________________________________________________________

События для клавиш:
'onkeydown' - подойдет для комбинации клавиш.
'onkeypress' - чтобы получать символы, кот. вводит пользователь.

_____________________________________________________________

ЗАПРЕТ НА ВВОД ОПРЕДЕЛЕННЫХ СИМВЛОВ

	// вешаем обработчик на загрузку документа, событие load будет обрабатываться функцией init
	window.addEventListener("load", init, false);	
	function init() {
		// с помощью getElements... находим все input в doc и записываем их в []
		var inputs = document.getElementsByTagName("input");
		// запускаем цикл, чтобы перебрать массив
		for (var i = 0; i < inputs.length; i++) {
			// создаем временную var e, куда записываем индексы
			var e = inputs[i];
			// запускаем ряд проверок
			// пропускаем элементы input, которые не поля вводов
			if (e.type != "text") continue;
			// пропускаем элементы, у которых нет атрибута data-chars-allowed
			if (e.dataset.charsAllowed == undefined) continue; 
			// dataset - свойство, дающее возможность обратиться к атрибутам data-*
			// другой способ получения атрибута
			//if(e.getAttribute("data-chars-allowed") == undefined)
			e.addEventListener("keypress", keyFilter, false);
	}
_____________________________________________________________

<!> Когда исп. свойство dataset (e.dataset.charsAllowed), то в этом свойстве будет находиться объект, кот. содержит в себе свойства в соответствии с именами пользовательских (data-*) атрибутов в разметке.
_____________________________________________________________

Запись инициализации var
-----------------------------
var startX = event.clientX,
	startY = event.clientY;
-----------------------------
_____________________________________________________________

"Вы действительно хотите закрыть вкладку?"

	window.onbeforeunload = function () {
		return "Вы уверены, что хотите закрыть окно?";
	}
_____________________________________________________________

ФОРМЫ

Форма - это спец. элемент HTML-разметки для отправки введенных пользователем данных на сервер. 

Первое, что необходимо сделать при работе с form - это получить ссылку на DOM-элемент, кот. предоставит нам функциональность взаимодействия с пользователем. Т.е. мы должны получить объект, кот. представляет форму.

СПОСОБЫ ПОЛУЧЕНИЯ ФОРМЫ
1. Если создаем в разметке форму, не опр. для нее никаких атрибутов, мы можем получить к ней доступ посредством свойства .forms:
	<form></form>  =>  var f = document.forms[0];
В свойстве forms находится коллекция всех форм, опр. на странице.
2. Исп. форм с атрибутом name. Если задаем форме атрибут name, значение кот. уникально, то мы можем обратиться к одноименному свойству объекта document.
	<form name="test"></form>  =>  var f = document.test;
	

СПОСОБЫ ПОЛУЧЕНИЯ ЭЛЕМЕНТА

<form>
	<input type="text" />				// document.forms[0].elements[0];
	<input id="e" type="text" />			// document.getElementById('e');
	<input name="element" type="text" />	// document.forms[0].element;
	// если у input есть атрибут name, он автоматом становится свойством формы
</form>

_____________________________________________________________

Т.к. значение, записываемое в куки, может хранить в себе спец. символы, рекомендуется всегда при записи куки исп. метод encodeURIComponent().

	function setCookie() {
	// Чтобы связать временное значение cookie файла с текущим документом. достаточно выполнить следующую операцию
	document.cookie = "version=" + encodeURIComponent(document.lastModified);
	// Cookie не могут содержать точку с запятой, запятые или символы разделители. Перед сохранением значение в cookie желательно вызвать функцию encodeURIComponent(). При чтении значения надо вызвать decodeURIComponent().
	// Записанный таким способом cookie сохраняются в текущем сеансе браузера но удаляются после его закрытия.
	}

_____________________________________________________________

WEB STORAGE

WS бывает 2 форматов: 'session storage' и 'local storage'. Это контейнеры, кот.  хранят данные на стороне клиента. Эти данные не будут отправляться по сети, а будут сохраняться в браузере и смогут исп. JS-кодом для к-то операций.

Cookies имеют недостатки. Так, мы не можем сохранить в куки-наборы значения > 4кб, а если и сохраним, то при отправке на сервер у нас постоянно будет отправляться куки вместе с запросом. В итоге мы будем потреблять > трафика, будем забивать канал лишними данными, кот. отправляются на сервер с запросом.

Если данные, кот. мы записываем в куки, нужны нам только для локального хранения, мы можем исп. вместо куки Session или Local Storage.

	btn1.onclick = function () {
		window.sessionStorage.setItem("key1", "Test value");
		// или
		window.sessionStorage.key2 = "Test value 2";
		// или
		window.sessionStorage["key3"] = "Test value 3";
	}

Сессия живет, пока открыта вкладка. Если надо хранить данные для всего сайта и хранить долго, даже если мы закроем браузер, надо исп. Local Storage.

	btn1.onclick = function () {
		window.localStorage.setItem("key1", "Test value");
		// или
		window.localStorage.key2 = "Test value 2";
		// или
		window.localStorage["key3"] = "Test value 3";
	}

_____________________________________________________________

ТЕХНОЛОГИИ ДЛЯ СОЗДАНИЯ ГРАФИКИ

SVG и VML (Vector Markup Language) - это технологии, кот. позволяют создавать изображения в виде XML-файлов. Браузер скачивает с сервера XML и превращает XML-документ в набор графических элементов, кот. видит пользователь.
SVG - это векторная графика, и если мы будем масштабировать изображение, у нас не будет теряться качество, потому что браузер будет перерисовывать изображение в соответствии с правилами, кот. заданы в XML-файле.
Исп. SVG оч удобно в JS-коде, т.к. JS легко взаимодейстует в DOM-моделью и может менять элементы, кот. находятся в HTML-документе. Также легко JS может изменять элементы, из кот. состоит SVG или VML файлы. Получается, с помощью JS мы можем динамически добавить новый элемент в SVG, изменить или удалить его, тем самым изменив изображение.


ЗАХВАТ ИЗОБРАЖЕНИЯ
-----------------------------------------------------------
	window.onload = function () {
		var img1 = document.getElementById("logoImg");	// получение по id
		// Использование коллекции images объекта document. В ней находятся все картинки текущего документа. Можно обращаться в pic по индексу либо по значению атрибута name.
		// Значение name может исп. как имя свойства
		var img2 = document.images.logo;		// получение по name (способ 1)
		//  или в качестве индекса при обращении к images как к массиву
		var img3 = document.images["logo"];	// получение по name (способ 2)
		// Если атрибут name являются уникальным для img в текущем документе:
		var img4 = document.logo;				// если name уникальный
	}
    <img id="logoImg" name="logo" src="images/logo.png" alt="CyberBionic Systematics" />
-----------------------------------------------------------

ПРО СМЕНУ ИЗОБРАЖЕНИЯ

Урок 10. Работа с графикой. 7 минута.
_____________________________________________________________

"C помощью document.getElementById('chartContainer') получаем ссылку на элемент с id='chartContainer'."
_____________________________________________________________

В JS один из способ конвертации любого значения в boolean - это использование двойного отрицания '!!'.
	return !!document.createElement("canvas").getContext;
"Если getContext undefined, браузер поймет это как false. Первый '!' превратит undefined в противоположенное значение, т.е. в true, в второй '!' - в false. В итоге функция вернет false. Если в getContext содержится объект, фукнция, кот. можно вызвать, ее наличие расценится как true".
_____________________________________________________________

'HTTP ПРОТОКОЛ' - это набор правил, определяющих общение между браузером и сервером.

'AJAX' - модель построения веб-приложений, в кот. страницы обновляются частично. Когда мы создаем обычную страницу, при выполнении к-то действий, пользователь инициирует ее полную перезагрузку: нажав на кнопку, на сервер уходит запрос, и возвращается новая страница, кот. заменяет текущую. Если используем AJAX-архитектуру, нажав на кнопку, мы отправляем на сервер запрос, приходит ответ, но в ответ приходит не вся страница, а только кусочек обновленной инфы, кот. мы вставляем в документ.
С помощью AJAX мы делаем частичное обновление страницы, а не полную перезагрузку.

Весь AJAX заключается в исп. 1 типа данных: 'XMLHttpRequest'. 

AJAX исп. спец. объект 'XMLHttpRequest', кот. делает запрос к серверу, получает ответ и использует его для обновления части документа. Т.о., не сам браузер качает новые данные, а качает спец. объект, созданный в JS-коде.
Вот когда мы исп. этот спец. объект, мы и создаем AJAX-документ.

	window.onload = function () {
		document.getElementById("btnGet").onclick = function () {
			// Создание объекта для HTTP-запроса
			var xhr = new XMLHttpRequest();
			// Настройка объекта для отправки асинхронного GET запроса
			xhr.open("GET", "testfile.html", true);

			xhr.onreadystatechange = function () {
				if (xhr.readyState == 4) {	// если получен ответ
					if (xhr.status == 200) {	// и если статус-код ответа 200
						// responseText - текст ответа полученного с сервера
						document.getElementById("output").innerHTML += xhr.responseText; 
					}
				}
			}
			xhr.send();		// Отправка запроса, так как запрос асинхронный сценарий продолжит свое выполнение. Когда с сервера придет ответ сработает событие onreadystatechange
		}
	}
	
Если мы делаем асинхронный запрос, нам обязательно установить обработчик на событие 'onreadystatechange'.


.ashx - специальный файл технологии ASP.net, кот. исп. для обработки запроса. Эти файлы еще называют handler'ами или HTTP-обработчиками. Задача хендлера получить запрос и выдать ответ.

Если мы делаем GET-запрос, то данные, кот. отправляются на сервер, идут прямо в адресной строке. Когда делаем GET-запрос на сервер, то на сервере ничего не меняется: сервер только ищет данные и возвращает результат.
Если делаем POST-запрос - мы отправляем на сервер к-то инфу, кот. будет исп. для внесения изменений в состояние приложения. Например, создание новой записи в базе.

"Сообщение будет отправляться не в адресной строке, а в теле самого сообщения. Сервер, получив это сообщение, может исп. его для того, чтобы поменять к-то свое внутренне состояние."




=========================================================
jQuery
=========================================================

Событие 'ready' происходит в момент готовности DOM-дерева, что происходит раньше начала загрузки "тяжелых" мультимедийных файлов. Это оптимальный момент, когда можно приступить к установке обработчиков различных событий и выполнять другой подготовительный javascript-код.
ВАЖНО! 
Если подготовительные действия требуют наличия таких элементов как картинки, правильным будет полагаться на событие load. Однако, имейте ввиду, что одновременное использование .ready() и <body onload="..."> приведет к ошибке. Если вам необходимо использовать оба события, используйте метод библиотеки jQuery .load(), вместо <body onload="...">.

_____________________________________________________________

СЕЛЕКТОРЫ

$("*") - выбор всех элементов на странице
$("p").css("color", "red") - выбор всех p и установка СSS-свойства color: red
$("p,ul").css("color", "red") - выбор тегов <p> и <ul> на странице
$("div p").css("color", "red") - выбор всех <p> внутри <div>
$("p + div").css("color", "red") - выбор всех <div>, кот. следуют за <p> и находятся на том же уровне вложенности
$("div > span").css("color", "red") - выбор <span>, являющихся child для <div>
$("div:has(ul)").css("background", "red") - выбор всех <div>, имеющим хотя бы один вложенный <ul>
$("p.red").css("color", "red") - выбор всех <p> с классом "red"
$("p#red").css("color", "red") - выбор всех <p> с id="red"
$("span ~ p").css("color", "red") - выбор всех <p>, кот. предшествует <span> на том же уровне вложенности
$("a[target]").css("color", "red") - выбор всех ссылок с атрибутом "target"
$("input[type=text]").val("admin") - выбор всех <input> с "type=text". С помощью метода val() добавляем первому <input> атрибут 'value' со значением "admin". 
--------------------------------------------
$("a[href^='http://']") - выбор всех ссылок, у кот. значение атрибута 'href' начинается c "http://"
$("a[href$='.com']") - выбор всех ссылок, у кот. значение атрибута 'href' заканчивается на ".com"
$("a[href*='html']") - выбор всех ссылок, у кот. значение атрибута 'href' содержит "html"
--------------------------------------------
$('p').eq(0).text("Выбираем первый параграф") - eq() - метод, который позволяет выбрать нужный элемент из массива по индексу
$('[name="input_background"]') - элементы, у кот. атриб. name="input_background"
$('.bold_paragraph') - элементы с классом "bold_paragraph"
$('#red_paragraph') - элементы с id "red_paragraph"

Метод в HTML5.
'querySelector()' - получение первого элемента на странице, который соответствует селектору.
	var paragraph = document.querySelector("p");
	paragraph.style.fontSize = "30px";
'querySelectorAll()' - возвращает массив элементов, соответствующих селектору. 
	var list = document.querySelectorAll(".list > li");
	// В данном случае возвращается массив элементов списка, находящихся в элементе ul с атрибутом class="list"
	
________________________________________________________



               +=======================+
===============|    ФИЛЬТРЫ В jQuery   |===============
               +=======================+

+-----------------------+
|    БАЗОВЫЕ ФИЛЬТРЫ    |
+-----------------------+

:even - выбор элементов с четным индексом
	$('table tr:even')
:odd - эл-в с нечетным индексом
	$('table tr:odd')
:eq(i) - выбор эл-та коллекции по индексу
	$('table tr:eq(4)')
:first - первое совпадение
	$('table tr:first')
:last - последнее совпадение
	$('table tr:last')
:first-child - первый дочерний эл-т набора
:last-child - последний дочерний эл-т набора
:only-child - если эл-т явл. единственным дочерним
	$('div p:only-child') - применить стили к <p>, если он единственный ребенок

:nth-child - выборка на основе нумерации DOM-дерева
:nth-child(n) - дочка №n
:nth-child(even) - четная дочка
:nth-child(odd) - нечетная дочка
:nth-child(an+b) - каждый a + b

:eq - выбор эл-та по индексу
:gt - все эл-ты с индексом >
	$('p:gt(3)');	// [4, ...]
:lt - все эл-ты с индексом <
	$('p:lt(4)');	// не включительно, т.е. [0, 1, 2, 3]

:not(n) - выберет все элементы из массива выборки кроме тех, которые соответствуют "n".
		$("li:not(:eq(3))");		// выберет все эл-ты, кроме эл-та с индексом 3

:header - получение всех заголовков
	$(':header') == $('h1, ..., h6')

:animated - возвращает эл-ты, в кот. происходит анимация

+------------------------+
|    ФИЛЬТРЫ КОНТЕНТА    |
+------------------------+

Позволяют ориентироваться на содержимое элемента, и искать, выбирать только те эл-ты, кот. соответствуют опр. содержимому.
------------------
:contains('text') - фильтр, который выбирает все элементы, в которых встречается указанный текст
	$("p:contains('HTML')").css("background-color", "red");
:empty - все эл-ты, в кот. отсутствует содержимое
	$('div:empty')
:has(el) - все эл-ты, кот. содержат указанный эл-т 
	$('div:has(p)')

+------------------------------+
|    ДОП. ФИЛЬТРЫ АТРИБУТОВ    |
+------------------------------+

$('elem[attr~=val]') - выбор всех эл-в с атрибутом, содержащим значение val, разделенное пробелом.
$('elem[attr!=val]') - выбор всех эл-в с атрибутом, не содержащим значение val.
	$("a[target!='_blank']");

+--------------------+
|    ФИЛЬТРЫ ФОРМ    |
+--------------------+

:button - выбирает все кнопки на странице (как <button>, так и <input type="button">)
	$(":button").css("font-weight","bold");
:checkbox - выбор всех элементов "checkbox"
	var count = $(":checkbox").length;
:checked - выбирает только отмеченные флажки или переключатели
	var n = $("input:checked").length;
:disabled - выбирает эл-ты форм в неактивном состоянии
	<input type="" disabled="disabled">
	$("input:disabled").val("disabled");
:enabled - выбирает эл-ты форм в активном состоянии
	$("input:enabled").val("enabled");
:file - выбирает все элементы типа "file"
	$(":file").css("border", "1px solid red");
	
______________________________________________________

РАБОТА С CSS В jQuery

Функция .css("свойство", "значение"):
	$("p").css("color", "green")
Функция .css( { набор свойств } ):
	$("p").css( {background: "Red", fontSize: "18pt"} )

_____________________________________________________________

РАБОТА С DOM-ДЕРЕВОМ

// Метод eq(n) - возвращает элемент, идущий под индексом 'n' в наборе выбранных элементов.
	$("div").eq(2).addClass("blue");
Есть еще фильтр:
	$("div:eq(2)").addClass("blue");
Но исп. метод лучше.

// Метод filter(function). Если передать методу filter() некоторую функцию, он вызовет ее для каждого элемента в наборе и исключит те элементы, для которых эта функция вернет значение false.
// Эта функция получает доступ к текущему элементу набора через $(this).

	$(function () {
	// В качестве параметра "index" функция будет получать порядковый номер обрабатываемого элемента. Если Ф возвращает true - элемент проходит проверку и попадает в результирующий набор данных.
		$("p").filter(function (index) {
			// Если текущий <p> содержит атрибут align и его индекс [0], то true.
			if ($(this).attr("align") && index == 0) { return true; }
			// Применяем свойства с подходящим элементам.
		}).css("background-color", "red");
	});


// slice(start,end) - выделяет подмножество из набора совпавших элементов. Ведет себя точно как встроенный метод разделения массивов.
// Выделение подмножества начинается с индекса "start" (включительно) по индекс "end" (не включительно).
	$("#btn1").click(function () {
		$("p").css("background-color", "green");
		$("p")
			.slice(0, 3)
			.css("background-color", "red");
	});


'find(selector)' - отыскивает дочерние элементы, которые удовлетворяют указанному выражению.
	var newText = $("p") // находим все параграфы
		.text()          // извлекаем текст из параграфов
		.split(" ")      // разбиваем текст по пробелам
		.join("</span> <span>"); // оборачиваем каждое слово в span

_____________________________________________________________

$('p') - получаем набор параграфов
_____________________________________________________________

Метод 'html()'

Получает HTML-содержимое первого элемента в наборе соответствующих элементов или устанавливает HTML-разметку для каждого совпавшего элемента.

---------------------------------------
	$("p").click(function () {
		alert( $(this).html() );
	});
	
	<p><b>Test string</b></p>
---------------------------------------
.html() извлекает не текст, как в случае с text(), а HTML-разметку. Мы получим не "Test string", а "<b>Test string</b>".

Пример вставки разметки:
	$("p").html("<u>Hello world</u>");

_____________________________________________________________

// wrap() - вставляет каждый совпавший элемент набора в указанную конструкцию HTML кода. Этот процесс наиболее полезен для встраивания дополнительной структуры в документ без необходимости разрушения его первоначальных семантических свойств.
// empty() - удаляет все содержимое из каждого элемента в наборе совпавших элементов.
// remove() - удаляет все совпавшие элементы из DOM. Эта функция НЕ удаляет элементы из объекта jQuery, позволяя Вам воспользоваться ими позже. Обратите внимание, начиная с версии 1.2.2 эта функция также удаляет все обработчики событий и внутренние закешированные данные.

	$(function () {
		$("span").wrap("<div>");

		$("#clearBtn").click(function () {
			$("p").empty();
		});

		$("#removeBtn").click(function () {
			$("span").remove();
		});
	});

_____________________________________________________________

СОБЫТИЯ И ОБРАБОТЧИКИ

Пользователь своими действиями на странице (будь то нажатие клавиши или шевеление мышью) вызывает события, и JS-код способен реагировать на эти события, отлавливая их и обрабатывая.

	addEventListener("a", b(c){}, d);		// стандартный обработчик событий в JS
Данный метод предназначен для добавления обработчика («слушателя») события. Он принимает 3 параметра:
a - название события;
b - функция-обработчик события; 
c - объект события, передаваемый в функцию-обработчик;
d - "этап прохождения события", на кот. будет запускаться обработчик. true - этап tunnel (перехват), false - bubble (всплывание).

----------------------------------------------------------
'ready' - определяет функцию, кот. будет запущена после полной загрузки DOM
	// Первый вариант.
	$(document).ready(function () {
		alert("Page Loaded I");
	});

	// Второй вариант.
	$(document).ready(after_ready);
	function after_ready() {
		alert("Page Loaded II");
	}

	// Третий вариант вариант. (Сокращенная запись)
	$(function () {
		alert("Page Loaded III");
	});
----------------------------------------------------------
	// focus - событие происходит, когда элемент получает фокус
	$("input").focus(function() {
		$(this).val("focus");
	});

	// blur - событие происходит, когда элемент теряет фокус
	$("input").blur(function() {
		$(this).val("blur");
	});
----------------------------------------------------------
Нативный метод .preventDefault().

	document.forms[0].addEventListener("submit", function (e) {
		if (document.getElementById("nameInput").value.length == 0) {
			// Если поле ввода пустое - отменить действие по умолчанию, которое связанно с событием.
			e.preventDefault();
			alert("Введите имя");
		}
	}, false); 
----------------------------------------------------------
Нативный метод .stopPropagation(). 

	e1.addEventListener("click",
		// e - параметр хранит объект с информацией о событии.
		function (e) {
			this.style.backgroundColor = "green";
			alert("Обработчик DIV 1");
			// прекращение дальнейшего маршрута события.
			e.stopPropagation();
		},
	false);
	
ВНИМАНИЕ! Исп. только с методом bubble (false)
----------------------------------------------------------
БЛИН!
preventDefault() и stopPropogation() - это про разное. Первый отменяет действие события по умолчанию, а второй - чисто про распространение события.

----------------------------------------------------------
Метод on()

	$("#button").on("click", function (event) { ... } );
	или
	$("#button").click( function (event) { ... } );

	
// Метод on(событие, обработчик) используется для привязки обработчиков на события к объекту или объектам.
// Также есть возможность передавать дополнительные данные в виде объектов.

	$(function () {
		function user_info(event) {
			$('#out').html("Login: " + event.data.login + "<br />" + "Password: " + event.data.password);
		}
		// Создание и передача дополнительных данных в виде объектов
		var access = { login: 'admin', password: '12345' };
		$('#button').on('click', access, user_info);
	});

_____________________________________________________________

CallBack-функция - это функция, кот. выполняется по окончанию чего-то.
_____________________________________________________________

Не просто this, а $(this).
_____________________________________________________________

// div: hidden: first  - первый скрытый div
	$("div:hidden:first").fadeIn("slow");
_____________________________________________________________

	.datepicker("option", "", ) меняет функциональные характеристики datepicker.
_____________________________________________________________

	$(function () {							// после загрузки DOM-дерева
		$("#datepicker").datepicker();		// получаем текстовый input по id
		// метод change() сработает, когда выберем 1 из пунктов droplist'а
		$("#anim").change(function () {		// и вызываем на нем метод datepicker
			// смена анимации для datepicker
			$("#datepicker").datepicker("option", "showAnim", $(this).val());
		});
	});
	
	<select id="anim">
            <option value="show">Show (default)</option>
		...
	</select>
_____________________________________________________________

<!>'Когда получаем набор элементов с помощью $(), мы получаем не полноценный массив, а массивоподобный объект.'
_____________________________________________________________

"Библиотека MooTools больше предназначена для объектно-ориентированного программирования."
_____________________________________________________________

// jQuery.noConflict() - отказываемся от использования переменной $ как объекта-контейнера для функциональности jQuery.
// Данный подход часто используется, чтобы решить конфликты при использовании других JS-библиотек вместе с jQuery.

	$(function () {
		var newJ = jQuery.noConflict();		// теперь newJ - псевдоним $
		newJ("#div1").css("background-color", "green");
		jQuery("#div2").css("background-color", "green"); 
		// Глобальная переменная jQuery продолжает работать
		$("#div3").css("background-color", "green");
		// Глобальная var $ перестает использоваться после вызова noConflict
	});
	
	
	$(function () {
		var newJ = jQuery.noConflict(true);   // true - удалить все global var в jQuery
		newJ("#div1").css("background-color", "Green");
		jQuery("#div2").css("background-color", "Green");
		$("#div3").css("background-color", "Green");
	});

_____________________________________________________________

AJAX - это:
1) фоновый обмен данных между браузером и сервером;
2) локальное/фрагментарное обновление страницы.

При AJAX-запросах сервер возвращает XML или JSON файлы.

ashx - формат файла, написанного на C# с исп. технологии ASP.net, кот. предназначен для того, чтобы мы могли считать данные, кот. будут передаваться через POST-запрос.

'003_data.html - очень полезная информация' !!!

_____________________________________________________________

.serialize() - возвращает строку с именами и значениями выбранных элементов форм. Эта строка будет иметь формат параметров url-запроса.
---------------------------------------------------------------------------
	var data = $('form').serialize();	// login=abc&password=123
	
	<form>
		<input type="text" name="login" value="abc" />
		<input type="text" name="password" value="123" />
	</form>
---------------------------------------------------------------------------	
"Метод извлек значения и сразу преобразовал их в нужный формат для отправки запроса на сервер".
"Извлекает все данные из форм и отображает их как одну строку".

_____________________________________________________________

JSON

Удобнее всего данные на сервер передавать не по 1 паре "ключ-значение", а сразу пачкой в виде объектов. Но просто объект мы передать не можем, для этого исп. преобразования в JSON-объект.
----------------------------------------------------------
	var student = {
		name: "Ivan",
		age: 25,
		course: "jQuery"
	}

	// JSON.stringify() - метод для сериализации объекта в JSON
	var data = JSON.stringify(sudent);	// сериализация
	alert(data);	// '{ "name" : "Ivan", "age" : "25", "course" : "jQuery" }'

	// JSON.parse() - метод для десериализации данны из JSON в JS объект
	var obj = JSON.parse(data);
	alert(obj.name + "\r\n" + obj.age + "\r\n" + obj.course);
----------------------------------------------------------



_____________________________________________________________


_____________________________________________________________


_____________________________________________________________


_____________________________________________________________


_____________________________________________________________


_____________________________________________________________


_____________________________________________________________


_____________________________________________________________


_____________________________________________________________


_____________________________________________________________


_____________________________________________________________


_____________________________________________________________


_____________________________________________________________



