.htaccess - то файл конфигурации веб-сервера для конкретного домена.

<?php ... ?> - php-вставка или теги-ограничители.

Секция -> Обертка -> Элементы.
Для обертки используем max-width в пикселях.

Сервер это приложение которое предоставляет веб-контент клиенту.

DNS - это телефонная книга интернета.

Протоколы - это простые языки, позволяющие компьютерам обмениваться данными независимо от ПО или ОС.
Протокол - это просто стандартизированный формат для передачи данных между двумя устройствами.

Хост - это любое устройство в сети Интернет, имеющее сетевой интерфейс.

Объектно-ориентированный и процедурный.

DOCUMENT_ROOT - это корневая директория сервера.

DNS преобразует доменное имя в IP-адрес.

<meta name='robots' content='noindex' />

array.length соответствует наибольшему индексу массива +1.

'Регулярное выражение' - это объект, кот. описывает набор символов или символьный шаблон, кот. можно исп. для поиска подстрок в к-либо тексте.
Язык для описания шаблонов, кот. задают правила поиска в тексте.

<?php if ( have_posts() ); ?>	// если записи есть...
<?php while ( have_posts() ); ?>	// до тех пор, пока записи есть...

Бывает 2 вида архитерутуры: 2-уровневая и 3. В 2-ур есть клиент и сервер, в 3 - клиент, application-server (сервер приложений) и database-server (сервер БД).

С помощью протокола мы регламентируем, как должны строиться сообщения, какова их структура, какие команды мы в них различаем, какие способы передачи инфы будет исп. длина сообщения.

В HTTPs есть инструменты, обеспечивающие защищенность передачи данных: SSL/TLS (шифрует пакеты данных) и Public/Private Key (подпись цифровым сертификатом - цифр. ключи).
------------------------------------------------------------------------------------------------
ПРИМЕР ЗАПРОСА HTTP:
	GET /courses/networks HTTP/1.1	метод  |  ресурс  |  версия протокола
	HOST: www.asozykin.ru				заголовок  |  доменное имя
Этого достаточно, чтобы веб-сервер ответил.


ПРИМЕР ОТВЕТА ВЕБ-СЕРВЕРА:
HTTP/1.1  200 OK		версия протокола  |  статус (код ответа)
Server: nginx		реализация сервера
Content-Type: text/html; charset=UTF-8		тип передаваемой страницы
Content-Length: 5161		длина страницы
	либо
Connection: close/open (если есть C-Length)	"Соединение нужно закрыть"
	(пустая строка)
<!DOCTYPE html>
------------------------------------------------------------------------------------------------
<!> MIME-Type и Content-Type в вебе 1 и то же. Он обязательно нужен браузеру, чтобы отобразить документ. Без остальных заголовков в принципе может обойтись.

HTTP-метод HEAD получает только заголовки без тела документа. Исп. ботами.

АВТОРИЗАЦИЯ - когда для доступа к ресурсу надо ввести логин-пароль.

ВЕБ-сервер как готовый продукт редко содержит в своем коде ошибки и редко возвращает 500 ошибку. Однако Application-Server, кот. запускает ваше веб-приложение, кот. генерирует ваши динамические страницы, часто может отдавать 500 ошибку. Это происходит, если серверный скрипт приложения не сработал должным образом.

'Общие заголовки HTTP' неободимы для управления соединением или форматом содержимого (того, что передается в теле запроса). Поэтому они могут присутствовать как в запросе, так и в ответе: управление соединением требует 2-стороннего принятия решения.

Set-Cookie - заголовок ответа, когда сервер передает клиенту куку (хеш-ключ), а Cookie - это заголовок запроса, когда клиент возвращает серверу куку.

DOM Content Loaded - когда все объекты на странице были распарсены в DO-модель браузером.

Для кэширования основным заголовком является Expires, если хотим принудительно закэшироваать ресурс: сказать, что вот этот файл не будет меняться до такой-то даты, можешь исп. его и не перезапрашивать.

По-хорошему, каждому web-разработчику нужно уметь писать HTTP-запросы в Telnet. Т.е. открыли Telnet, на 80 порт, запросили любой ресурс.

Раньше файлы ужимали с помощью минификации, сейчас - gzip.

Статику нужно кешировать принудительно, складывать ее в к-то домен, на отдельный быстрый сервер. Часто динамику разносят со статикой. Т.о. снимается нагрузка с сервера. Динам. конетент кешировать бессмысленно.

Редирект можно сделать в заголовке http-запроса, в html-теге <meta> и в JS.

Куки отправляются с каждым запросом на соответствующий домен. Если набралось 4КБ кук, то с каждым запросом, помимо 100 байт значимой инфы, я 4кб кук отправляю с запросом. Т.е. более 1,5Кб в пакет уже не влазеет. Средний размер пакета ~1кб. Если инфа не влезет, будет исп. больше 1 пакета для запроса страницы, и в сумме это уменьшит кол-во передаваемых данных и замедлит отдачу страниц

CSS спрайт. Внимательней с gif, т.к. у них индексированная палитра 256 цветов, и надо так подбирать css спрайт, чтобы они были в одной цветовой гамме.

Уменьшай кол-во запросов к CSS и JS, уменьшая кол-во самих файлов.
Большшой файл браузер рендерит быстрее, чем много маленьких.

Chunked encoding
В радиционном ответе всегда дб загловок Content-Length. Это нужно на случай keep-alive соединения, чтобы вы знали, когда окончатся байты предыдущего соединения, и можно будет отправить след запрос. Кроме длины, нет другого признака, по кот. можно понять, когда закончился ответ сервера на ваш запрос. Поэтому его нужно указывать.
Если вдруг на начало генерации страницы вы не знаете длину стр., кот. получится, для этого есть механизм кодировки сообщений с неизвестной длиной - chunked-encoding, - в нем контент записывается блоками по неск. байт (1024байт по умолчанию): т.е. пишется начало блока, в блоке 1024байта, потом след. блок и т.д. Его можно включить явно, либо сервер сам посмотрит, что вы не дали ему длину, и начинает кодировать в chunked и отправлять браузеру.
Т.о., если у вас страница переменной длину, не статика, и вы заранее не знаете, сколько будет байт, вы можете с помощью протокола HTTP/1.1 начать передавать, не зная длину страницы.

Есть метод API, кот. позволяет сделать асинхронный запрос и получить данные, но во всех браузерах это ограничено тем же самым доменом. Т.е. вы можете отправлять AJAX-запрос только на тот домен, с кот. загружена страница.

SAAS (software as a service) - то же, что десктопные приложения, но онлайн.

Клиенто-серверное приложение.
Клиент - браузер. Сервер - компьютер в дата-центре. Веб-сервер - приложение, кот. работает на этом компе.

Клиент обращается к серверу, открывает сетевое соединение, отправляет запрос, веб-сервер отвечает на запрос и возвращает в браузер страничку. Сама html-страничка хранится на веб-сервере, клиент получает ее от сервера по сети.

Что происходит после того, как браузер получил IP адрес. Он устанавливает сетевое соединение (TCP). Для браузера TCP-соединение выглядит как файл, в кот. он может что-то записать и прочитать из него - называется 'socket'. Браузер открывает сокет, кот. устанавливает сетевое соединение с удаленной машиной. Далее нужно по этому сокету передать запрос и получить ответ. В каком формате передавать запрос?

	*** ЗАПРОС ***
'GET /wiki/страница HTTP/1.1'
GET - метод HTTP-запроса. Что хочет браузер/клиент от сервера? В данном случае - документ.
/wiki/page - URL, ИД документа на сервере. В данном случае он неуникален, т.к. начинается с '/' - это ИД в пределах 1 сервера.
HTTP/1.1 - тип протокола и его версия.
"Потом идут заголовки. Заголовки представляют собой 'ключ: значение'. C их помощью передаются разные опции при передаче файлов. Например, мы можем получать сжатый контент, поддерживаем тока рус яз, длина содержимого, тип содержимого."
'Host: ru.wikipedia.org' -
'Accept: text/html' -
'Connection: close' -
(пустая строка)
	*** ОТВЕТ ***
'HTTP/1.1 200 OK'
'Server: Apache'
'Content-Language: ru'
'Content-Type: text/html; charset=utf-8'
'Content-Length: 1234'
'Contention: close'
(HTML)

Стандарты того, как нужно структурировать данные. В протокле HTTP сказано: есть первая, есть заголовки, потому пустая строка, далее тело запроса/ответа.

Чем форматы отличаются от протоколов? Форматы описывают структуру данных, а протоколы - процесс передачи данных.

XML - это разметка с помощью тегов. Исп. в вебе, json и jsonp. Это форматы для описания древовидной структуры данных в JS и не только в нем.

CSV исп. для передачи таблиц.

URI vs URL
URI - более общее понятие, это ИД ресурса, формат идентификатора. Это набор правил, по кот. строится уникальный ИД чего-либо. Есть ограничения на исп. символы. Основное правило в след: если хотите сделать URI id, у вас первое слово до ':' - это схема, кот. показывает тип ИД. Например, если ИД начинается с mailto:me@tut.ru - это почтовые адреса.
URL - подмножество URI. Он указывает, откуда можно получить ресурс.

Веб-сервер - это программа, кот., в самом простом варианте, отдает файлы с диска. У нее есть 1 важная настройка, она написана в конфигурационном файле 'DocumentRoot' (DocumentRoot=/htdocs)/. DocumentRoot - это имя директории, из кот. веб-сервер программы отдает файлы.

Разобрал = Распарсил

Работа веб-сервера действительно заключается отчасти в том, чтобы путь, кот. указан в URL, преобразовать в действительный путь к файлу. Он берет путь из URL, склеивает его с DocumentRoot, получает абсолютный путь и этот файл возвращает клиенту.

Гиперссылки - это адреса других документов внутри тела данного.
Ссылка может ссылаться на участок текущего документа - это якорь: "#chapter1".

ФОРМЫ
<!>Для получения инфы исп. метод GET. Если хотите изменить инфу - метод POST.

Для того, чтобы генерировать динамические файлы, веб-сервер должен уметь запускать к-то программы. Поэтому был разработан протокол CGI (Common Gateway Interface - «общий интерфейс шлюза») - это соглашение, по кот. веб-сервер для генерации ответа может запустить к-то внешнюю программу.

JS в браузере оживляет страничку. Когда браузер получил HTML-файл, он разбирает его и стоит DOM-дерево. Т.е. html-файл для браузера представляет дерево, соответственно, вложенные теги - это вложенные элементы. У каждого элемента есть обработчики событий.
С помощью JS можно динамически загружать данные. Обычно данные загружаются, когда пользователь кликает по ссылке или отправляет форму, причем перезагружается вся страница целиком, и потом загружаются все связанные файлы (стили, скрипты и проч). С помощью JS можно сделать http-запрос без перезагрузки страницы: отправляется запрос, получает часть инфу с сервера

В JS функция - это объект первого рода.

'Замыкание' - функция+ее лексическое окружение на момент создания. Лекс. окр. - это множество var, кот. опр. вне функции.

JS, если на пальцах, - это язык программирования браузера.
Как работает браузер?
Браузер загружает html-файл с сервера, парсит его, преобразуя html в дерево; html - вложенная структура тегов, браузер анализирует ее и строит дерево - DOM (DOM - объектное представление html). Потом он отрисовывает/рендерит дерево на экране в соответствии с CSS. Затем он позволяет пользователю что-то делать. Так вот, JS исп., чтобы изменить этот DOM. Если вы меняете это дерево налету, без перезагрузки страницы, браузер перерисовывает ее. Кроме того, браузер перехватывает действия пользователя и генерирует события. Когда браузер что-то делает, браузер вызывает обраотчики, привязанные к конкретному элементу дерева. Например, submit в форме.

this указывает на тот элемент, на кот. сработало событие.

JS в браузере однопоточный, поэтому функции выполняются последовательно, строго по очереди.

document. - это самый верхний DOM-элемент, глобальная var, свойство объекта window.

Свойство window - location. C помощью JS можно изменить URL страницы, перезагрузить текущую страницу или редиректнуть. Если присвоить location r-то URL - это аналогично редиректу со стороны серва.

(int) 10 / 3 = 3 - явное преобразование в целое число.
intdiv(10,3) = 3 - в PHP7

$_GET['param'] - получение параметра из строки запроса.

$ или jQuery - точка входа.


AJAX-запрос средствами jQuery:
	$.ajax({
		url: '/vote.php',
		data: { id: 33, action: 'like' },
		success: function (data, status) {
			alert('ok:' + data);
		},
		error: function (xhr, status) {
			alert('fail: ' + status);
		}
	});


Как работает бесконечный скроллинг?
Есть событие скролл, кот. срабатывает при прокрутке документа. На это событие вешается обработчик, кот. получает значения координат: до какой степени вы прокрутили документ. Он сравнивает их с высотой документа, и если видит, что вы прокрутили до конца (ну, или до 70%), он делает ajax-запрос и полученные данные вставляет в низ ленты. URL страницы остается прежним.
(01:50:00)

Полезные мелочи jQuery - это 'data-* атрибуты'. Если надо передать к-то данные в JS, допустим, из шаблонизатора, то правильней и удобней это делать через data-атрибуты. Из $ иэти данные можно получить через функцию .data(). Например:
	<a id="myid" data-mydata="yep">CLICK</a>
	$('#myid').data('mydata');
Соответственно их можно установить:
	$('#myid').data('flag', 'on');
Т.е. это такое хранилище данных, кот. вы можете привязать к вашим тегам.

Самые крутые виджеты были собраны в jQuery UI. Фактически это набор плагинов, кот. предоставляют разные граф. элементы.

"Как передавать данные?"
Можно передавать их 2 способами:
1. Через объекты, явно указывая имя: значение.
2. В виде строчки. Есть прекрасный метод serialize() в $. Он сериализует форму, т.е. он пройдет по все параметрам и соберет их в то, что вы видите в GET-запросе: urlFormEncoded, когда они соединены через & и прочее.

Желательно не исп. глобальные var. Для это нужно создать для них отдельную scope с помощью самоосуществляющейся функции:
	(function() {
		// do some work
	})();
Внутри нее можно объявлять var, кот. будут жить внутри нее. Это функции сразу выполняется. Фактически код внутри функции выполнится, но var уже будут не глобальными и не будут замусоривать пространство. Глобальные var можно создать как свойство объекта window.

----------------------------------------------------------------------------------------------
ОЧЕНЬ ПОЛЕЗНАЯ ВЕЩЬ ДЛЯ ВЕРСТАЛЬЩИКА
"Исп. разные классы для JS и верстки. Желательно разделять классы, кот. отвечают за структуру данных (коммент, кнопка внутри коммента), от тех, кот. отвечают за дизайн. Так, классы JS могут иметь префикс 'js-' ".
----------------------------------------------------------------------------------------------

"Эта функция без имени. Это значит, мы хотим исп. ее только 1 раз".


ДУДАРЬ

var - это ячейка памяти.

Чтобы создать константу исп. ключевое слово define.
	define("ИМЯ_КОНСТАНТЫ", "Значение");
Чтобы убедиться в существовании константы есть defined():
	echo defined("ИМЯ_КОНСТАНТЫ");	// 1 (true)

Точка - это строковый оператор, исп. для конкатенации, т.е. объединения неск. строчек в 1 строку.

Логическое операции:
	$bool = $x == $y;		// если true, то true
	$bool = !($x == $y);		// если true, то false
	$bool = !($x != $y);		// если true, то false
Исключающее ИЛИ:
	$bool = $x != $z ^ $y > $z;	// вернет true, если 1 выражение true, а др. false
	$bool = !($x != $y && $z < $x) || $x != $y;

В PHP 0 и "" - это false.

В PHP можно записывать как 'elseif', так и 'else if'.

Оператор switch:
	$x = 12;
	switch ($x) {
		case "Hello": echo "Это строка"; echo "Это определенно строка"; break;
		case 12: echo "Эта переменная равна 12"; break;
		// break прервет последовательное выполнение оставшихся case
		default: echo "Инструкция по умолчанию не обязательна";
	}

Цикл делает 1 и ту же операцию неск. раз.

Цикл for:
	for ($i = 0; i < 10; i += 2) {
		echo "Цикл #$i<br>";
	}
Цикл while:
	$x = 0;
	while ($x < 10) {
		echo "Итерация № $x <br>";
		$x++;
	}

Функция:
	function printSum($first, $second) {
		return ($first + $second);
	}
	$a = 1;
	$b = 2;
	printSum($a, $b);		// 3

Добавить элемент в конец массива:
	$array[] = "Новый строковый элемент";
Чтобы вывести все элементы массива, исп. цикл.
	for ($i = 0; $i <= count($array); $i++) {	// count считает с 1, поэтому <=
		echo "Элемент с индексом $i = ".$array[i]."<br>";
	}

-------------------------------------------------------------------------------------------------
Ассоциативный []:
	$assoc = ["name" => "Vladimir", "age" => 25, "has_girl": false];

Для АМ есть спец. цикл 'foreach', кот. перебирает массив по ключу, извлекая значение каждого эдемента и помещая его в собственную var.
	foreach ($assoc as $key => $value) {
		$sum += $value;
	}

Получим среднее значение массива:
	$assoc = ["first" => 12, "second" => 45, "third" => 23, "fourth" => 55];
	function getAverage ($assoc) {
		foreach ($assoc as $key => $value) {
			$sum += $value;
		}
		return $sum / count($array);
	}
	getAverage($assoc);
-------------------------------------------------------------------------------------------------

'Двумерный массив' - это тот, в кот. каждый элемент является другим массивом.
	$assoc = [ [12, 4.46, "string", true], ["Example", 25, false], [45, "strong"] ];
	echo $assoc[0][2];	// string
Также можно вывести все значения элементов массива:
	for ($i = 0; $i < count($assoc); $i++) {
		for ($j = 0; $j < count($assoc[$i]); $j++) {
			echo $assoc[$i][$j]. " ";
		}
		echo "<br>";
	}

ОБЛАСТЬ ВИДИМОСТИ VAR
Есть глобальная, локальная и статическая.
Глобальные var определяются в основном коде и всегда доступны для вызова.
---------------------------------------------------------------
Обращение к глобальной var внутри функции в PHP:
	$x = 10;
	function() {
		$GLOBALS["x"] += 17;
		либо объявив внутри
		global $x; $x = 27;
	}
	echo $x;	// 27
---------------------------------------------------------------
Статическая var исп. только внутри функции и каждое ее новое значение будет запоминаться. Она недоступна вне функции, но как-будто глобальная. Если опр. функцию, кот. будет инкрементировать значение static var, и поместить ее в цикл, то каждый раз цикл, вызывая функцию, будем возвращать нам новое значение. Т.о., со static var мы получим "1, 2, 3, 4, 5", тогда как без - "1, 1, 1, 1, 1".
	function test_2() {
		static $id;
		$id++;
		echo $id"<br>";
	}
	for ($i = 0; $i < 5; $i++) {
		test_2();
	}

Подключение документов:
	require "header.php";
	require_once "header.php";
	include "footer.php";
	include_once "footer.php";

Чтобы получить все данные, отправленные пользователем, сущ. 3 суперглобальных var: $_REQUEST (получает данные, отправленные как get-, так и post-методом), $_GET, $_POST.

Способ вернуться на прежнюю страницу:
	<?php
	if (isset($_POST["done"])) {	// проверяет, сработала ли кнопка submit
		if ($_POST["name"] == "") {
			echo "Введите имя <a href='/'>Попробовать еще раз</a>";
		} else {
			header("Location:index.php");
		}
	}
	?>
	...
	<input type="submit" name="done" value="Готово">

==================================================

ФУНКЦИИ

ДЛЯ РАБОТЫ С ТИПАМИ ДАННЫХ
	isset($x) - проверяет существование var $x.
	unset($x) - полностью удаляет var $x.
ПРОВЕРКА СООТВЕТСТВИЯ ТИПУ:
	is_numeric($x) - является ли $x набором цифр. И 15 и "15" вернет true.
	is_integet($x) - является ли числовым литералом.
	is_double() - является ли float, нецелочисленным.
	is_string() - является ли строкой.
	is_bool() - является булином.
	is_scalar() - является ли примитивом, простым литералом (не [] и не {}).
	is_null() - true, если var undefined.
	is_array() - является ли массивом.
	gettype($x) - узнать тип var.

СТРОКОВЫЕ ФУНКЦИИ
	$string = "This is example!";
	strlen($string) - количество символов в строке.
	strpos($string, "exa") - найти позицию символа в строке	// 8
	strpos($string, "is", 4) - найти <...>, начиная с 4 позиции	// 5
		if (strpos($string, "T") == false) echo "T не найдено";
		else echo "T найдено";	// true, потому что [0] = null = false
		// нужно строгое равенство ===
	substr($string, 3);			// s is example
	substr($string, 3, 7);		// s is ex
	substr($string, 3, -2);		// s is exampl
	str_replace("is", "abc", $string);	 // Thabc abc example!
	str_replace(["is", "ple"], ["abc", "123"], $string);	 	// Thabc abc exam123!
ПРОВЕРКА ОТПРАВЛЕННЫХ ПОЛЬЗОВАТЕЛЕМ ДАННЫХ
	htmlspecialchars() - преобразует спец. символы в HTML-сущности: '<' в '&lt;'
	// принимая данные от юзера, всегда применяем к ним эту функцию
	strtolower() - приведение к нижнему регистру
	strtoupper() - приведение к ВЕРХНЕМУ регистру
	trim("   delete spaces   ") - удаляет пробелы по краям

ФУНКЦИИ ДЛЯ РАБОТЫ С МАССИВАМИ
$array = [12, 17, 5, 23, 56];
	count($array) - считает кол-во элементов	// 5
	sort() - сортировка по возрастанию
	rsort() - сортировка по убыванию
	asort()
	arsort()
	alist()
	ksort() - сортировка по ключам ASC
	krsort() - сортировка по ключам DESC
	shuffle($array) - перемешать элементы в массиве
	in_array(10, $array); - проверяет наличие элемента в массиве
	array_merge($arr_1, $arr_2) - объединяет массивы, все элементы сохраняются
**	$array = [1, 2, 3, 4, 5, 6, 7];
	array_slice($array, 1,)			// 2 3 4 5 6 7
	array_slice($array, 1, 2)		// 2 3
	array_slice($array, 1, -2)		// 2 3 4 5
САМЫЕ ЧАСТОИСПОЛЬЗУЕМЫЕ
	count()
	sort()
	unset($array[0]);

ФУНКЦИИ ДАТЫ
	time()
	microtime(true)
		$start = microtime(true);
		echo "Прошло: ".(microtime(true) - $start)." секунд";
	date("Y-M-D H:I:S");
	getdate();
==================================================

РАБОТА С ФАЙЛАМИ
	fopen() - открывает файл или URL и проводит с ними манипуляции


Глобальный массив '$_SERVER' хранит всю инфу о пользователе, зашедшем на вашу страничку. Исп. для статистики. С помощью нее можно узнать, откуда пользователь пришел, с какой и на какую страничку, с какой страны, IP и мн. др.
	$_SERVER["REMOTE_ADDR"];	// 192.168.0.1


СОЗДАНИЕ РЕДИРЕКТА
	header("Location: http://google.com");
		или
	header("Location: abc.html");	// абсолютный путь к странице
	// вместе в редиректом исп. оператор exit, т.к. после редиректа нам не требуется выполнение кода, следующего после header()
	exit;
	// Какой-то код на странице, кот. нет смысла выполнять браузеру после редира


ОТПРАВКА ПОЧТЫ НА EMAIL
	$message = "Обычное сообщение";
	$to = "name@mail.ru";
	$from = "vo1-khaproff@mail.ru";
	$subject = "Тема сообщения";
	$subject = "=?utf-8?B?".base64_encode($subject)."?=";	// для Mail.ru
	// $headers - заголовки очень важны, т.к. без них почтовые сервисы не смогут корректно обрабатывать сообщения
	$headers = "From: $from\r\nReply-to: $to\r\nContent-type: text/plain; charset=utf-8\r\n";
	mail ($to, $subject, $message, $headers);
	// Остается записать функцию mail(), кот. передает команду в приложение SendMail. Сам PHP ничего не отправляет, он делегирует.


COOKIE

Cookie - набор var, кот. хранятся в браузере пользователя.
Лучший пример исп. кук - авторизация на сайте. Пользователь вводит логин-пароль, нажимает кнопку, чтобы отправить данные, и заходит на сайт. Куки пока еще не исп-ся. Они придуманы для того, чтобы при перемещении по сайту, пользователю не приходилось вводить данные авторизации на каждой странице.
Пользователь регистрируется, авторизуется, мы помещаем его данные в куки, указывая срок их хранения. Куки таже могут хранить персональные данные.
	setcookie("num", 10, time() +20);	// name куки, value, expires в сек
	$_COOKIE["num"];	// 10
ПРОВЕРКА КУК
	if(isset ($_COOKIE["num"])) echo "Куки установлены";
<!> Cookie сохраняют значение, даже если юзер перезагружает страницу.
СКОЛЬКО РАЗ ОБНОВЛЯЛАСЬ СТРАНИЦА
	<?php
		$num = (isset ($_COOKIE["num"])) ? $_COOKIE["num"] : 0;
		$num++;
		setcookie("num", $num, time() +5);
		echo "Пользователь обновил страницу $num раз";
	?>


СЕССИИ

session_start() - это осн. функция для работы с сессиями, на записывается в самом-самом верху кода.
	<?php
		session_start();
		$num = (isset ($_SESSION["num"])) ? $_SESSION["num"] : 0;
		$num++;
		$_SESSION["num"] = $num;
		echo "Пользователь обновил страницу $num раз";
	?>
- Для сессии не нужно никаких доп. функций. Это типо как глобальная var, в кот. просто записываем любое значение.
- Сессия автоматически удаляется через 15 минут.
- Сессия записывается как уникальная var для каждого пользователя. 2 пользователя не могут иметь 1 сессию.
- Сессия лучше кук, т.к. пользователь не имеет к ним доступа.
Сессию можно удалить:
	session_destroy();

<!> Если смысл php-кода в том, чтобы что-то вывести, то вместо
	<?php echo $_SESSION["from"]; ?>
	можно записать
	<?=$_SESSION["from"] ?>


SQL - язык, кот. помогает связаться с БД через СУБД.

INSERT INTO `mybase`.`users` (`id`, `login`, `password`, `reg_date`) VALUES (NULL, `admin`, `1234`, `время с момента регистрации`);

SQL-запрос - обращение к СУБД на языке SQL.
"Выполнить SQL-запрос к БД mybase".



'.htaccess'
В отличие от этих централизованных ограничений на доступ к информации и ее использование, второй способ является децентрализованным. Каждый отдельный пользователь, поддерживающий на вашем Web-сервере свой Web-каталог, может управлять доступом клиентов к этому каталогу посредством файла .htaccess. Вдобавок, пользователи могут использовать собственные значения директив, находящихся в файлах srm.conf и access.conf, если разрешить эту возможность в глобальном файле управления доступом.



В JS все объект, кроме boolean, undefined и null.

К примитивам можно применять методы благодаря "оберткам".
	$string = "text";
	$string = String("text");

new всегда создает объект.

var num = Number(123);	// typeof number
console.log(typeof num.toString());		// typeof string

Выражение отличается от стейтмента тем, что всегда что-то возвращает.
Выражение парсеру надо вычислить, тогда как литерал - просто вывести.


Парсер - это программа, кот. преобразует ваш код в программу. Это переводчик между языком человеческим и машинным.

ОПЕРАТОРЫ
1) арифметические	+ - * / %
2) сравнения			< >  <=  >=  ==  !=  ===  !==
3) условные			if  ?
	(age === 18) ? alert("Вы взрослый!") :
		(age === 21) ? alert("Держите пиво!") :
		(age === 24) ? alert("Юность заканчивается!") :
		alert("Вам нет 18!");
4) логические		||  &&  !
5) побитовые * (редко используются)


МЕТОДЫ СТРОК
	var str = '"string" is a data type';
	str.length - кол-во символов
	.concat - объединение строк, но лучше +
	str.charAt(1) - какой символ на позиции N
	str.charCodeAt() - код в кодировке
	str.substring(0, 8)
	str.slice(-5)
	str.substr(14, 4)
	str.split(' ') - превратить в массив, исп. сепаратор
	str.replace('string', 'num')
	str.indexOf('a')
	str.toUpperCase()
	str.toLowerCase()


console.log( Boolean(Nan) );		// false
console.log( Boolean("") );			// false
console.log( Boolean(0) );			// false
console.log( Boolean(undefined) );	// false
console.log( Boolean(null) );		// false

Если var объявлена, но не инициализирована, вренется undefined.
	var obj = {},
		param,
		arr = [1,2,3];
	console.log( param );			// undefined
	console.log( obj.parampam );	// undefined
	console.log( arr[7] );				// undefined
<!> Если браузер возвращает undefined, значит, вы что-то не объявили или не передали.

'ОБЕРТКИ' - явный способ преобразования типа данных
	String()
	Number()
	Boolean()
	console.log( typeof String(123) )		// string
	console.log( typeof Number("123") )	// number
	console.log( typeof Boolean(123) )		// true
	console.log( typeof Boolean(0) )		// false
'Неявное преобразование'
	console.log( typeof (5 + "1"));	// string
	console.log( typeof (125 + ""));	// string
	console.log( typeof (+"125"));	// number
	console.log( typeof (!!"125"));	// boolean
	console.log(+"");		// 0
	console.log(+true);	// 1
	console.log(+false);	// 0
'C помощью методов'
	var num = 777;
	console.log ( typeof num.toString )	// string
	console.log ( parseInt("100 px") )		// 100
	console.log ( parseFloat("100.24 px") )	// 100.24


ОБЪЕКТ - это контейнер ключей и свойств.
Объекты очень удобны для хранения и организации данных. Т.к. в объекты можно вкладывать др. объекты, в итоге можно получать очень полезные древовидные структуры.
При вызове свойства объекта можно исп. точечную или квадратную нотацию.
	obj.prop1  или  obj["prop1"]
<!> Важно запомнить, что объекты всегда передаются по ссылкам. Они никогда не копируются.
'Удаление свойства объекта'
	delete obj.prop1;		// удаляет только свойство объекта, не прототипа


МАССИВ
	array.length соответствует наибольшему индексу массива +1.
'Удаление элемента из массива'
	arr.splice(1, 1);
	// 1 аргумент - с какого индекса начинаем удаление, 2 - сколько эл удаляем

	var arr = [1, 2, 'str', {}];
	var matrix = [
		[1, 2, 3];
		[4, 5, 6];
		[7, 8, 9];
	];
	var newArr = arr.concat(matrix);
	console.log(newArr);		// [1, 2, 'str', object Object, Array(1), Array(2), Array(3)];
'Превращение массива в строку'
	arr.join(' ');	// аргумент - сепаратор; по умолчанию будет каша без ','
'Вставить элемент в конец []'
	arr.push('new2');
'Удаление последнего элемента []'
	arr.pop();
'Вставка и удаление элементов в начале []'
	arr.shift('first');
	arr.unshift();
'Изменить порядок элементов и вернуть новый []'
	var revArr = arr.reverse();
'Обрезать []'
	arr.slice(0, 5);		// с какого индекса по какой резать
'Сортировка некорректная'
	arr.sort();


ЦИКЛЫ
1. for
2. for in - исп. для обхода объектов.
------------------------------------------------------------------------------
	var obj = {
		prop1: 'one',
		prop2: 'two'
	}, prop;
	for (prop in obj) {	// var prop - каждое свойство объекта obj
		if (obj.hasOwnProperty(prop)) {
			// обяз. проверка: если prop принадлежит obj, то работаем
			console.log( prop + ' : ' +obj[prop] );
		}
	}
	// prop1 : one
	// prop2 : two
------------------------------------------------------------------------------
3. while
4. do ... while


ФУНКЦИИ
'Функция' - это конструкция, кот. позволяет неск. раз исп. 1 и тот же кусок кода.
Функция в JS - это тоже объект, тоже значение.
Функция всегда возвращает к-то значение. Если нет return, вернется undefined.

Hoisting Function Declaration:
	function func1() {
		function funcExample() {
			return 'one';
		};
		return funcExample();
		function  funcExample() {
			return 'two';
		}
	};
	console.log( func1() );	// two
---------------------------------------
Function Expression:
	function func2() {
		var funcExample = function() {
			return 'one';
		};
		return funcExample();
		var funcExample = function() {
			return 'two';
		}
	};
	console.log( func2() );	// one
---------------------------------------

'Функции обратного вызова' или 'callback' - когда нудно выполнить фукнцию после ответа сервера.
---------------------------------------
	var func = function(callback) {
		var name = "Nick";
		return callback(name);
	}
	console.log( func(function(n){
		return "Hello" + n';
	}) );	// Hello Nick
---------------------------------------
"Так работает функция обратного вызова, кот. передается в качестве аргумента другой функции, и уже в теле другой функции вызывается."

'Возвращение целой функции'
	var func1 = function() {
		return function() {
			console.log("Привет!");
		};
	};
	func1()();		// Привет!	// внимание на ()()

'Анонимная самовызывающаяся функция'
	(function() {
		console.log("Привет от анонимной самовызывающейся функции");
	})();
Таким образом обычно изолируют код от глобальной области видимости.

'Не понял, как это вещь называется'
	var funcArgs = function(a, b, c) {
		console.log(arguments);
	};
	funcArgs(1, 2, 3);		// [1, 2, 3]
или еще так
	var funcArgs = function() {
		var i, sum=0;
		for (i=0; i < arguments.length; i++) {	// пробежимся по всем аргументам
			sum += arguments[i];			// сложим их в 1 var
		};
		return sum;
	};
	console.log( funcArgs(1, 2, 3) );		// 6


"Все var всплывают к верху области видимости".
"Если вы запрашиваете var, кот. нет в локальной области видимости, парсер будет искать ее во внешней, а затем в глобальной областя видимости".


ЦЕПОЧКА ОБЛАСТЕЙ ВИДИМОСТИ
------------------------------------------
	var k = 4;
	console.log(k);	// 4

	var outerScope = function() {
		var k = 8;
		console.log(k);	// 8

		var innerScope = function() {
			var k = 12;
			console.log(k);	// 12
		}
		innerScope();
		console.log(k);	// 8
	};
	outerScope();
------------------------------------------

<!> Хорошая практика: всегда объявляй var в начале scope. Тот же i:
	var k = 10, i;
	for (i= ...)


"Все var внутри функции - это свойства объекта LexicalEnvironment (объекта var)".
При запуске функции создается объект, куда записываются все var функции. При создании функции у нее пояляется скрытое свойство (ссылка) 'scope'. Это свойство ссылается на лексическое окружение, в кот. функция была создана и на все его свойства. Т.о., если функция была создана в window, то свойство 'scope' будет ссылаться на window.































Объявление констант в PHP:
	define('name', 'value', true);		// true не обяз., он исключает чувст-ть к регистру

В PHP можно писать как 'else if', так и 'elseif'.

foreach - цикл исключительно для перебора массива.
Обычный []:
	$array = [1, 2, 3];
	foreach($array as $value) {
		echo $value;		// 123
	}
Ассоциативный []:
	$array = [
		"key"  => "value",
		"key2" => "value2",
		"key3" => "value3",
		...
	]
	foreach($array as $key => $value) {...}

В функции в PHP можно установить значение аргумента по умолчанию:
	function test($var = "10") {
		echo $var;
	}
	test();		// 10
	test(20);	// 20

Функции в PHP не видят глобальных var. Для работы с инициализированными глобальными var, в функции их нужно определить с ключевым словом 'global'.
	global $a;
<!> Для констант global не требуется.

По словам чувака, сессии в PHP исп. для передачи var между php-документами. Пишем:
	session_start();
	$_SESSION['Язык'] = 'PHP';		// помимо него есть $_SERVER, $_POST, $_GET
	$_SESSION['Я'] = 'Человек';		// теперь данные [] доступны в др. документах
	unset($_SESSION['Язык']);		// удаление ключа

Получение данных форм в PHP:
	if ($_POST['attr_name_value']) {
		echo "123";
	}

MySQL
	var_dump($connect);		// проверка на работоспособность
<?php
	include_once('setting.php');
	$connect = mysqli_connect(HOST, USER, PASSWORD, DB);
	if (!$connect) exit ("Ошибка подключения к БД.");	// если ошибка
	$row = mysqli_fetch_assoc( mysqli_query ($connect, "SELECT `text_1`, `text_2` FROM `test` WHERE `id` = 1") );		// т.е. Столбец  =>  БД  =>  Ряд
	// без WHERE извлекается вся таблица
	var_dump($row);
?>
Другой вариант:
	$query = mysqli_query ($connect, "SELECT `text_1`, `text_2` FROM `test` LIMIT 2");
	// LIMIT 2 - не больше 2 значений
	while( $row = mysqli_fetch_assoc($query) ) {
		echo "<br/>$row[text_1] $row[text_2]";
	}
-------------------------------------------------------------------------------------------------
SELECT запрос
	$query = mysqli_query ($connect, "SELECT `text_1`, `text_2` FROM `test`");
UPDATE запрос
	mysqli_query($connect, "UPDATE `test` SET `text_1` = 'Новой значение' WHERE `id` = 1")
INSERT запрос
	mysqli_query($connect, "INSERT INTO `test` VALUES('', NOW(), 'Это текст 1'), 'Это текст 2' ");	// VALUES(ID, ВРЕМЯ, ЗНАЧЕНИЕ 1 столбца, ЗНАЧ 2 столбца)
DELETE запрос
	mysqli_query($connect, "DELETE FROM `test` WHERE `id` = 1");
	// без WHERE таблица удалится целиком

















Robots.txt - текстовый файл, который содержит параметры индексирования сайта для роботов поисковых систем.


Что такое файл Sitemap?

Файл Sitemap — это файл с информацией о страницах сайта, подлежащих индексированию. Разместив этот файл на сайте, можно сообщить роботу Яндекса:

какие страницы вашего сайта нужно индексировать;
как часто обновляется информация на страницах;
индексирование каких страниц наиболее важно.
Файл Sitemap учитывается при индексировании сайта роботом, однако Яндекс не гарантирует, что все URL, указанные в файле, будут добавлены в поисковый индекс Яндекса.

Использование файла Sitemap

Что такое файл Sitemap?
Нужно ли создавать файл Sitemap?
Как создать файл Sitemap?
Какие форматы файлов Sitemap поддерживает Яндекс?
Требования к файлу Sitemap
Как сообщить Яндексу о файле Sitemap?
Как удалить файл Sitemap?
Что такое файл Sitemap?

Файл Sitemap — это файл с информацией о страницах сайта, подлежащих индексированию. Разместив этот файл на сайте, можно сообщить роботу Яндекса:

какие страницы вашего сайта нужно индексировать;
как часто обновляется информация на страницах;
индексирование каких страниц наиболее важно.
Файл Sitemap учитывается при индексировании сайта роботом, однако Яндекс не гарантирует, что все URL, указанные в файле, будут добавлены в поисковый индекс Яндекса.

Нужно ли создавать файл Sitemap?

Обычно робот Яндекса узнает о страницах сайта, переходя по ссылкам со страницы на страницу. В большинстве случаев этого достаточно для полного индексирования сайтов. Однако робот может не найти некоторые страницы или неверно определить их важность: проблемными обычно становятся динамически создаваемые страницы или страницы, на которые можно попасть только пройдя по длинной цепочке ссылок. Файл Sitemap помогает решить эти проблемы.

Как создать файл Sitemap?

В интернете представлено большое количество ресурсов, позволяющих создать файл Sitemap автоматически. Файл необходимо создать согласно одному из форматов, описанных ниже. Разместить файл следует в корневую директиву сайта (http://<адрес сайта>/sitemap.xml).

Рекомендуем использовать формат XML, так как он позволяет предоставлять дополнительную информацию о страницах сайта. Для каждого URL вы можете указать:

дату последнего обновления страницы (элемент lastmod);
частоту изменения страницы (элемент changefreq);
относительную значимость страницы (элемент priority).










ПЫТАЮСЬ ИЗВЛЕЧЬ ПАРОЛЬ

-----------------------------------------------------------------------------------
изменение пароля для root
UPDATE `user` SET `Password` = password('admin') WHERE `User`='root'

Примечание. В файле конфигурации "config.inc.php" (найдите его в папке webservers с помощью поиска) измените строку (чтобы найти примените команду Ctrl+F и наберите "password")
$cfg['Servers'][$i]['password'] = '';
на
$cfg['Servers'][$i]['password'] = 'admin';
-----------------------------------------------------------------------------------



ПРОБЛЕМА С PREG_REPLACE()	"/E IS DEPRECATED".
---------------------------------------------------
Меняем в vqmod.php (~317 строка)
	$modFilePath = preg_replace('/([^*]+)/e', 'preg_quote("$1", "~")', $modFilePath);
на
	$modFilePath = preg_replace_callback('/([^*]+)/', function ($m) { return preg_quote($m[1], "~"); }, $modFilePath);
















TIMEWEB


БАЗОВЫЕ ПРИНЦИПЫ РАБОТЫ

Чаще всего под сайтом понимают набор страниц в интернете, содержащих информацию – контент и имеющих общий адрес (имя) – доменное имя.

Для хранения сайта и возможности свободного доступа к нему в любой момент времени существует услуга размещения сайтов – хостинг. Компания, которая предоставляет хостинг (место под сайт), называется хостинг-провайдером.

Место выделяется на мощных компьютерах – серверах, которые всегда работают и всегда доступны через интернет. Размещение сайта на хостинге более удобно, чем его хранение на личном компьютере - Вам не нужно беспокоиться о том, что отключится электричество или интернет.

Доменное имя сайта просто запомнить и удобно вводить в адресную строку браузера, например, доменное имя сайта компании Timeweb – timeweb.com. Но персональные компьютеры и серверы, на которых хранятся сайты, работают с цифровыми данными и назначают каждому сайту свой цифровой адрес в сети – IP-адрес.

Для удобства перевода привычных нам доменных имен в IP-адреса, понятные компьютерам, существует система доменных имён – DNS. С ее помощью доменное имя сайта, которое пользователь вводит в адресную строку, преобразуется в IP-адрес. Так, IP-адрес сайта timeweb.com - 92.53.96.141.

Если сайт работает с большим количеством данных, которые необходимо систематизировать (адреса пользователей, названия товаров), ему понадобится база данных. Это удобный способ хранения информации в виде таблиц. Базы данных значительно упрощают работу с информацией и ускоряют процесс доступа к ней.

Сайт нередко сравнивают с квартирой. Тогда все вещи и жильцы квартиры – это контент. Шкафы с упорядоченным содержимым – базы данных. Дом, в котором расположена квартира – это хостинг. Название улицы и номер, по которому дом можно найти – IP-адрес. А доменное имя можно сравнить с обозначением того, что это за дом – например, "Офис компании Timeweb" или дом Ивана Иванова.


ОПРЕДЕЛЕНИЕ И НАЗНАЧЕНИЕ CMS

CMS (Content Management Software) - это система управления содержимым (контентом) сайта, которая используется для обеспечения возможности редактирования и управления информацией на сайте, а также ее предоставления пользователям (посетителям сайта) в виде, который удобен для навигации или поиска.

Основная задача CMS - показывать страницы сайта пользователям, формируя их содержимое "на лету" из заранее определенных шаблонов с дизайном и контентом.





'Индексный файл' или 'файл-индекс' - это тот файл, который открывается по умолчанию при обращении пользователя через веб к каталогу, а не к конкретному файлу. Например, ваш посетитель запросит адрес http://ваш_домен/price/, где price - название каталога. Индексный файл это тот файл, который будет показан пользователю при обращении к каталогу без указании имени конкретного файла в нем.

По умолчанию индексными файлами являются следующие: index.html, index.htm, index.php, index.php3, index.phtml, index.shtml, default.htm или default.html. Если вы хотите чтобы первым открывался какой-то иной файл, нужно переопределить текущие значения. Как это сделать читайте здесь.






Cоздание sitemap.xml (online generator)

Одним из критериев технической оптимизации сайта и его готовности к продвижению является наличие файла sitemap.xml, содержащего полный набор актуальных страниц и отображающих текущую структуру сайта. Этот файл используется поисковыми системами для нахождения новых страниц сайта, а также с помощью него роботу поисковой системы сообщается информация о тех страницах, которые необходимо индексировать.

Помимо самих URL страниц, файл sitemap.xml содержит дополнительную информацию в виде мета-данных, указывающих для каждого URL:

дату его последнего изменения
частоту изменений
его приоритетность на уровне сайта
Чтобы не тратить время на создание подобного файла вручную и был разработан данный инструмент.

Данный Sitemap Generator предназначен для онлайн генерации файла sitemap.xml, полностью соответствующего стандартам XML и учитывающегося всеми поисковыми системами.

После создания сайтмап, его необходимо скопировать в корневую папку сайта и добавить в конец файла "robots.txt" директиву "Sitemap: http://www.вашсайт.ru/sitemap.xml".
=======================================================

Создание Sitemap

Sitemap – это карта сайта в формате XML. Файл «Сайтмап» предназначен для информирования поисковых систем (таких как Яндекс, Google, Yahoo, MSN и др.) о страницах сайта, которые следует индексировать. Sitemap позволяет значительно ускорить сканирование сайта. Кроме того, Sitemap позволяет передать информацию обо всех страницах Вашего сайта, включая те, которые поисковым роботам не удается получить в ходе обычного сканирования.

Создание Sitemap особенно полезно когда:

На Вашем сайте новые страницы генерируются автоматически и часто.
Ваш сайт создан недавно, и на него указывает небольшое количество ссылок.
Ваш сайт содержит большой архив страниц с контентом, которые слабо или совсем не связаны друг с другом.
Протокол Sitemap

В соответствии с протоколом Sitemap и требованиями поисковых систем файл Sitemap должен содержать не более 50 000 страниц и не превышать размер в 10 Мб. Это означает, что если Ваш сайт содержит более 50 000 страниц или размер файла Сайтмап превышает 10 МБ, необходимо создать несколько файлов Sitemap.

Для каждой страницы протокол Sitemap, кроме обязательного параметра URL, предусматривает дополнительные теги:
	'Lastmod' - указывает на дату последнего изменения страницы.
	'Changefreq' - вероятная частота изменения контента страницы. Допустимые значения:
		always - всегда, при каждой загрузке страницы
		hourly - каждый час
		daily - каждый день
		weekly - раз в неделю
		monthly - раз в месяц
		yearly - раз в год
		never - означает, что содержимое страницы не изменяется.
	'Priority' - приоритет страницы относительно других страниц на Вашем сайте. Допустимый диапазон значений — от 0,0 до 1,0. Данный тег позволяет указать поисковым системам, какие страницы, по Вашему мнению, являются наиболее ценными.


Sitemap - веб-страничка с размещенными на ней сведениями о структуре конкретного ресурса.















=====================================================


'БД' - набор сведений, хранящихся некоторым упорядоченным способом.

'СУБД' - это совокупность языковых и программных средств, кот. осуществляет доступ к данным, позволяет их создавать, менять, удалять, обеспечивает безопасность данных и т.д.

'SQL' - язык структурированных запросов, основной задачей кот. явл. предоставление простого способа считывания и записи инфы в БД.

"В СУБД информация представлена в виде таблиц, строки кот. называются записями, а ячейки - полями. При создании таблицы необ. указать список полей и их типы. В каждой СУБД кол-во типов разнится."

___________________________________________________________________________________

В консоли СУБД 'NOT NULL' означает обязательное заполнение поля.

create database my_db;
show databases;
use my_db;
create table my_table (id INT(11) NOT NULL, name VARCHAR(255) NOT NULL);
show tables;
insert into my_table (id, name) values (1, 'Vladimir');
select * from my_table;
select * from my_table limit 3;
select * from my_table where id >5;
update my_table set name='Petr' where id=5;
delete from my_table where id=2;
select * from my_table ORDER by id desc;

___________________________________________________________________________________

НОРМАЛИЗАЦИЯ

"Реляционная БД" - база, построенная на связях таблиц между собой.

"Нормализация" - процесс разбиения данных на таблицы, чтобы избавиться от избыточности данных.

"Constraints" - ограничения типов данных.
	NOT NULL - поле обязательно для заполнения.
	UNIQUE    - ограничение на повторяющееся значение, оно дб уникально.
	DEFAULT   - когда поле дб обязательно заполнено, но в него не было передано никакого значения.

Чтобы связать 1 таблицу с другой, нужно создать 'первичный ключ' - уникальный индекс, кот. исп. для идентификации записи. Чаще всего, первичным ключем явл. поле id. При добавлении PRIMARY KEY полю талицу, поле автоматически наследует констрайты от NULL и UNIQUE и создается индекс - некое значение, позволяющее быстрее осуществлять поиск данных по записи.
Чтобы сослаться на поле другой таблицы, исп. внешние ключи (FOREIGN KEY).

<!> Чтобы в MySQL работал механизм внешних ключей, необ. выбрать систему хранения данных InnoDB. В конце запроса пишем:
	); ENGINE InnoDB;

___________________________________________________________________________________

Экспорт данных в БД называется 'dump'.

Если работаешь с неск. таблицами с внешним ключом, при выполнении операций с одноименными полями указывай 'имя_таблицы.поле'.

___________________________________________________________________________________

При редактировании таблиц все запросы начинаются с 'ALTER TABLE'.
1. Добавление поля в таблицу:
	ALTER TABLE table_name ADD COLUMN new_field
	BOOLEAN NOT NULL DEFAULT TRUE;
2. Удаление поля из таблицы:
	ALTER TABLE table_name DROP COLUMN new_field;
3. Переименовать поле и сменить тип (MySQL):
	ALTER TABLE table_name CHANGE old_field new_field
	BOOLEAN NOT NULL DEFAULT TRUE;
4. Сменить тип поля (MySQL):
	ALTER TABLE table_name MODIFY new_field VARCHAR(255)
	NOT NULL DEFAULT 'value';
5. Переименование таблиц:
	ALTER TABLE table_name RENAME TO new_table_name;

'LIKE' - сравнение строк. Для поиска подстроки:
	SELECT * FROM table_name WHERE field_1 LIKE 'value';
вернет записи таблицы, где поле field_1 = value
	SELECT * FROM table_name WHERE filed_1 LIKE 'val%';
вернет записи, где поле field_1 начинается с val
	SELECT * FROM table_name WHERE field_1 LIKE '%lue';
вернет записи, где поле field_1 заканчивается на lue

ОПЕРАТОРЫ 'AND' и 'OR' делают поиск по множеству критериев:
	SELECT * FROM table WHERE field_1 = 1 AND field_2 > 3;

C помощью оператора 'DISTINCT' можно вывести уникальное значение записи. Как правило, такой запрос исп. во вложенных запросах JOIN:
	SELECT DISTINCT field_1 FROM table;
вернет уникальные записи поля field_1 таблицы.

Группирование записей с помощью 'GROUP BY':
	SELECT field_1, COUNT(field
___________________________________________________________________________________

SELECT * FROM regions WHERE active=2 AND name LIKE '%a' LIMIT 1;
___________________________________________________________________________________

'PRIMARY KEY' или 'Первичный ключ' - задает уникальный индекс записи.
___________________________________________________________________________________

"Триггер" - это хранимая в БД процедура, автоматически вызываемая СУБД при возникновении опр. условий.

"Это процедура опр. типа, исполнение кот. обусловлено действием по модификации данных в таблице: при вставке, изменении, удалении записи. Момент запуска триггера опр. с помощью ключевых слов AFTER, BEFORE, INSTEAD."
___________________________________________________________________________________

create table if not exists users (
	id integer primary key auto_increment,
	username varchar(32) not null unique,
	password varchar(255) not null,
	email varchar(255) not null unique,
	created_at datetime not null,
	updated_at datetime not null
) engine innodb default charset=utf8;

create table if not exists profiles (
	id integer primary key auto_increment,
	user_id integer not null,
	name varchar(255),
	last_name varchar(255),
	photo_path varchar(255),
	about text,
	foreign key (user_id) references users(id)
) engine innodb default charset=utf8;

DELIMITER $$
CREATE TRIGGER new_profile AFTER INSERT ON users
FOR EACH ROW
	BEGIN
		INSERT INTO profiles(user_id) VALUES (NEW.id);
	END $$
DELIMITER;

DELIMITER $$
CREATE TRIGGER update_user AFTER UPDATE ON profiles
FOR EACH ROW
	BEGIN
		UPDATE users SET updated_at = now() WHERE id = OLD.user_id;
	END $$
DELIMITER;

DELIMITER $$
DROP TRIGGER IF EXISTS delete_profile;
CREATE TRIGGER delete_profile BEFORE DELETE ON users
FOR EACH ROW
BEGIN
DELETE FROM profiles WHERE user_id = OLD.id;
END $$
DELIMITER;

insert into users (username, password, email, created_at, updated_at) values ('sk.avanger', 'passwordhashwithsalt', 'sk.avanger@sk.av', now(), now());

update profiles set name = 'Alex' where user_id = 1;

delete from users where id=1;
___________________________________________________________________________________

'Транзакция' - это группа последовательных операций с БД, представляющая собой логическую единицу работы с данными.

"Транзакция - это группа последовательных запросов, кот. должна выполниться как 1 целое либо не выполниться вообще. Иными словами, тразакции позволяют контроллировать процесс сохранения изменений в БД".

Пример тразакции в MySQL:
	START TRANSACTION;
		UPDATE table SET field=NULL WHERE id=5;
		DELETE FROM other_table WHERE id=7;
	COMMIT;
Выполнит группу операций как 1 целое, запрос на изменение поля и удаление записи не вступят в силу, пока мы не подтвердим операции ключевым словом COMMIT.

ОТМЕНА ТРАНЗАКЦИИ 'ROLLBACK'
Чтобы не сохранять изменения, произведенные операциями внутри транзакции, необ. вызвать оператор 'ROLLBACK', и данные в таблице вернуться к исходному виду до объявления транзакции.
Также оператор 'ROLLBACK' позволяет возвращаться не только к исходному состоянию, но и к "контр. точкам", кот. можно объявлять внутри тела транзакции. Для этого нужно объявить контр. точку с помощью оператора 'SAVEPOINT' и для возврата к этой точке: "ROLLBACK TO SAVEPOINT".
	BEGIN
			UPDATE table SET field = NULL WHERE id = 5;
			DELETE FROM other_table WHERE id=17;
		SAVEPOINT point_name;
			DELETE FROM test_table WHERE id=75;
		ROLLBACK TO SAVEPOINT point_name;
	COMMIT;
В результате будет выполнено только 2 запроса: изменение записи в талице table и удаление записи из таблицы other_table.

___________________________________________________________________________________

В MySQL нужно указывать движок и кодировку таблицы.
)	ENGINE	InnoDB
	DEFAULT CHARSET = UTF8;
___________________________________________________________________________________

Атрибут 'UNSIGNED' для INTEGER не допустит отрицательных значений.
___________________________________________________________________________________

Подключение к БД в PHP:
//	$con = new mysqli("HOST", "username", "pass", "database");
	$mysqli = new mysqli("localhost", "root", "", "mybase");
	$mysqli->query("SET NAMES 'utf8'");
	$mysqli->close();
// открывая соединение, нужно его закрывать, чтобы исключить перегруженности БД и проблем с доступом к ней для новых пользователей

___________________________________________________________________________________


___________________________________________________________________________________


___________________________________________________________________________________


___________________________________________________________________________________


___________________________________________________________________________________


___________________________________________________________________________________


___________________________________________________________________________________


___________________________________________________________________________________


___________________________________________________________________________________


___________________________________________________________________________________


___________________________________________________________________________________


___________________________________________________________________________________


___________________________________________________________________________________


___________________________________________________________________________________


___________________________________________________________________________________


___________________________________________________________________________________


___________________________________________________________________________________


___________________________________________________________________________________


___________________________________________________________________________________


___________________________________________________________________________________
















































6 лет назад мне было трудно представить, во что разовьются ИТ. Сегодня перспективность отрасли очевидна настолько, что об этом неловко говорить. Программирование видится наиболее привлекательной сферой деятельности для человека, желаюшего быть востребованным на рынке труда в ближайшие годы. Это и побудило гуманитария освоить новую область знаний.

Были изучены HTML-CSS-JavaScript (jQuery), PHP, основы работы с базами данных и CMS (WordPress). Я не являюсь профессионалом до кончиков пальцев, но есть фундамент, который позволит разобраться в проблеме и решить ее.

В прошлом я работал UI/UX-дизайнером, хорошо владею графическими редакторами. Долгое время изучал английский, что сильно помогло при знакомстве с языками программирования и еще поможет.

В Тамбове нет более подходящего места работы, поэтому буду настойчиво пытаться попасть именно к вам.

Я хочу развиваться в этом направлении.



Ежегодно учебные заведения Тамбова производят IT-специалистов. Их поток ощутим, и тем не менее Demis постоянно пребывает в поиске сотрудников. Очевидно, это объяняется тем, что профессиональный уровень дипломирванных специалистов недостаточен для выполнения даже рутинных задач.

Поначалу это может занимать больше времени, чем бы мне хотелось, но не больше, чем хотелось бы вам.

Люди нанимают кого-то не потому, что вы хотите, чтобы вас наняли, а потому что У НИХ ЕСТЬ ПРОБЛЕМА.