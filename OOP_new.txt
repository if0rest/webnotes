========================================================
	ООП
========================================================

ООП — подход в программировании, основанный на представлении программы как совокупности объектов(1), где каждый объект является экземпляром к-то класса(2), а классы множат подклассы, образуя иерархию(3) наследования.

В процедурном П каждая програма - 1 большой фрагмент кода, состоящий из множества модулей, функций, переменных. В ООП программа - набор взаимодействующих компонентов - объектов.

ООП был придуман для упрощения, сокращения и ускорения написания кода. ООП делает программирование более осмысленным и понятным за счет того, что базируется на привычной человеку модели представлений о мире как пространстве объектов. ООП эту концепцию реализует: есть множество исполнительных элементов, кот. могут взаимодействовать между собой, при этом каждый явл. самостоятельным и самодостаточным.

ООП программы более просты и мобильны, их легче модифицировать и сопровождать. Код с ООП лучше организован, потому что в нем понятно, какой объект чем обрабатывается.

Объекты дают лучшую организацию кода и поддерживаемость.

Класс - это бланк с графами (имя, тел.) и пустыми полями. Каждый экземпляр - это когда мы отрываем бланк и заполняем его. Бланки бывают разными: записная книжка, рецепт доктора, письмо.
ИНСТАНЦИРОВАНИЕ КЛАССА - создание экземпляра класса.

КЛАСС - фрагмент кода, у кот. есть имя и кот. описывает опр. объект. Код класса может состоять из множества различных элементов: конструктор, геттеры, var и методы экземпляра, статические.
Чтобы воспользоваться кодом класса нужно создать(инициализирвать) объект класса. ОБЪЕКТ ссылается на экземпляр Класса.
• Класс - это чертеж, по кот. создается проект.
• Объект - самая обычная var, ссылающаяся на экземпляр класса.
* АБСТРАКТНЫЙ КЛАСС - это класс, для кот. не мб созданы экземпляры.

Любой класс состоит из 2 составляющих: данные и методы. Данные отвечают за состояние объекта, методы - за поведение объекта.

ВИДОВ МЕТОДОВ 2: методы экземпляра и методы класса (статические).
1. Суть МЭ: в классе объявляется метод, программируется его поведение. Чтобы вызвать этот метод, нужно создать объект, а потом вызывать этот метод из объекта.
2. То же со статическим методом, но чтобы вызвать его, не нужно обращаться к объекту - можно напрямую к классу.

• Хороший пример статического метода - конструктор (инициализатор, фабричный метод). Есть в каждом классе и занимается тем, что создает объект из класса (инициализирует экземпляр класса).
• getter/setter - выполняют черную работу: устанавливают и получают значения var. Т.к. в норм. классе все var дб инкапсулированы, то, чтобы обращаться к ним, необ. спец. публичные методы - собственно геттеры и сеттеры (или аксессоры). Как правило, у каждой закрытой var есть свой геттер и сеттер. Геттер называется как и сама var и занимается тем, что возвращает значение var. В имени сеттер ставится префикс set-, и он устанавливает новое значение.
• Виртуальные и абстрактные методы. 'Виртуальный' - можно переопределить в наследниках и для наследников. 'Абстрактный' - подтип виртуального, и его нужно переопределить. Он не имеет  реализации, т.е. ничего не делает, у него отсутствует тело с блоком кода.



ПРАДИГМЫ ООП:

1. ИНКАПСУЛЯЦИЯ. Все О взаимодействуют между собой как черные ящики: у каждого есть публичный интерфейс, через кот. он общается со всей программой, при этом вся его внутрення реализация скрыта.
Все механизмы класса можно разделить на инкапсулированные (скрытая реализация класса) и публичные (интерфейс класса). Реализация скрыта и попасть в нее можно только через интерфейс класса - набор публичных элементов.
Инкапсулированные элементы, по большому счету, нужны для обеспеч. норм. работы публичных.
ИНТЕРФЕЙС КЛАССА - это набор публичных элементов, через кот. общаемся и управляем классом.
ИНСТРУМЕНТЫ ИНКАПСУЛЯЦИИ - модификаторы доступа: public, protected, private.

2. НАСЛЕДОВАНИЕ - создание новых более специфичных классов на основе существующих, не дублируя их содержимое.
	Человек -> Водитель -> Дальнобойщик

3. ПОЛИМОРФИЗМ - это разное поведение 1 метода в разных экзеплярах.
П - свойство наследованных классов иметь одинаковые методы, кот. будут по-разному работать в контексте разных объектов.
"1 интерфейс со множеством реализаций."

4. АБСТРАЦКИЯ - основа ООП, позволяющая работать с объектами, не вдаваясь в особенности их реализации. Абстрагировать - отбросить маловажные и незначительные элементы, чтобы увидеть суть.



МОДИФИКАТОРЫ ДОСТУПА опр. scope:

• PUBLIC - означает, что все методы и свойства объекта будут доступны в любой точке скрипта и вне класса.
• PRIVATE - свойства и методы объекта мб исп. только внутри класса. Оно закрыто от внешнего кода.
• PROTECTED - свойства и методы могут исп. только внтури класса и дочерних объектов.

$this->$name - обращение к методам и свойствам в контексте объекта.
self::$name - обращение к статическим свойствам и методам класса.

СВОЙСТВА хранят данные, МЕТОДЫ - выполняют задачи.

АБСТРАКТНЫЙ КЛАСС - это класс, для кот. не мб созданы экземпляры.

ИНТЕРФЕЙСЫ - просто шаблоны. Структуры, кот. описывают, какие константы и методы должен содержать класс, кот. будет реализовывать интерфейс. Для интерфейса, как и для АК, не мб созданы экземпляры.

ТРЕЙТЫ - это примеси, кот. позволяют объединить общие методы для всех наследующих классов. ТРЕЙТ - это механизм обеспеч. повторного исп. вашего кода.

МАГИЧЕСКИЕ МЕТОДЫ (clone, get, set). clone() клонирует объекты в PHP, будет автомат. вызван при клонировании объекта. get() и set() перехватывают обращение к закрытой var, временно делая ее доступной для чтения и изменения.

ИСКЛЮЧЕНИЕ (try-throw-catch) - действие, кот. не укладывается в работу приложения. Исп. для корректной обработки ошибки и восстановления. Исключения в PHP - это экземпляры класса Exception.


---------------------------------------------------------
	ООП от CBS
---------------------------------------------------------
Основные парадигмы ООП:
1. Инкапсуляция.
2. Наследование.
3. Полиморфизм.
4. Абстракция.
5. Посылка сообщений.
6. Повторное использование.

• ИНКАПСУЛЯЦИЯ - сокрытие реализации элементов класса и частей программных систем. Это не процесс: мы просто скрываем то, что не нужно пользователю, предоставляя только необ. часть интерфейса. Реализуется засчет модификаторов доступа, т.е. мы можем открывать члены либо закрывать.
• НАСЛЕДОВАНИЕ - создание нового более специализированного объекта на базе существующего. Наследование зацепляет парадигму Повтороного использования.
• ПОЛИМОРФИЗМ - изменение поведения объекта в зависимости от внешних факторов. Приводит пример: пришли в универ - привелись к состоянию студента, вышли на улицу - горожанин, в автобус - пассажир, дома - сын.
Если снять с объекта все то, что на него навесили, мы приведем его к первоначальному виду. П осуществляется через приведение типов. Мы были унаследованы от к-то типа, мы можем сделать upcast - привестить к базовому типу - или downcast.
• АБСТРАКЦИЯ - это придание объекту характеристик, отличающих его от других объектов, четко опр. его концептуальные границы. АБСТРАГИРОВАНИЕ - это способ выделить набор значимы хар-тик объекта, исключая из рассмотрения незначимые. Собственно, абстракция - это набор всех таких характеристик.
	Двигателя не существует - это клапаны, набор вращающихся механизмов, поршни, коленвалы и т.д. Двигатель - это абстракция, описывающая взаимосвязь эти элементов.
ПОСЫЛКА СООБЩЕНИЙ - хз.
ПОВТОРНОЕ ИСПОЛЬЗОВАНИЕ - если уже есть опр. объект-чертеж, мы его закодили, создали виртульный объект при создании этого экземпляра, мы можем его исп. в 2 разных объектах. Т.е. наши оъекты могут состоять из еще к-то маленьких объектов.

АСПЕКТНО-ОРИЕНТИРОВАННОЕ П - событийная модель, надстройка над ООП. ООП может сущ. без АОП, но не наоборот.

===========================================================


ООП

Был разработан с целью сделать мышление о программировании более похожим на мышление о реальном мире.

Именно классы, а не объекты, лежат в основе ООПроектирования, потому что мы исп. классы для создания объектов. Класс описывает, чем будет объект, но это не сам объект. Класс - это проект, подробное описание, определение объекта.
У класса есть имя, кот. описывает, что это такое. Также класс имеет атрибуты и поведение, кот. указывают, какие элементы данных характеризуют каждый объект, и что каждый объект может делать.

'Абстрагирование' говорит, что мы фокусируемся на существенных свойствах чего-то, а не на 1 конкретном примере. Мы автоматом отбрасываем неважные и нерелевантные детали. Абстракция означает, что у нас есть идея или концепция, полностью отделенная от конкретного экземпляра. Пример со столом.

Принцип 'инкапсуляции' в том, что объект не должен предоставлять иных сведений о себе, кроме тех, что необх. для работы др. частей приложения.

'Наследование' - это эффектиный способ наследования кода. Можно создать новый класс, но вместо того, чтобы писать его с 0, можем взять за основу существующий класс.

'Полиморфизм'.


FURPS / FURPS+
1. Functional requirements - функциональные требования.
2. Usability R - удобство пользования, справка, документация.
3. Reliability R - надежность, возможность восстановления при отказе, приемлемая частота сбоев.
4. Perfomance R - производительность, доступность приложения, требования к памяти и др. ресурсам.
5. Supportability R - возможность поддержки.


Для структурирования объектов исп. классы. 'Класс' - это чертеж, опр. структуру объектов. Объекты 1 класса создаются на его основе одинаково. Исп. класс для создания объектов, я знаю, что различаться по своей структуре они не будут.
Классы делают программу модульной, разделяя ее функциональные возможности с наименьшим перекрытием. Классы имеют атрибуты или структуры данных для свойств.
Объект - это экземпляр класса, имеющий все его свойства и формы поведения. Свойства одинаковые, но свойства могут отличаться.

ООП позволяет разделить проект на согласованно управляемые блоки.

$this - это ссылка на объект, вызвавший метод.
Для доступа к свойствам объекта с помощью псевдо-переменной $this введите после нее "->", а затем укажите имя свойства без "$".
	$this->name;

Результатом создания экземпляра явл. объект соответствующего класса. Чтобы его создать, начните с объявления "var + new + имя Класса", экземпляр кот. нужно создать.
	$instance = new Class;

Видимость свойства или метода опр. с помощью ключевого слова области видимости: public, protected или private.
Если методы или свойства опр. как public или открытые, это означает, что их можно исп., а свойства еще и изменять везде, где доступен объект.
	// запись защищенного свойства:
	protected $_address_id;
	// обращение к свойству извне:
	echo "Address ID: {$address->_address_id}";		// fatal error

'Магические методы' - это специализированные методы PHP, кот. выполняются в ответ на конкретное событие. Есть около десятка ММ. Выглядят так:
	$__construct();	// двойное подчеркивание
	$__toString();
Нельзя назвать метод 1 из этих имен и не вызвать магическое поведение.
С помощью ММ можем выполнять заданные действия в ответ на специфические события (например, попытка доступа к несуществующему свойству или вызов несущетсвующего метода).
"Минусы".
1. Вызов ММ существенно замедляет выполнение кода от 3-20 раз.
2. ММ игнорируют scope и могут случайно предоставить доступ к свойству/методу, кот. дб скрыты.
3. С ММ может не работать завершение кода в IDE.

Запись документации (коммента):
	/*
	* Guess the postal code given the subdivision...
	* @todo Replace with a database lookup.
	* @return string
	*/

--------------------------------------------------------------------------------------------------
<?php
	// Определим конструктор для объекта БД:
	public function __construct() {
		$this->connection = new mysqli('localhost', 'root', 'pass', 'mydb');
		// Обработка ошибок
		if (mysqli_connect_error()) {
			trigger_error('Не удалось подключиться к MySQL: '. mysqli_connect_error() . E_USER_ERROR);
		}
	}
	// Чтобы запретить копирование подключения к БД, воспользуюсь __clone(), кот. опр. способ дублирования объекта
	// Пустой ММ __clone() для запрета копирования объекта
	private function __clone() {}
	// Опр. открытый метод для получения подключения MySQLi
	public function getConnection() {
		return $this->connection;
	}
?>
--------------------------------------------------------------------------------------------------

При копировании объекта по id, мы получаем копию {}. Чтобы продемонстрировать это, создадим копию по ссылке. Добавим символ ссылки "&" в операцию присваивания после объекта $address_business_copy.
	$address_business_copy = &$address_business;

Мы можем создать стандартный {} непосредственно из БД. 1 из методов в MySQLi 'fetch_object' возвращает текущую строку набора результатов как объект стандартного класса.
	mysqli_result::fetch_object;


================================================================

ИЗ ЛЕКЦИЙ YANDEX

'Область видимости функций' опр. во время создания функций, поэтому явл. лексической. Она образует 'замыкание' - объект, кот. содержит ссылки на все задекларированные var и родительский контекст (замыкания функций, в кот. была создна эта функция и т.д. до глобальной scope).

"Интерпретатор смотрит на наличие искомой var в собственной scope. Если не находит, поднимается выше, в родительскую scope. Если и там нет, поднимается до глобальной scope. Если интерпретатор не находит var, он бросает исключение".
'Собственная scope  ->  Родительская scope  ->  Глобальная scope  ->  Success / Исключение'
Т.о. алгоритм поднимается по областям видимости, и если 1 var объявлена в неск. scope, то значение var первой встретившейся перекроет значение остальных.
Цепочку областей видимости еще называют 'контекст'.

prototype и ___proto___ - это разные сущности.
prototype - свойство функции. Оно есть у Ф с рождения. По умолчанию пустой объект.
___proto___ - ссылка на prototypе у объекта. Во многих движках JS оно скрыто. Определяется во время работы оператора new.

В JS любая Ф мб конструктором.

Можно легко проверить, кто инициализировал событие и узнать, стоит ли обрабатывать его. Достаточно проверить:
	var isTarget = event.target.classList.contains('good');

Нативные методы CSS быстрее, чем JS/$.


AJAX - модель запроса данных от сервера в фоновом режиме, без перезагрузки страницы.


================================================================


ООП - это подход в программировании, основанный на привычной человеку объектной модели представлений, где есть множество исполнительных элементов, кот. взаимодействуют между собой. При этом, каждый такой элемент явл. самостоятельным и самодостаточным.

ОБЪЕКТЫ дают лучшую организацию кода и поддерживаемость.

Переменные/данные/состояние/атрибуты и методы/действия/поведение/фукнции.

Основная идея ООП - все состоит из объектов. В процедурном программировании каждая програма это 1 большой фрагмент кода, состоящий из множества модулей, функций, переменных.
Любая ООП программа по сути набор взаимодействующих друг с другом компонентов - объектов. Важный момент: программист при создании ООП-программ распределяет ответственность за работу всего приложения между всеми объектами, и каждый объект отвечает только за себя, являясь полностью самостоятельным.
Важно то, что все объекты взаимодействуют между собой как черные ящики: у каждого объекта есть свой публичный интерфейс посредством кот. он общается со всей программой, при этом вся его внутрення реализация полностью скрыта. Это "ИНКАПСУЛЯЦИЯ".
ООП также позволяет упростить большие и сложные объекты, составляя их из более маленьких, т.е. могут выступать в роли агрегатора. Все эт опозволяет создавать очень большие системы, оч. большие программы, над кот. могут работать сотни и тысячи разработчиков, при этом ни один не будет знать всей системы целиком, т.к. каждый работал исключительно над своей частью.
Еще 1 мощный инструмент ООП - возможность создавать объект на основе существующих, не переписывая код заново, а просто добавляя им новые возможности, переменные, методы. Это "НАСЛЕДОВАНИЕ".

Класс - это всего лишь фрагмент кода, у кот. есть имя и кот. описывает опр. объект. И чтобы воспользоваться этим кодом необх. создать объект из этого класса. Объект класс - это экземпляр класса, а его создание - инициализация.
• Класс - это чертеж, по кот. создается проект.
• Объект - самая обычная var, ссылающаяся на экземпляр класса.
• Из 1 класса можно создать множество подобных объектов.
• Имена классов пишутся с Большой, объектов - с маленькой.

Объект в коде программы - это самая обычная var. Процесс инициализации проходит так: мы объявляем var, создаем объект и присваиваем его этой var. После чего var будет выступать в качестве объекта, точнее ссылки на него. Теперь можно делать с этой var или obj все то, что вы запрограммировали в классе. Если в классе запрограммировали к-то методы, вы можете вызывать их.

Есть правило записи:	имена классов пишутся с Заглавной буквы (MyClass), объектов - с маленькой (myClass).

Класс дб макс. простым и отвечать только за ту задачу, кот. была на него возложена.
• Класс должен описывать только 1 объект, будь то клиент-магазин или абстрактный объект, сущ. только в рамках программы.
• Имя класса очень важно. Оно дб простым и понятным, и сразу говорить, за что отвечает. Не мб глаголом.
• Качественный, понятный и согласованный интерфейс. Программист, польз. вашим классом должен четко понимать, какое действие совершает тот или иной публичный метод.
• Хорошая инкапсуляция.
• Хорошая реализация: каждый метод должен быстро, четко и безошибочно выполнять свои действия.

Мы выяснили, что КЛАСС - это фрагмент кода, кот. описывает опр. объект. Код класса может состоять из множества различных элементов: конструктор, деструктор, статические var и методы, var и методы экземпляра, геттеры, сеттеры и т.д.
На самом деле, все становится ясно, если понять 1 простую и важную вещь: все классы могут состоять только из 2 составляющих: методы (действия) и данные (переменные), причем последние необяз.
Методы отвечают за поведение объекта, данные - за состояние.

Другими словами, КЛАСС - это объединение данных и действий, кот. можно совершать над этими данными, в 1 сущность - класс.

'Метод' - это 1 строгоопределенное запрограммированное действие, кот. можно совершать над объектом.
'Данные' - набор var внутри класса, в кот. хранятся параметры, необх. для описания объекта и его состояния.

ИТОГО:
• Любой класс состоит из 2 составляющих: данные и методы. Данные отвечают за состояние объекта, методы - за действия объекта.
--------------------------------------------------------------------------------
ВИДЫ МЕТОДОВ

Все методы можно разделить на 2 части: методы экземпляра и методы класса (статические).
• Методы экземпляра исп. чаще всего. Его суть: в классе объявляется метод, программируются к-то действия, кот. он должен выполнять, и для того, чтобы вызвать этот метод, необ. сначала создать объект, и только потом вызывать этот метод из объекта. Вот вся его суть!
• В (статическом) методе класса почти то же самое, но чтобы вызвать метод, нам не нужно обращаться к объекту. Для вызова статического методамы должны обращаться напрямую к классу. Более того, мы вообще не сможем вызвать статический метод из объекта.

• Хороший пример статического метода - конструктор (инициализатор, фабричный метод). Есть в каждом классе и занимается тем, что создает объект из класса (инициализирует экземпляр класса).
• getter/setter - выполняют черную работу: устанавливают и получают значения var. Т.к. в норм. классе все var дб инкапсулированы, то, чтобы обращаться к ним, необ. спец. публичные методы - собственно геттеры и сеттеры (или аксессоры). Как правило, у каждой закрытой var есть свой геттер и сеттер. Геттер называется как и сама var и занимается тем, что возвращает значение var. В имени сеттер ставится префикс set-, и он устанавливает новое значение.
• Виртуальные и абстрактные методы. 'Виртуальный' - метод, кот. можно переопределить в наследниках и для наследников. 'Абстрактный' - подтип виртуального, разница в том, что его можно и нужно переопределить в наследниках. Абс.м. не имеет никакой реализации, у него отсутствует тело с блоком кода, т.е., грубо говоря, он ничего не делает, поэтому и еще называют чистыми методами.
<!> Для абстрактного класса обязательны наследники, иначе класс бесполезен. Если в классе опр. абстрактный метод - класс абстрактный: он ничего не делает, у него нет тела с реализацией.
--------------------------------------------------------------------------------
НАСЛЕДОВАНИЕ - создание новых классов на основе существующих.
Одно из самых мощных инстументов в ООП, кот. заключается в том, что вы можете создавать более специфичные классы на основе уже существующих, естественно, не копируя их содержимое.
	Суперкласс -> Подкласс -> Под-подкласс
	Человек -> Водитель -> Дальнобойщик
<!> Подкласс обязательно должен являться более специализированной версией своего суперкласса.

ИНКАПСУЛЯЦИЯ - класс как черный ящик.
Все механизмы класса можно разделить на инкапсулированные (скрытая реализация класса) и публичные (интерфейс класса).
"Это все позволяет реализовать идею черного ящика, когда вся реализация скрыта и похожа на ЧЯ, попасть в кот. можно только через строгоопр. вход и выход в виде интерфейса класса - публичного набора элементов класса".
Все инкапсулированные элементы класса нужны, по большому счету, чтобы обеспечить норм. работу публичных.
ИНТЕРФЕЙС КЛАССА - это набор публичных элементов, через кот. общаемся и управляем классом.
ИНСТРУМЕНТЫ ИНКАПСУЛЯЦИИ - модификаторы доступа. Это неск. ключевых слов: public, protected, private.

АБСТРАЦКИЯ. Абстрагировать объект или явление - отбросить маловажные и незначительные элементы, чтобы увидеть суть.
А - основа ООП, позволяющая работать с объектами, не вдаваясь в особенности их реализации.

ПОЛИМОРФИЗМ. "Один интерфейс, много реализаций".
П - это свойство, кот. позволяет 1 и то же имя, например, имя метода, исп. для решения внешне схожих, но технически разных задач.
П - это 1 интерфейс со множеством реализаций.






--------------------------------------------------------------------------------
Основные парадигмы ООП:
1. Инкапсуляция.
2. Наследование.
3. Полиморфизм.
4. Абстракция.
5. Посылка сообщений.
6. Повторное использование.

• ИНКАПСУЛЯЦИЯ - сокрытие реализации элементов класса и частей программных систем. Это не процесс: мы просто скрываем то, что не нужно пользователю, предоставляя только необ. часть интерфейса. Реализуется засчет модификаторов доступа, т.е. мы можем открывать члены либо закрывать.
• НАСЛЕДОВАНИЕ - создание нового более специализированного объекта на базе существующего. Наследование зацепляет парадигму Повтороного использования.
• ПОЛИМОРФИЗМ - изменение поведения объекта в зависимости от внешних факторов. Приводит пример: пришли в универ - привелись к состоянию студента, вышли на улицу - горожанин, в автобус - пассажир, дома - сын.
Если снять с объекта все то, что на него навесили, мы приведем его к первоначальному виду. П осуществляется через приведение типов. Мы были унаследованы от к-то типа, мы можем сделать upcast - привестить к базовому типу - или downcast.
• АБСТРАКЦИЯ - это придание объекту характеристик, отличающих его от других объектов, четко опр. его концептуальные границы. АБСТРАГИРОВАНИЕ - это способ выделить набор значимы хар-тик объекта, исключая из рассмотрения незначимые. Собственно, абстракция - это набор всех таких характеристик.
	Двигателя не существует - это клапаны, набор вращающихся механизмов, поршни, коленвалы и т.д. Двигатель - это абстракция, описывающая взаимосвязь эти элементов.
ПОСЫЛКА СООБЩЕНИЙ - хз.
ПОВТОРНОЕ ИСПОЛЬЗОВАНИЕ - если уже есть опр. объект-чертеж, мы его закодили, создали виртульный объект при создании этого экземпляра, мы можем его исп. в 2 разных объектах. Т.е. наши оъекты могут состоять из еще к-то маленьких объектов.

АСПЕКТНО-ОРИЕНТИРОВАННОЕ П - событийная модель, надстройка над ООП. ООП может сущ. без АОП, но не наоборот.

--------------------------------------------------------------------------------
ООП ДЛЯ НАЧИНАЮЩИХ

ОПП применяется для более легкого создания управляемых проектов.
ООП программы более просты и мобильны, их легче модифицировать и сопровождать.
Код с ООП лучше организован, потому что в нем понятно, какой объект чем обрабатывается. Большие приложения, написанные с процедурным подходом, становится невозможно воспринимать уже после выода неск. версий вашего приложения.

Суть подхода - создавать все объектами.

ОБЪЕКТ - это экземпляр Класса. Часто Класс сравнивают с типом данных, а Объект - типа var.


<?php
	// будем исп. класс ShoppingCard как форму для создания объектов типа ShoppingCard
	class ShoppingCart {
	}

	// чтобы создать объект нужен оператор new
	$product1 = new ShoppingCart();

	// каждый объект имеет свой внутренний ИД
	var_dump($product1);
	// оператор instanceof() проверяет принадлежность объекта классу
	var_dump($product1 instanceof(ShoppingCart));	// true
?>


Модификаторы доступа, опр. scope:
• Public - означает, что все методы и свойства объекта будут доступны в любой точке скрипта и вне класса.
• Private - свойства и методы объекта мб исп. только внутри класса. Оно закрыто от внешнего кода.
• Protected - свойства и методы могут исп. только внтури класса и дочерних объектов.

Свойства - хранят данные, методы - выполняют задачи.

$this - обращение к методам и свойствам в контексте объекта.
	$this->name = "Vladimir";
self::$name - обращение к статическим свойствам и методам класса.

ПОЛИМОРФИЗМ - это следствие наследования. Это свойство у наследованных классов иметь одинаковые методы, кот. будут по-разному работать в контексте разных объектов.
	П - это разное поведение 1 метода в разных классах.
В программировании полиморфизм исп. для создания модульных структур приложения и упрощения расширения функционала. Чтобы избежать мешанины условных выражений, описывающих разные варианты действий, можно создать взаимозаменяющие объекты, кот. будут выбираться в зависимости от условий использования.

АБСТРАКТНЫЙ КЛАСС - это класс, для кот. не мб созданы экземпляры.
	abstract class User{
		public $name;
		abstract public function getStatus();
	}
АК позволют более качественно моделировать сущности. Т.е. для работы вам требуются не полностью готовые классы, а заготовки/шаблоны. Они уже будут что-то уметь, иметь свойства и методы, но в таком виде их нельзя исп-ть.

В PHP отказались от множественного наследования впользу интерфейсов. ИНТЕРФЕЙСЫ - просто шаблоны. Это структуры, кот. описывают, какие константы и методы должен содержать класс, кот. будет реализовывать интерфейс.
ВАЖНО! Интерфейс не должен содержать реализацию указанных методов - только перечисления того, что будет исп. в самом классе. В интерфейсе могут находиться только объявления методов, но не их тела.
	interface FirstIinterface {
		public function getName();
	}
Для интерфейса, как и для абстрактного класса, не мб созданы экземпляры. В любом классе, кот. будет поддерживать данный интерфейс, дб реализованы все методы, исп. в данном интерфейсе.

ТРЕЙТЫ - это примеси, кот. позволяют объединить общие методы для всех наследующих классов. ТРЕЙТ - это механизм обеспеч. повторного исп. вашего кода. Он оч. похож на Класс, но предназначен для группирования функционала хорошо структурированным и последовательным образом.
--------------------------------------------------------------
МАГИЧЕСКИЕ МЕТОДЫ (clone, get, set)

• clone() клонирует объекты в PHP. Функция clone() будет автомат. вызвана при клонировании объекта? если она опр. в соответствующем классе.
	class user {
		public function __clone() { echo "Cloned" };
	}
	$obj = new User;
	$obj2 = clone $obj;
Метод clone работае с клонированным объектом, а не с исходным.
• get() и set(). Если var закрыта, то обращение к ней возможно только через открытые методы. Методы перехватывают обращение к закрытой var, временно делая ее доступной для чтения и изменения.
--------------------------------------------------------------
ИСКЛЮЧЕНИЯ (try-throw-catch)

Технология исключения позволяет писать код восставноления после ошибки. Если примен. исключения, перехват и обработка ошибок удасться намного проще.
ИСКЛЮЧЕНИЕ - это действие, кот. не укладывается в работу приложения. И используют, чтобы корректно обрабатывать ошибки в случае их возникновения.
В исключениях применяются операторы try-throw-catch. Исключения кидают в ту часть кода, где ошибка неизбежна, чтобы та была поймана и обработана.

• Исключения в PHP - это экземпляры спец. класса Exception. Чтобы кинуть исключение, исп. throw. Вы исп. экземпляр класса Exception, потому после throw записывается 'new Exception', а в круглых скобках указ. сообщение, кот. относится к ошибке.
• Если в некоторой строке блока try было брошено исключение, то все инструкции после throw будут проигнорированы, и если исключение будет поймано, то начнется выполнение всех инструкций блока catch. В скобках catch указывается название класса исключения и var-экземпляр этого класса. По факту, это объявление типа var.
• Если брошенное исключение не совпадает с указанным классом, будет ошибка.

	$file = 'namespace.php';
	// ловим исключение
	try {
		if (!file_exists($file)) {
			// бросаем исключение
			throw new Exception('File not found');
	}
	} catch (Exception $e) {
		echo $e->getMessage();
	}
Мы ловим брошенное исключение и выводим на экран сообщение в виде строки, кот. была передана в конструктор класса Exception.
Можно создавать свои классы исключений.
	class newException extends Exception {}
--------------------------------------------------------------







