Все-таки с помощью 'new' мы создаем экземпляр класса.

Внутри Класса методы и свойства задаются в точности как функции и var в JS.
	class Car {
		var $wheels = 4;			// свойство		// VAR!!!
		function wheels() {};	// метод
	}

self::$var - позволяет удобней обратить к атрибуту Класса внутри метода Класса.

СТАТИЧЕСКИЕ методы и атрибуты, объявленные внутри Класса, существует даже, если у Класса нет экземпляров:
	Student::$name;

Вот так объявляется ПОДКЛАСС:
	class B extends A {}

Все объекты исп. присвоение по ссылке по умолчанию.

Как var могут объявляться внутри класса:
	var $name;
	public $name;
	protected $name;
	private $name;

--------------------------------------------------------------------
ДОСТУП К ФАЙЛАМ

r - прочитать файл с начала. Это read only, файл уже должен существовать.
w - метод записи с начала, перезаписывает имеющееся содержимое файла; если файла нет, он его создаст.
a - добавляет записи в конец.
r+ - можем читать и записывать.
w+ - очистит все и поместит нас в начало, откуда сможем читать и записывать.
a+ - поместит в цонец файла, также позволит читать и записывать.
t - модификатор; преобразует разрыв строк в Windows: \n в r\n\. 
	fopen('1.txt', 'wt');
	fopen('1.txt', 'a+t');
b - модификатор; включает бинарный режим, в котором данные не будут преобразовываться. Настоятельно рекомендуется всегда использовать при открытии файлов с помощью fopen().
-------------------------------------------------------------------
ПЕРЕМЕЩЕНИЕ УКАЗАТЕЛЯ

$pos = ftell($handle);		// положение указателя (каретки)
fseek($handle, $pos-6);		// возьмет текущую позицию и переместится назад
rewind($handle);				// обратная перемотка, вернет в начало файла 

Режимы 'a' и 'a+' (режимы добавления в конец) не позволяют перемещать указатель. Они ставят его в конец файла и заставляют оставаться там.
А режимы 'r' и 'w' позволяют перемещаться, читать и записывать в разных местах.
Так что, если хотим иметь возможность добавить что-то в конец, а затем перейти в начало, нужно исп. 'r+'. 

--------------------------------------------------------------------
include
require
echo
isset();		// сущ. ли var
unset();		// удалить var
print_r
var_dump
array_shift             // удаляет первый элемент []
array_unshift           // добавляет элемент в начало []
array_pop               // убирает последний элемент []
array_push($arr, 'val') // добав. элемент в конец []
array_flip;													// меняет местами ключи с их значениями
time()																		// время с 1970
date('Y-m-d H:i:s')
mktime(2,30,45,10,1,2009)		// созд. временную метку (H:i:s и m-d-Y)
checkdate(12,31,2000)			// проверка даты на существование
strtotime()


get_class_vars('Person') 	// вернет все var внутри класса Person

Узнать дирректорию файла, с кот. работаете с помощью магич. константы: 
echo __DIR__;

Проверить существование файла:
	file_exists(__FILE__);	// это неправильная запись

--------------------------------------------------------------------

Переменная переменной:
$a = 'hello';
$hello = 'everyone';
echo $$a;	// everyone

$$a = $($a) = $(hello) = $hello = 'everyone'
--------------------------------------------------------------------
Внутри $SERVER хранятся все var сервера ($_COOKIE, $_SESSION) и запросов ($_GET, $_POST)
• $_SERVER['PHP_SELF'] - URL текущей страницы.
• Не советую исп. $_REQUEST.

"Эй, ты знаешь переменную $var в глобальной scope? Присвой ей значение 2".
	global $var = 2;
--------------------------------------------------------------------
ПРИСВОЕНИЕ ПО ССЫЛКЕ

Ссылки позволяют var обращаться к тому же контенту, что и другие var.

	$a = 1;
	$b = $a;		// в $b помещается значение $a и закрепляется
	$b =& $a;	// теперь $b и $a связаны, и изменение значения одного повлечет изменение другого
	$b = 5;
	echo $a;		// 5

ПЛЮС в том, что если удалим $a, $b останется. Как удалить ярлык. Часто будет возникать потребность удалить ссылку, но чтобы значение осталось не тронутым.
	unset($b);	// удалит значение $b, а значение $a сохранится
--------------------------------------------------------------------
ССЫЛКИ В КАЧЕСТВЕ АРУГМЕНТОВ ФУНКЦИИ

	fucntion ref_test(&$var) {		// & = global внутри функции
		$var = $var * 2;
	}
	$a = 10;
	ref_test($a);	// 20

Примечание:
	function ref_test(&$var) { $var = }
		почти тоже самое, что
	function ref_test($var) { global $var = }
--------------------------------------------------------------------
ОПРЕДЕЛЕНИЕ КЛАССОВ

Мы опр. объект через опр. класса.

PHP отслеживает, когда мы создаем Класс.

Получить все задеклар-е классы:
	$classes = get_declared_classes();
Проверка существования класса:
	if (class_exists('Person')) {...}
--------------------------------------------------------------------
ОПРЕДЕЛЕНИЕ МЕТОДОВ КЛАССА

	class Person {
		function say_hello() {
			echo 'Hello!';
		}
	}

	$methods = get_class_methods('Person');
	foreach ($methods as $method) {
		echo $method . "<br>";
	}

	if(method_exists('Person', 'say_hello')) {...}
-------------------------------------------------------------------
ОПРЕДЕЛЕНИЕ СВОЙСТВ КЛАССА

	var $name = 'Vladimir';

<!> ОБРАТИ ВНИМАНИЕ на исп. ключ. слова 'var'.

-------------------------------------------------------------------
ИНСТАНЦИРОВАНИЕ КЛАССА - создание экземпляра класса.

Класс - это бланк с графами (имя, тел.) и пустыми полями. Каждый экземпляр - это когда мы отрываем бланк и заполняем его. Бланки бывают разными: записная книжка, рецепт доктора, письмо.

	class Person { function say_hello() {...} };
	$student = new Person();
	$studet->say_hello();
-------------------------------------------------------------------
ССЫЛКА НА ЭКЗЕМПЛЯР

$person = new Person();		// создаем экземпляр класса
// Внимание!! Ниже мы не дублируем экземпляр person, а ссылаемся на него.
$student = $person;

	class Person {
		function say_hello() {
			echo 'Hello from inside the class'.get_class($this).'<br>';
		}
		function hello() {
			$this->say_hello();
		}
	};
	$student = new Person();
	$student->say_hello();	// Hello from inside...
	$student->hello();		// Hello from inside...

$this - это способ обратиться к экземпляру и вызывать различные аспекты этого экземпляра изнутри класса.
-------------------------------------------------------------------
ПОНИМАНИЕ НАСЛЕДОВАНИЯ КЛАССА

	class Car {
		var $wheels = 4;			// свойство		// VAR!!!
		var $doors = 4;
		function wheels() {};	// метод
	}

// CompactCar расширяет класс Car, ->, наследует его поведение
	class CompactCar extends Car {
	// все будет так же, как в Car, но $doors = 2;
	var $doors = 2;
	};

	$car1 = new Car();
	$car2 = new CompactCar();	// то же, что в Car

Если изменим свойство экземпляра класса Car, это не повлияет на CompactCar, т.к. он наследует свойства от Класса, а не экземпляра.
	$car1->wheels = x;
	$car2->wheels = y;

	echo $car1->doors;	// 4
	echo $car2->doors;	// 2
-------------------------------------------------------------------
РАБОТА С МОДИФИКАТОРОМ static

"Насколько я понял, обычно мы не можем обратиться к свойству или методу Класса напрямую - только через Экземпляр. Однако, модификатор static позволяет это делать".

	class Student {
		static $total_students = 0;
		static public function add_students() {
			// можно Sudent::, лучше self::
			self::$total_students++;
		}
	}
	// 
	echo Student::$total_students;

<!> В Классах нельзя исп. $this.
<!> Если Класс, то '::', если экземпляр, то '->'.
<!> Держи статичные методы и свойства отдельно от методов экземпляров. Т.о., все статические МиС должны идти вместе и вызывать статичные вещи, а нестатич - должны принадлежать экземплярам.   
-------------------------------------------------------------------
ССЫЛКА НА РОДИТЕЛЬСКИЙ КЛАСС

	class B extends A {
		static fucntion attr_test() {
			// просим вернуть значение из родителя
			echo A::$a;		// а лучше parent::$a, в данном случае A
		}
	}

<!> parent:: работает только с методами.
-------------------------------------------------------------------
ИСПОЛЬЗОВАНИЕ КОНСТРУКТОРОВ И ДЕСТРУКТОРОВ

КиД - это спец. методы, кот. автоматически вызываются при создании или уничтожении объекта. Идея в том, что, когда объект создается, сначала должен выполниться метод __construct{}, а при уничтожении - __destruct{}.
Конструкторы идеальны для любой инициализации или подготовки, кот. нужна объекту перед его использованием.

	class Table {
		public $legs;
		function __construct() {
			$this->$legs = 4;
		}
	}

Конструкторы могут принимать аргументы:
	function __construct($leg_count=4) {
		$this->$legs = $leg_count;
	}
-------------------------------------------------------------------
КЛОНИРОВАНИЕ ОЪЕКТОВ

	class Bevarage {
		public $name;
	}
	$a = new Bevarage;
	$a->$name = "coffee";
		$b = $a;
		$b->$name = "tea";
	echo $a->$name;	// tea	// Это ссылка на объект
	
	$c = clone $a;					// Это копия объекта
	$c->$name = 'orange juice';
	echo $a->$name;	// tea

То, что делается при методе __construct(){}, не делается, когда мы клонируем. Только при создании, а не копировании. Для этого есть метод __clone(){}: когда объект клонируется, происходит __clone.
-------------------------------------------------------------------
ПОДКЛЮЧЕНИЕ БД в config.php

define("DB_SERVER", "localhost");
define("DB_USER", "gallery");
define("DB_PASS", "1234");
define("DB_NAME", "photo_gallery");

Можно указать условие:
define("DB_SERVER") ? null : define("DB_SERVER", "localhost");
и т.д.
-------------------------------------------------------------------
ДОСТУП К ФАЙЛАМ

$file = '1.txt';

if($handle = fopen($file, 'w')) {	// если указатель успешен, то
	fwrite($handle, 'abc');
	$content = "123\n456";		// double quotes matters!
	fwrite($handle, $content);
	fclose($handle);
} else {
	echo 'Could not open file for writing.';
}
echo file_get_contents($file);

file_put_contents удобнее, но по умолчанию перепишет содержимое файла.
	$file = '1.txt';
	$content = "123\n456\n789";
	if($size = file_put_contents($file, $content)) {
		echo "A file of {$size} bytes was created";
	}

-------------------------------------------------------------------
УДАЛЕНИЕ ФАЙЛОВ

1. Сначала файл надо закрыть с помощью fclose().
2. У нас дб разрешения для записи в дирректории. Разрешения на запись в файл недостаточно.

	unlink('test.txt');
-------------------------------------------------------------------
ПЕРЕМЕЩЕНИЕ УКАЗАТЕЛЯ

$pos = ftell($handle);		// положение указателя (каретки)
fseek($handle, $pos-6);		// возьмет текущую позицию и переместится назад
rewind($handle);				// обратная перемотка, вернет в начало файла 

Режимы 'a' и 'a+' (режимы добавления в конец) не позволяют перемещать указатель. Они ставят его в конец файла и заставляют оставаться там.
А режимы 'r' и 'w' позволяют перемещаться, читать и записывать в разных местах.
Так что, если хотим иметь возможность добавить что-то в конец, а затем перейти в начало, нужно исп. 'r+'. 
-------------------------------------------------------------------
ЧТЕНИЕ ФАЙЛОВ

$file = '1.txt';
if($handle = fopen($file, 'r')) {
	$content = fread($handle, 10);	// хотим прочитать 10 байт
	$content_all = fread($handle, filesize($file));
	fclose($handle);
}
echo nl2br($content1);	// преобразует \n в <br>

$content = file_get_contents($file);
echo $content;
-------------------------------------------------------------------
SMTP-серверы берут отправляемый email, выясняют, куда он должен пойти дальше и передает его по цепочке другому SMTP-серверу, кот. делает то же самое. Так до тех пор, пока письмо не попадет к вашему провайдеру, кот. знает, к аккаунту какого пользователя это относится. Затем письмо помещается к вам во 'Входящие' и ждет, пока вы не авторзуетесь и не получите его.
PHPMailer исп. SendMail, а не SMTP. PHPMailer - расширенный, продвинутый вызов функции mail(). Просто теперь все это заключено в класс + можно отправлять сообщения без SMTP и при это пользоваться объектно-ориентированными возможностями, встроенными в PHPMailer.
Главная фишка PHPMailer - практически 100% гарантия, что провайдер пропустит письмо, и оно дойдет.
-------------------------------------------------------------------

-------------------------------------------------------------------