JavaScript - Lynda.com

JS - это язык программирования, созданный для веба для добавления поведения и интерактивности страницам.

HTML - язык разметки, для контента и структуры: "какой заголовок? сколько разделов, абзацев? что в них содержится?"
CSS - язык стилей, для отображения и оформления: "какой шрифт? какой цвет фона, страницы? какова ширина параграфа? отступы?"
JS - язык сценариев, для поведения и интерактивности: "что произойдет, если курсор мыши над меню? если вводите неправильное значение в поле формы? какова длительность отображения 1 изображения в слайд-шоу?"

КОМПИЛЯТОР преобразует исходный код в машинный (01).

Круглые скобки ( ) используют для условий, фигурные { } - для выделения того, что будем делать, если условие true. Условие нужно оценить как истинное или ложное. Если внутри { } есть несколько операторов, то все в совокупносит называется блоком кода.

Знак '=' - это команда, а не оператор.

Внутри { } размещается оператор.
____________________________________________________________________

if и else - операторы. Для них допустима 3-х уровневая вложенность. Если нужно глубже, разбивай на функции.
Оператор if возврашает true или false.
Интересное оформление:
if ( (a > b)
	  &&
	(c < d) )

Тернарный оператор: 
	условие ? true : false
____________________________________________________________________

Основная проблема любого цикла - это не что в нем делать, - это легко, - а когда остановиться. У while и if практически идентичный синтаксис.

WHILE LOOP
Код в блоке выполняется на каждом проходе по циклу:
	var a = 1;	 // объявим переменную
	while (a < 10) {	//дойдем до цикла   //проверяем условие: а меньше 10?   //true
		console.log(a);   //переходим в тело цикла и выполняем строки кода
		a++;   // +1 к значению переменной
	}   //дошли до закрывающей скобки и снова к оператору while
	Когда a станет = 10, условие while станет false и цикл завершится.

DO... WHILE LOOP
Сначала выполнится блок, затем проверится условие / Блок выполняется перед проверкой условия. Т.о. цикл как минимум 1 раз выполнит операцию внутри блока.
var a = 1;
do {
	console.log(a);
	a++;
} while (a < 10);	// Важно ставить ';' в конце условия

---------------------------------------------------------------
Требуется получить от пользователя значение более 100. Если 0 - повтор цикла. Если Отмена - цикл завершится.
Вариант 1
	var a;
	do {
		prompt("Введите число от 100",0);
	} while (a < 100 && a !== 0);	// НЕВЕРНО: иницилизируй переменную a=prompt...
Вариант 2
	var a;
	do { a = prompt("Введите число от 100",0);
	} while (a < 100 && a !== 0);	// НЕВЕРНО: при Отмене цикл повторяется. Используй null вместо 0.
Вариант 3
	var a;
	do { a = prompt("Введите число от 100",0);
	} while (a < 100 && a !== null);	// ВЕРНО.   * Не забудь ';' после while
-----------------------------------------------------------------

ШАБЛОН ЦИКЛА while
Независимо от задачи цикл while должен содержать некоторые элементы:
	var i = 1;	// Элемент, отслеживающий, где вы находитесь в цикле
	while (i < 10) {	// Э. для проверки условия, чтобы узнать, продолжать ли выполнение цикла
		// do stuff
		// do stuff
		// etc...
		i++;	// инкремент индекса в конце цикла
	}
Все 3 элемента нужны: 1) установка счетчика; 2) проверка условия; 3) инкремент индекса.

ЦИКЛ for - сокращенная версия цикла while
	for (var i = 1; i < 10; i++) {
		// do stuff
		// do stuff
		// etc...
	}
	
break ("выйти / прервать") - это слово, с помощью кот. можно выйти из цикла.
continue ("вернуться к началу цикла и снова проверить условие") - цикл не заканчивается, но заканчивается выполнение итерации.
Таким образом: continue перемещает нас наверх, к началу цикла, а break - перемещает за пределы цикла, вниз, к последующему коду скрипта.
Тем не менее, обе директивы используются не часто.

____________________________________________________________________

ФУНКЦИИ

Для удобства ориентации в большом массиве кода, мы разбиваем его на модули (сегменты меньшего размера). Это требует нескольких операторов, завернуть в блок и присвить имя - мы создаем ФУНКЦИИ. Для этого берем код, кот. хотим в нее поместить и оборачиваем его в фигурные скобки. Перед блоком ставим ключевое слово function и имя_функции(). Круглые скобки говорят о том, ожидает ли функция передачи к-либо данных или нет; если пустые - значит, не ожидает. После объявления ф. мы можем вызвать ее неограниченное кол-во раз, использую где-то в коде оператор с ее именем "nameFunc();".
	function myFunction() {
		console.log("We're in the function");
		// loops, if statements, anything!
		// ...
	}
	// something later
	myFunction();
	myFunction();
Код функции не запуститься сам по себе, только если вызвать ф.

Для чего нужна функция?	Обычно, что собрать код в блок и дать ему имя, чтобы вызвать его позже.

Хорошая практика: определять функцию до ее вызова.
Как правило, функции опр. вверху файла JS.

Часто создаются ф., кот. ожидают параметров. Они ожидают передачу в них информации. Чтобы это сделать, надо поместить в ( ) наши параметры:
	function myFunc( x ) { }		// ожидается параметр 'x'
Мы сообщаем, сколько кусочков информации будем принимать, и как они будут называться. Нам не нужны слова var: я просто говорю, что жду передачи кусочка инфы с названием 'x'. Если я хочу неск. параметров, я просто разделяю их запятыми:
	function myFunc( x, y ) { }
Определение ф., кот. принимает параметры 'x' и 'y', означает, что внутри кода я могу работать с 'x' и 'y', как-будто они существуют:
	function myFunction( x, y ) {		// параметры ожидают значения
		var myVar = x * y;			// получив значения, могу перемножить их
		console.log(myVar); 				// и вывести результат
		return myVar;				// вернем значение переменной
		}
	myFunction(754, 346);			// первая передача значений
	myFunction(947, -123);					// вторая
(1)	var myResult = myFunction(6, 9);
	
<*> alert(), к слову, тоже функция, встроенная в JS.
Также можно возвращать значения. Можно не только передавать информацию, но и получать что-то назал. Для этого используйте слово return, а затем передаваемую переменную или литерал.
(1) В последней строке я создаю новую var и присваиваю ей произведение переданных чисел. Переменная обращается к функции, передает ей значения, а функция производит описанные в ней вычисления.


ОЧЕНЬ ПОКАЗАТЕЛЬНЫЙ ПРИМЕР:
function calcD( a, b, c ) {
	return b*b - 4*a*c; }
var test = calcD( -4, 2, 1 );
alert( test );


VARIABLE SCOPE
Область видимости переменных относится ТОЛЬКО к функциям.
	var foo;		// глобальная var
	function simpleFunction() {
		// lots of code
		foo = 500;	// убрав var, сделали переменную глобальной
		// lots of code
		console.log( foo );	// 500
	}
	simpleFunction();
	console.log( foo );		// 500
<!> Переменную можно объявить на локальном или глобальном уровнях. Если локально, то var будет видна и доступна для операций только внутри функции. Для преобразования локальной переменной в глобальную, достаточно убрать ключевое слово var.

____________________________________________________________________

ТИПЫ И ОБЪЕКТЫ

МАССИВ - это 1 переменная, содержащая множество значений разных типов данных. [ ] - это индикатор массива, используя их, мы сообщаем JS, что это массив. Массив - это объект, поэтому у него есть свойства и к нему также применимы методы. Есть несколько способов создания массива:
	var mulipleValues = [ ];	// лучший способ   // mulipleValues - это объект
	var mulipleValues = new Array( );    // Array - это конструктор массивов
	var mulipleValues = Array( );	 // в new нет неоходимости
	var mulipleValues = Array(5);	// сообщаем, что размер массива = 5 элем-м [0...4]
Вообще, все массивы в JS динамические и могут быть такого размера, кот. вам нужен.
Т.к. массивы это объекты, у них есть свойства - это инфа, кот. мы можем узнать о массиве (например, .length - получаем значение свойства Длина). Напишем строчку кода, кот. создает массив и инициализирует его некоторыми значениями:
	var multipleValues = [10, 20, 30, 40, 50];
	// Я могу исп. имя массива и получить значение свойства length:
	console.log(multipleValues.length);  // 5 - это кол-во элементов
Т.к. массивы - это объекты, у них есть методы. Методы - это функции объектов.
	someFunction( params );	// так вызывается функция
	someObject.someMethod( );	// а так метод объекта
-------------------------------------------------
	var multipleValues = [10, 20, 30, 40, 50];
	var reversedValues = multipleValues.reverse( ); // [50, 40, 30, 20, 10]     // reversedValues - тоже массив
	// .reverse() - это метод объекта массив, где '.' - оператор
	console.log(reversedValues.sort());	// [10, 20, 30, 40, 50]
<!> Обратите внимание, для вызова метода обязательно нужны круглые скобки, иначе вернется не значение, а функция.
Поскольку массивы - это объекты, мы можем потребовать, чтобы они что-то сделали. И это очень полезно. Массивы встречаются повсюду и часто. Придется их создавать и работать с уже имеющимися. 
	var myArrayOfLinks = document.getElementsByTagName("a");    // сколько в документе ссылок?
	var myArrayOfLinks = document.getElementsByTagName("form");    // сколько в документе полей форм?

"Знак равенства, чтобы присвоить значение".

ЧИСЛА

В JS все числа 64-битные с плавающей запятой. Но можно легко сохранить в var число с дробной частью:
	var x = 10.4;
КОНКАТЕНАЦИЯ
Это "склеивание" значений переменных при сложении, если один из операндов - строка.
	var foo = 5;    // число
	var bar = "5";	   // строка
	console.log(foo + bar)	// из-за разности типов данных произойдет конкатенация ("склеивание")
* Конкатенация используется, например, для хранения кода и номеров телефона.
Если к-либо часть - строка, все операнды воспринимаются как строки.

NOT A NUMBER    (NaN)
	var foo = "55";	// может содержать буквы
	var myNumber = Number(foo);		// функция преобразует строку в число  // если false, то NaN
	// Если нужно узнать, что myNumber не является числом, исп. функция isNaN
	if ( isNaN (myNumber) ) {		// если значение НЕ ЧИСЛО, то вернется true    // у нас число, поэтому... 
		alert("It's not a number!")	// уведомление не появится
	}
isNaN проверяет, является ли значение НЕ ЧИСЛОМ. Чтобы проверить, ЯВЛЯЕТСЯ ЛИ ЧИСЛОМ, исп. двойное отрицание:
	if ( !isNaN (myNumber) ) {	// если isNaN возвращает false, false инвертируется с помощью '!' в true
		alert("It's a number!");	// появляется окно
	}

ОБЪЕКТ MATH
Работает с числами. У него оч. полезное поведение: некоторые полезные функции, кот. можно вызывать.
Округление ( .round ):
	var x = 200.6;		// допустим, мы хотим округлить число
	var y = Math.round(x);	// вызываем объект Math с методом .round и передаю значение 'х'
	alert(y)	// 201
Возвращение наибольшего/наименьшего значения ( .max / .min ):
	var a = 200, b = 10000, c = 4;
	var biggest = Math.max(a,b,c);	// 10000
	var smallest = Math.min(a,b,c);	// 4
У Math еще много полезных функций, например:
Math.PI     Math.random()     .sqrt()     .log()

СТРОКИ
Строки можно рассматрвать как объекты. Это значит, мы можем запросить у них информацию: у них есть свойства.
	var phrase = "This is a simple phrase.";
	console.log( phrase.length );		// 24 символа
	Это возможно, потому что строки можно рассматривать как массивы символов.
Есть не только свойства, но и методы.
Метод " .toUpperCase() ":
	var phrase = "This is a simple phrase.";
	console.log( phrase.toUpperCase() );		// THIS IS A SIMPLE PHRASE.
Метод " .toLowerCase() ":
	console.log( phrase.toLowerCase() );		// this is a simple phrase.
Метод .split() делит строку на части, используя некоторый символ как разделитель:
	var phrase = "This is a simple phrase.";
	var words = phrase.split(" ");	// Пробел в качестве разделителя
	console.log(words);	// ["This", "is", "a", "simple", "phrase."]
Метод " .indexOf() " позволяет узнать, есть ли конкретное слово где-нибудь в строке.
	var phrase = "We want a groovy keyword.";
	var position = phrase.indexOf("groovy");	// 10  Значит: есть и начинается с позиции 10
	Если слово найдено в самом начале, вернется 0. Если не найдено, вернется -1.
	Проверка может выглядеть так:
		if ( phrase.indexOf("DDD") == -1) {
				console.log("That word does not occur.");
		}
Метод " .lastIndexOf() " если слово встречается несколько раз, и надо знать последнее.
Метод " .slice() " позволяет вырезать опр. часть строки.
	var phrase = "Yet another phrase.";
	var segment = phrase.slice(6,5);		// (начальная позиция, длина)	// отсчет с 0
	alert(segment);	// other
	Похожие методы:  .substring()	 .substr()	// строчными

Строки чувствительны к регистру:
	var str1 = "Hello!";
	var str2 = "hello!";
	// str1 != str2
Если нужно, можно привести к одному регистру:
	if ( str1.toLowerCase() == str2.toLowerCase() ) {
	console.log("Yes, equal"); }
	
____________________________________________________________________

ОБЪЕКТ DATE
	var today = new Date();		// Date(year,month,day);		// month с 0
	console.log(today);	// Sat Apr 08 2017 16:33:34 GMT+0300 (RTZ 2 (зима))
Объект Date() хранится как кол-во милисекунд с 1 января 1970 года.
У него есть много методов (см. скрины).
" .getTime " - возвращает кол-во милисекунд с 1 января 1970 года. Это cамый полезный метод объекта Date(), и простой способ узнать, меньше ли одна дата, чем другая.
Разберем пример:
	var date1 = new Date(2000,0,1);
	var date2 = new Date(2000,0,1);
	if ( date1 == date2 ) { ...   // false   // объекты разные, хотя значения одинак.
	if ( date1.getTime() == date2.getTime() )	// true
	// сравнивается кол-во милисекунд. Все равно, что сравнивать 2 числа
* У Date() есть методы .get и .set. Если первый получает, второй - устанавливает.

____________________________________________________________________

ОБЪЕКТЫ

Идея объекта проста: это контейнер, кот. собирает вместе нек. данные и нек. поведение. Объект позволяет собрать переменные и функции, кот. относятся друг к другу, и дать им имя.
	var player = new Object();	// создаем общий объект-контейнер
	// решаем, что поместим внутрь
	player.name = "Fred";
	player.score = 10000;
	player.rank = 1;
	// наши данные на 1 уровень ниже, поэтому исп. оператор точку, чтобы сказать: player - это объект, а name - свойство. Хотя, когда name вне объекта, он считается var. Свойство - это просто переменная внутри объекта.
SHORTHAND (сокр. вариант):
	var player = { name: "Fred"; score: 10000; rank: 1}	// тут это не блок кода, а сокр. для созд. объекта

МЕТОД - это свойство объекта, содержащее функцию.
	
ФУНКЦИЮ можно сделать методом для объектов.

<!> Если var содержит function - она объект.

<!> Всякий массив - объект, но не всякий объект массив.

-------------------------------------------------
	var player1 = { name: "Fred", score: 10000, rank: 1};
	var player2 = { name: "Sam", score: 20000, rank: 5};

	function playerDetails() {
		console.log( this.name + " имеет ранк: " + this.rank + " и счет " + this.score);
	};
	player1.logDetails = playerDetails;
	// мы не вызываем ф., а просто пишем имя, связывая ее с объектом player1
	player2.logDetails = playerDetails;
	// Теперь у этих объектов есть метод .logDetails, и если мы его вызываем, он вызовет функцию playerDetails(). 
	player1.logDetails();	// вызываем Ф., кот. выведет данные в консоль
	player2.logDetails();
-------------------------------------------------

____________________________________________________________________

Переменная - небольшая коробка, которая хранить только 1 литерал.
	var i = 1;
	console.log( i );
Массив - большая коробка, хранящая множество литералов разного типа.
	var i = [1, 2, 3, "строка"];
	console.log( i [0] );
Объект - хранит в себе набор переменных и их значения.
	var i = { property: value, property2: value, property3: value, }
	console.log( i.property1 );
Функция - при вызове выполняет к-то алгоритм действий с переданными ей аргументами. Прогон.
	function func( par1, par2, par3 ) { ...
	func(123, 456, 789);

____________________________________________________________________

DOM

Модель - это то, как мы называем элементы, и, как мы описываем отношения между ними.
МОДЕЛЬ - это согласованный набор терминов, кот. описывают, как именно взаимодействовать с частями веб-страницы.

JS согласован с DOM, поэтому DOM доступен для JS.

DOM - это способ добраться до страницы из скрипта, и чтобы страница могла добраться до скрипта.

DOM рассматривает страницы как древо из узлов.


ПОЛУЧЕНИЕ ЭЛЕМЕНТОВ

document.getElementsByTagName("a")	// Я прохожу по doc и возвращаю любые узлы-элементы с <a> в HTML
	Как читать: 
	var myListItems = document.getElementsByTagName("li");
	"Я создам var myListItems и присвою ей document.getElementsByTagName() и передам "li". Т.е. я очу получить все узлы, кот. являются элементами списка. Как их хранить в одной var? Он создает массив myListItems. Он находит все элементы списка в doc и помещает их в элементы массива."

Если вызвать метод .getElementsByTagName() и передать имя тэга, кот. нет, все равно вернется массив, просто он будет пустым. Его длина будет равна 0, там ничего нет.


____________________________________________________________________

Cоздадим переменную newHeading для создания элемента H1:
	var newHeading = document.createElement("h1");
Но она еще ни к чему не привязана, она не часть страницы и ничего не содержит. Можно вызвать .innerHTML:
	newHeading.innerHTML = "Did You Know?";
Есть элемент, есть текст в нем, но он попрежнему не часть страницы. Интересующий меня элемент имеет id "trivia". 
	document.getElementById("trivia").appendChild(newHeading);
Вызываем строку выше, добавляем H1. Получаем, что хотели, но есть более точный вариант. Удалим предыдущую строку, а вместо нее напишем:
	var h1Text = document.createTextNode("Did You Know?"); // создаем текст. узел
Теперь var надо привязать к новым элементам.
	newHeading.appendChild(h1Text);

Таким образом,  1 шаг - это всегда создание элемента, а 2 - это добавление его в DOM.

.appendChild() всегда добавляет элемент в конец списка.

Разберем пример:
Шаг 1. Создаем элемент, отдельно.
	var newElement = document.createElement("li");
Шаг 2. Создаем var с объектом, - скажем, со 2-м пунктом списка, - и вызываем .getElementsByTagName(), потому что у 2-го пункта списка нет id. Сначала вызываю .getElementsByTagName("li"), чтобы найти все пункты ul, а затем с помощью [ ] указываю число 1.
	var secondItem = myElement.getElementsByTagName("li")[1];
Теперь вместо .appendChild() вызываю myElement.insertBefore() и передаю 2 параметра: новый элемент и элемент, перед которым хочу его вставить.
	var myElement.insertBefore(myNewElement, secondItem);
После чего новый элемент будет вставлен в указанное место списка в DOM.
Почти всегда будете исп. .appendChild(), но не забывайте про .insertBefore.

____________________________________________________________________

СОБЫТИЯ

События не нужно описывать, они уже происходят: это загрузка страницы, нажатие кнопки, перемещение курсора, прокрутка экрана, клик по полюформы и т.д. События встроены в JS, это часть JS, и есть спец. слова для их описания: onload, onclick, onmouseover, onblur, onfocus и т.д. Мы не пишем само событие, мы пишем обработчик события. 
Мы пишем функцию и обрабатываем 1 или неск. событий, когда они происходят.
Рассмотрим 3 способа реакции на событие в JS:
1. Напишем код JS прямо в HTML.
	<button onclick="alert('Hello, world');">
		Run some JS
	</button>
2. Исп. имени_элемента.события ( element.event = ... ).
	window.unload - событие загрузки для окна
	nameField.onblur - покидание поля
Очень часто исп. свершение действия по клику " myelement.onclick ":
	myelement.onclick = function() {	// анонимная функция
		// код обработчика события, кот. выполнится при нажатии
	}	// ...
В примере событие вызывает анонимную функцию. Для чего нужна функция?	Обычно, что собрать код в блок и дать ему имя, чтобы вызвать его позже.
3. document.addEventListener('click', myFunction, false);		// event без 'on'
Данный метод можно вызвать напрямую для объекта документа или любого элемента, кот. у есть. И вы передаете 3 параметра: событие, функция, false.

"Я заметил, что для событий в основном создаются анонимные функции".
	element.event = function() { ... }
	
____________________________________________________________________

"Строка захватывает элемент!"
	var emailField = document.getElementById("email");
	
"У меня есть определение функции simpleMessage..."
	function simpleMessage() {
	// some code	
	}

"Добавлю вызов setTimeout. Нужно передать ему 2 аргумента: имя функции и интервал в миллисекундах (5 сек)."
	setTimeout(simpleMessage, 5000);
* 'setTimeout' вызывается как alert или console.log, только с задержкой.

"intervalHandle - это просто переменная, кот. связывает меня с кусочком памяти. Она говорит: Я понимаю, что делает этот интервал."
	var intervalHandle = setInterval(changeImage, 5000);

"Я говорю, что когда кто-то кликает по изображению, вызывается clearInterval, передающая var intervalHandle, которой был присвоен результат вызова setInterval."
	myImage.onclick = function() {
		clearInterval(intervalHandle);
	}

"Объявлю переменную" , но  "Определю функцию"

"Создаю массив с 3 значениями, а затем создаю var для хранения текущей позиции в массиве."
	var messageArray = ["value1", "value2", "value3"];
	var messageIndex = 0;	// начинаем с 0

"Эта строка создает новую переменную для захвата сообщения в текущем элементе массива".
	var newMessage = messageArray[messageIndex];


____________________________________________________________________

ПОЯВЛЕНИЕ / ИСЧЕЗНОВЕНИЕ ТЕКСТА В ПОЛЕ

Чтобы при клике по 1 полю текст внутри исчезал, а при клике по 2 - вновь появлялся внутри 1, если 1 не был заполнен.
	var emailField = document.getElementById("email");
	emailField.onfocus = function() {
		if (emailField.value == "текст внутри input") {
		emailField.value = ""; }
	};
	emailField.onblur = function() {
		if (emailField.value == "") {
		emailField.value = "текст внутри input"; }
	}
____________________________________________________________________

ТАЙМЕРЫ

Используются, когда нужно вызвать код JS, но с задержкой. Слайд-шоу исп. таймеры, часы и проч. Официально, это не событие, но они похожи. Интересны 2 метода: 'setTimeout' и 'setInterval' (single / repeating)

"Добавлю вызов setTimeout. Нужно передать ему 2 аргумента: имя функции и интервал в миллисекундах (5 сек)."
	setTimeout(simpleMessage, 5000);	// происходит 1 раз
* 'setTimeout' вызывается 1 раз как alert или console.log, только с задержкой.
	setInterval(changeImage, 5000);   // вызывает функцию changeImage каждые 5с

____________________________________________________________________

ФОРМЫ

Получение форм и элементов форм:
	document.forms.frmContact		// frmContact - это name 
	document.forms.frmContact	.name
	document.getElementById("")
	
	myCheckbox.checked	// true or false 
	
"Когда .onsubmit вызывает обработчик события, нам нужно вернуть true или false."
	document.getElementById("frmContact").onsubmit = function() { ... }
	
"Я реагирую на событие .onclick элемента brochures ..."
	document.getElementById("brochures").onclick = function() { ... }
____________________________________________________________________

CSS и JS 

<!> Не помещай ;  внутрь строки.
	myElement.style.width = "230px";	// верный вариант

"Захватываю div join и присваиваю свойству style.left текущую позицию, а затем прибавляю 'px' "
	document.getElementById("join").style.left = currentPos + "px";
<!> Помните, что мы должны передавать единицы измерения для CSS.

____________________________________________________________________

<!> При работе с объектами первое слово пишется с Заглавной буквы.
	Math	Date	Array
Напомню:
	var myDate = new Date();
	
____________________________________________________________________

JS vs. jQuery

	document.getElementById("myDiv").className = "highlight";
	jQuery("#myDiv").addClass("highlight");
	$("selector")

В jQuery селекторы заимствованы из CSS, поэтому исп-ся '#' для ID и '.' для класса. И в отличии от getElement... , кот. будет работать только для 1 элемента, jQuery автоматически работает со всеми элементами, кот. соответствуют селектору.

Можно еще больше уточнить запрос: их можно объединить. Например,
	$("p.description");
вернет все абзацы с классом description.

СИНТАКСИС 
	jQuery("что искать?").чтоХотимСделатьИлиИзменить;
	jQuery("#myDiv").addClass("highlight");		// В этом случае	$ найдет идентификатор myDiv, а затем добавит класс highlight.
Также есть
	.removeClass("highlight");
	.toggleClass("highlight");	// добавить, если нет, и удалить, если есть
	
____________________________________________________________________

JS и HTML5

В дополнение к getElementById() и getElementsByTagName() появились:
	var a = document.getElementsByClassName("myClass");
	// возвращает все элементы этого класса
	// можно запросить неск. классов, разделяя их пробелами
	var b = document.getElementsByClassName("first second");
	
<!> Если, оъявив var, мы присваиваем ей объект, то переменная является элементом.
	var worker = new Worker("anotherjavascriptfile.js");
	"Вы можете создать новый объект worker и отправить его в отдельный файл JS."

____________________________________________________________________

Вызов функции кликом по ссылке. Работают, но так делать неправильно. Лучше использовать обработчики событий в коде JS.

ПЛОХО:
	<p>Inside your HTML, you may find:
	<a href="javascript:someFunction()">this</a>
	</p>
ХОРОШО
	<p>A preferable way is
	<a href="nojavascript.html" onclick="someFunction(); return false;">this</a>
	</p>
	 
"Вы часто будете видеть 'return false' - это для того, чтобы остановить поведение ссылки по умолчанию, т.е. не переходить по ссылке. Если в браузере включен JS, вызовется функция, а если нет - мы перейдем по ссылке."

____________________________________________________________________

AJAX: Asynchronous JavaScript And XML
AJAX == JavaScript
____________________________________________________________________

ОБЪЕКТ 

Мы можем создать объект с помощью { } или new Object()

Свойства объекта - это переменные, которые принадлежат конкретно этому объекту.
Методы - это функции, кот. принадлежат этому объекту.

* Если функция начинается с Заглавной буквы - это функция-конструктор.
	function Player() { ... }
	var fred = new Player(); // строка создает новый объект и вызывает функцию-конструктора
"Мы используем new для создания новой var от конструктора Player(). До этого мы видели слово new только для встроенных объектов, как Date(), Array(), RegExp(). Но мы можем исп. его и для своих объектов."


* Если var содержит объект, это делает ее элементом.

____________________________________________________________________

РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ

Это странные последовательности символов, которые описывают соответствие шаблонам и строкам.

Можно проверить кол-во цифр в номере кредитной карты, соответствие адреса электронной почты или URL базовому шаблону, что пароль содержит заглавные и строчные буквы, или просто найти некоторые слова в строке.

Есть 2 этапа:
1) Сначала вы создаете регулярное выражение, кот. описывает шаблон.
2) А затем проверяете что-то на соответствие этому шаблону.

Мы можем создать var js:
	var myRE = /hello/;	// это сокр. вариант
	var myRE = new RegExp("hello");	// полный

Проверим, есть ли слово 'hello' где-то в строке.
	var myString = "Does this sentence have the word hello in it?";
	if ( myRE.test(myString) ) {
		alert("Yes");
	}
"Создадим новую строку myString. Вызовем метод .test для регулярного выражения myRE и передадим в него myString."
____________________________________________________________________

<!> Если дважды объявить одну и ту же переменную с разными значениями, активным будет последнее. var, объявленная позднее, переопределяет значение предыдущей.
____________________________________________________________________

	var numberType = 56.01e3		// 56.01 умножаем на 10 в 3 степени и получаем 56010
	var numberType = 56.01e-3		// 56.01 умножаем на 10 в -3 степени и получаем 0.05601
____________________________________________________________________

	var user = "Владислав";		// обычный примитив - строковый литерал
	var user2 = new String("Владислав");	// браузер интерпретирует как объект	// можно применить .length и увидеть '9'
	console.log(user2);	// String {0: "В", 1: "л", 2: "а", 3: "д", 4: "и", 5: "с", 6: "л", 7: "а", 8: "в", length: 9, [[PrimitiveValue]]: "Владислав"}
Т.е. директива new + функция-конструктор String преобразует var в объект.
____________________________________________________________________

ПРО ОБЪЕКТЫ И ПРИМИТИВЫ

	var v1 = "10+15";	// примитив
	var v2 = new String("10+15");	// объекта
<!> При обращении к к-либо свойству или объекту(?) строки, JS автоматически оборачивает ее в объект String.
	console.log( eval (v1) );		// 25	// eval() интерпретирует строку как исх. код, в итоге происх. вычисление
	console.log( eval (v2) );		// String {0: "1", 1: "0", 2: "+", 3: "1", 4: "5", length: 5, [[PrimitiveValue]]: "10+15"}
	console.log( eval( v2.valueOf() ));	// 25	// .valueOf() конвертирует объект String в примитив
	
Сравнение строковых примитивов. Обычное условие на if (больше-меньше) else.
	console.log('ab'.charCodeAt(0));	// 97	// (0) - это позиция нужного символа
	console.log('ab'.charCodeAt(1));	// 98	// 98 - номер в Unicode 
	
	
	
	
	
	
	
JAVASCRIPT: ФУНКЦИИ

Внутри скобок можно вписать серию параметров, разделив их запятыми. Параметров может быть сколько угодно либо нисколько. Они станут локальными переменными, доступными только внутри вашей функции.
'Параметры функции станут ее переменными.'

* Внутриблочные инструкции также называются утверждениями (statement).
------------------------------------
Функция может включить какое угодно утверждение, но JS предлагает особый вариант: директива return. Помимо возвращения примитива Ф также может вернуть объект или другую функцию. В нашем случае она вернет значение сложения.
	function plus(a, b) {
		var sum = a + b;
		return sum; };		// используем метод/директиву/функцию return
	alert(plus(2, 3));	// 5
ИЛИ
	function plus(a, b) {
		return (a + b); };
	alert(plus(2, 3));	// 5
------------------------------------
В функии всегда есть скобки, в кот. мб набор идентификаторов переменных - параметры / аргументы. Их передают функции в качестве локальных var, т.е. получить к ним доступ можно только изнутри функции.
------------------------------------
Другой способ создания Ф - определение выражения: когда Ф присваивается как значение var. Ее еще назыв. литералом функции или анонимной Ф.
	var plus = function(a, b) {
		return console.log(a + b);	// 5, если plus(2,3);
	};
С литералом Ф. можно сделать много того, чего не сделать с объявлением Ф., потому что ее можно исп. везде, где будет var.
------------------------------------
ВЫЗВАТЬ ФУНКЦИЮ И ИНИЦИАЛИЗАРОВАТЬ ЗНАЧЕНИЯ НЕМЕДЛЕННО можно, передав аргументы после знака '}' :
	var plus = function(a, b) {
		return console.log(a + b);	// 5, если plus(2,3);
	}(2, 3);		// вот здесь

Выражение определения будет полезно, если Ф. нужна только единожды или вы хотите немедленно что-то исполнить.
------------------------------------

____________________________________________________________________

ВЫЗОВ ФУНКЦИИ. Метод 1

Объявлять функции - это хорошо, но код не будет исполнен, пока Ф. не будет вызвана. Есть 4 способа вызова:
1) Functions		в качестве функции;
2) Methods		в качестве метода;
3) Constructors 	в качестве конструктора;
4) Call & Apply	через методы вызова и применения.

Еще у Ф. будет парочка доп. параметров: arguments и this. Массив arguments полезен там, где нужно создать функцию без передачи опр. числа параметров. При традиционном вызове функции параметр this получает копию глобального объекта.
------------
return - директива
return() - метод
------------
	function plus(a, b) {
		return (		// исп. return() как ф. для возврата целого набора парам-в
			console.log(a+b),	// заметь, это будто параметр функции return
			console.log(this),
			console.log(arguments)		
			)
	}
	plus(2, 2);		// вызов ф. т.о. дает аргументу this глобальный объект window
____________________________________________________________________

ВЫЗОВ ФУНКЦИИ. Метод 2

Вызов в качестве метода. Метод - это функция, кот. была присвоена в качестве свойства объекта.

Объекты - самый гибкий тип данных. Они могут содержать любой тип данных, включая другие объекты или функции.

Обращение к методу внутри функции выглядит так:
имя_функции.свойство-метод( аргумент1, аргументN )
Например:
	var calc = {
		status: "Awesome",
		plus: function(a,b) {
			return (
				console.log(this),			// Object {status: "Awesome", plus: function}
				console.log(a+b),				// 4
				console.log(arguments),		// [2, 2]
				console.log(this.status)	// Awesome
			)
		}
	}
	calc.plus(2,2);
	
Атрибут this указывает на объект, в кот. находится функция.

____________________________________________________________________

Функции в JS могут не только создавать методы для объектов, но они сами могут создавать объекты. Это называется 'конструирование объекта'. Объект создается ключевым словом new, и этот метод создания объекта называется 'конструктором'.

"Вызываем конструктор Dog"
	var cat = new Dog();		// не уверен, что правильно записал/прочитал
"Создадим новый объект на основании функции Dog"
	firstDog = new Dog;
	
<!> К слову, конструктор можно вызывать как со скобками, так и без.

Ключевое слово new создает новый экземпляр, вроде копии, но не совсем. Это скорее как размножение: конструктор создает объект на основании изначальной функции, но у каждого экземпляра будет свой набор свойств.

Аргумент this укажет на каждый экземпляр объекта. 
	return console.log(this);
Если мы вызываем атрибут this внутри объекта, он указывает на этот объект. В противном случае он укажет на глобальный.
Когда мы используем конструктор new, параметр this будет содержать копию того объекта, кот. мы создали.

<!> Имена конструкторов пишутся с Большой буквы. Конструктор - функция, создающая объект.

Часто объекты стоит создавать через добавление метода. Тем не менее, конструктор объектов позволяет вам динамически вызывать новые экземпляры объектов.

____________________________________________________________________

Немного о прототипах

Вот такая ебалабула:
-------------------------------------------
	var speaked = function(saywhat) {	// метод
		console.log(saywhat);
	}
	var Dog = function() {				// объект
		var name, breed;
	}
	Dog.prototype.speak = speaked;	// speak - прототип	
	firstDog = new Dog;					// экземпляр, заимствующий функционал Dog
	firstDog.name = "Rover";
	firstDog.breed = "Doberman";
	firstDog.speak("Woof");
-------------------------------------------
Dog.prototype.speak = speaked;
Dog - конструктор
.prototype - связующая хрень
.speak - метод
speaked - функция

____________________________________________________________________

МЕТОДЫ CALL & APPLY или 'непрямой вызов'

Дают > контроль над аргументом this. C их помощью можно определить значение аргумента this.
Можно также контроллировать this и передавать ему к-то аргументы, поскольку call и apply используют 2 параметра: желаемое значение аргумента this внутри функции, а также те аргументы, кот. вы хотите передать функции. Разница в том, что 'call' передает значение, а 'apply' - массив.
	speak.call(saySomething)	// где speak - функция, call - метод, а saySomething - объект
	"Тут я беру saySomething и передаю его методу speak в качестве праметра this"

.call. и .apply. дают возможность привязывать объекты к функциям в качестве параметра this, так функции становятся еще более гибкими.

____________________________________________________________________

ПРО return

Утверждение return доступно только в теле функции, больше его нигде использовать нельзя. Оно используется, чтобы отослать что-то обратно вызывающему. Его можно присвоить var, тогда оно поставит значение в переменную, когда вернется функция. Утверждение return - это, как правило, последнее утверждение в функции. Его можно поставить где угодно в функции, но тогда оставшаяся часть функции не сможет запуститься.
Утверждений return можно поставить сколько угодно, так что, если хотите, можете исп. if, чтобы остановить функцию и вернуть значение на основании др. условий.
return может вернуть что угодно или ничего, включая возврат др. функций, объектов либо, опять же, ничего вообще. 

____________________________________________________________________

var myVar = document.querySelectorAll(".someclass"); - позволяет выбрать элемент в DOM с опр. классом.
____________________________________________________________________

"Создать var, а затем выполнить ее как функцию."
____________________________________________________________________

САМОВЫЗЫВАЮЩАЯСЯ ФУНКЦИЯ

1. Вызов функции, кот. присвоена переменной, вручную:
	var iKnow = function kung() {		// имя функции редко исп., только для рекурсии
		console.log('foo'); }
	iKnow();	// foo
2. Самовызывающаяся функция или Вызов анонимной функции:
	var iKnow = function() {		// убираем ИД
		console.log('foo');
	}();		// скобки превращают объявление функции в выражение
Здесь не нужно имя, поскольку мы не исп. его внутри функции. Если бы была нужна рекурсивность - другое дело.
3. Самоосуществляющаяся функция или анонимное замыкание:
Поскольку мы исп. функцию саму по себе, ей нужно имя, а его уже нет. Тогда можно попросить JS сделать из функции значение и через скобки передать к-то значения.
	(function() {
		console.log('foo');
	})();
Такой паттерн называется (см. заголовок), поскольку у нее нет имени, и все созданные внутри функции будут доступны только внутри функции. Любая переменная, созданная внутри не будет доступна на глобальном уровне, вне функции. Это вообще-то хорошо, потому что мы так защищаем var внутри функции. Иными словами, мы запираем var внутри этой функции от всего остального мира, поэтому это называется 'замыканием'. Этот паттерн очень важен в JS, особенно при работе с модулями.

* Когда исп. keyword function, JS думает, что мы хотим создать функцию с именем.
* Скобки превращают объявление функции в выражение.
* Анонимная (самовызывающаяся) функция не имеет имени, но присваивается var с именем и через нее вызывается.
*s Самоосуществляющейся функции не нужны ни var, ни собственное имя, она просто оборачивается в ().

____________________________________________________________________

ОБЛАСТЬ ВИДИМОСТИ

ОВ var - это то, когда и где в коде var существует и имеет опр. значение.
ОВ функции - любая созданная внутри этой функции var, будет локальна ей. var, созданная в родительской ф. также будет жить в дочерней.

'Цепочка областей видимости' опр., что произойдет, если функция не сможет найти var внутри своей функции. Грубо говоря, она станет искать var во всех родительских ф.

ПОДНЯТИЕ ОПРЕДЕЛЕНИЙ ПЕРЕМЕННЫХ
В процессе обработки браузером JS меняет местами объявления о переменных и ставит их сверху их функциональной области видимости. Т.е. браузер изначально знает о существовании всех var, не зная их значений.
Мы видим так:
	function myDog() {
		console.log(dogName + ' says woof');	// undefined says woof
		var dogName = "Fido";
	}
Браузер видит так:
	function myDog() {
		var dogName;	// браузер поднимает var над scope, объявляет сразу
		console.log(dogName + ' says woof');
		dogName = "Fido";
	}
Даже объявление второй одноименной var на глобальном уровне не поможет, ибо внутри функции ее значение обновится на undefined.

____________________________________________________________________

return - утверждение возврата.
____________________________________________________________________

"Создаю var myArguments и выставляю их на те аргументы, кот. приходят к моей функции или ни на что вообще."
	var myArguments = arguments[0] || '';
	
<!> Функцию можно обернуть в скобки, чтобы защитить от глобальной области видимости.

____________________________________________________________________

МОДУЛИ

Модули позволяют исп. 1 и тот же код в неск. приложениях. Они пригождаются, когда при написании нового кода надо позаимствовать строки из старого. М позволяют исп. этот код заново, не копируя и не вставляя, они как бы создают библиотеки для этого.
Первым делом нужно создать пространство имен: оно защитит var вашего модуля от глобальных var (это важно, если они одноименные). Мы знаем, что 'функцию можно обернуть в скобки, чтобы защитить от глобальной области видимости'. Но что, если мы хотим иметь доступ к этим var из приложения? Для этого нужно создать var и присвоить ее самоосуществляющейся функции, тогда мы получим доступ к содержимому.
	var ray = (function() {
		var private;	// эти var не будут доступны вне функции
	})();
Мы создали пространство имен для var ray, так что в эту функцию доступ у нас есть. Если нужно вытащить или осуществить что-то из функции вне основного приложения, исп. утверждение возврата return. кот. поможет связаться с остальной частью приложения. Так мы сможем сделать видимым то, о чем наше app должно знать. Хотя вместо возврата устверждения мы можем вернуть объект, а через объект создать var и функции.

Исп. return, чтобы вернуть объект. В этом объекте добавим элемент speak().
	var ray = (function() {
		return {
			speak: function() {
				console.log('hello');
			}
		};
	})();
Пока у меня есть функция, к кот. я имею доступ через пространство имен, и, создав функцию, я могу вывести что-то в основное приложение. Для этого в HTML-документе после ссылки на главный скрипт создадим новый скрипт и вызовем в нем фукнцию.
	<script>
		ray.speak();	// в консоли появится hello
	</script>
Так мы создали модуль и можем выполнить его из основного приложения, пространство имен при это останется защищенным. Впрочем, главное, на что стоит обратить внимание, мы добавили пространство имен, чтобы защитить содержимое модуля от глобальных var. Плюс мы исп. return для выполнения тех функций, кот. должно выполнять наше app. 
	
____________________________________________________________________

МОДУЛИ ЧЕРЕЗ ЗАМЫКАНИЯ (из учебника)

Цель модуля - скрыть внутренние детали реализации скрипта. В том числе: временные переменные, константы, вспомогательные мини-функции и т.п.

Предположим, мы хотели бы распространять некий скрипт в виде библиотеки, чтобы любой желющий мог подключить его и пользоваться функционалом. Достаточно скачать и подключить, например, как внешний файл hello.js - и готово. Если подключить подобный скрипт к странице «как есть», то возможен конфликт с переменными, которые она использует. То есть, при подключении к такой странице он её «сломает».

Чтобы проблемы не было, всего-то нужно, чтобы у скрипта была своя собственная область видимости, чтобы его переменные не попали на страницу.
Для этого мы завернём всё его содержимое в функцию, которую тут же запустим.

(function() {
	var message = "Привет";		// глобальная переменная нашего скрипта
	function showMessage() {		// функция для вывода этой переменной
	alert( message );
	}
	showMessage();		// выводим сообщение
})();

Cкобки нужны, чтобы показать, что у нас не Function Declaration, а Function Expression, который по правилам JS можно вызвать «на месте».

<!> «На месте» разрешено вызывать только Function Expression.

Можно показать это другим способом, например поставив перед функцией оператор:
	+function() {
	alert('Вызов на месте');
	}();
	!function() {
	alert('Так тоже будет работать');
	}();



____________________________________________________________________

ОЧЕНЬ ПОКАЗАТЕЛЬНЫЙ ПРИМЕР

var message = "Привет";		// объявили

function showMessage() {		// упаковали
	alert(message);
}

showMessage();					// вызвали

____________________________________________________________________

	var arr = [ 1, 'Имя', { name: 'Петя' }, true ];	// микс значений
	// получить объект из массива и тут же его свойство
	alert( arr[2].name );	// Петя
____________________________________________________________________








СОБЫТИЯ JS

Событие в JS может произойти когда угодно: после загрузки страницы в браузере, наводки курсора на ссылку, после загрузки видео или отсылки анкеты. Все это - события, и если вы хотите назначить к-то задание таким вещам, вам необходимо прехватить событие при помощи 'регистрации событий'. Т.е. вы попросите браузер сделать что-либо в случае этого события. 

Есть неск. способов сделать это:
1. Исп. атрибуты тэгов.
    <li><img src="images/pnk.gif" alt="pink" onclick="alert('pushed pink')"></li>
	Но это плохая практика, т.к. код становится сложно обновлять.
2. Точечная нотация.
Сначала обозначаете, до какого элемента в DOM хотите добраться, а потом обозначаете, какое событие нужно выследить. Когда это событие произойдет в элементе ваш код запуститься.
	<li><img src="images/pnk.gif" alt="pink"  id="pink"></li>
	<script>
		document.getElementById('pink').onclick = function() {
			alert('Pushed pink'); };
	</script>
3. Метод .addEventListener()
Его можно исп. с любым элементом на странице. На первый взгляд выглядит, как точечная запись, поскольку спрашивает тип события, функцию и булин (тип распространения).
	   <li><img src="images/pnk.gif" alt="pink" id="pink"></li>
	<script>
		document.getElementById('pink').addEventListener('click', function() {
		// слушаем только те события, что происх. внутри элемента pink
		alert('Clicked on pink');
		}, false);	// обрати внимание, что элементы отделются запятыми
	<script>
Преимущество этого способа в том, что он позволяет отслеживать неск. событий 1 вызовом (распространение событий). Еще 1 +, что событие мб запушено не DOM'овыми элементами, т.е. с помощью этого метода можно написать собственное событие, а разные части кода могут следить за теми событиями, кот. вы создали и в зависимости от этого запускать части кода.

____________________________________________________________________

АНАЛИЗИРУЕМ СВОЙСТВА СОБЫТИЙ

Когда вы зарегистрируете и перехватите событие, вы получите от браузера объект соытия. Полученные данные также зависят от типа запрашиваемого события, но во многих событиях есть много общей информации. Рассм. инфы, кот. может вернуться от объекта события.
	// передаем функции объект события
	document.getElementById('pink').addEventListener('click', function(e) {
	console.log(e);	// MouseEvent { много свойств }
	}, false);	
	
Из MouseEvent получим много инфы, разделим ее на неск. секций.

Event Info:
a) type - тип получаемого события;
b) timestamp - временная метка, т.е. время, когда произошло событие, чтобы мб делать что-то после события;
c) defaultPrevented - предотвращение события по умолчанию (можно при клике по ссылке не дать браузеру по ней перейти, а сделать что-то другое).

Targeting info (инфа об ориентации):
a) current target - элемент, кот. было присвоено событие. Это не обяз. то событие, по кот. нажали, поскольку событие может отслеживать другой элемент;
	<li><img src="images/pnk.gif" alt="pink" id="pink"></li>
	// отслеживаем клик по img, хотя могли отслеживать клик по li
b) target - элемент, из кот. исходит событие, но не обяз. тот элемент, кот. оно было присвоено;
c) srcElement - исходный элемент, кот. запустил событие;
d) fromElement и toElement - относятся к события наведения и уведения курсора.

Coordinate Info (инфа о координатах):
a) screen X,Y - позиция по отношению к экрану пользователя;
b) client X,Y - позиция по отношения к окну;
c) layer X,Y - ~ к др. позиционрированному элементу (позиционир. в CSS);
d) page X,Y - ~ к HTML-документу;
e) offset X,Y - к элементу, запустившему событие.

Key/Mouse info (инфа о клавиатуре и мыши):
a) charCode/keyCode - способы опр., какой знак был нажат;

Немногое из того, что осталось, смотри в видео.

____________________________________________________________________

РАСПРОСТРАНЕНИЕ СОБЫТИЙ

Позволяет одному элементу перехватить все события его дочерних элементов. В предыдущем примере мы слушали события только внутри элемента 'pink'.
	document.getElementById('pink').addEventListener('click', function() {
	alert('Clicked on pink');
	}, false);
С распространением можно прослушать все события в неупорядоченном списке.
	<ul class="grid">
		<li><img src="images/ylw.gif" alt="yellow"></li>
		<li><img src="images/org.gif" alt="orange"></li>
		<li><img src="images/ppl.gif" alt="purple"></li>
		<li><img src="images/blu.gif" alt="blue"></li>
		<li><img src="images/pnk.gif" alt="pink"></li>
		<li><img src="images/grn.gif" alt="green"></li>
		<li><img src="images/ygr.gif" alt="ygreen"></li>
		<li><img src="images/gry.gif" alt="gray"></li>
		<li><img src="images/red.gif" alt="red"></li>
	</ul>
	<script>
		document.getElementById('grid').addEventListener('click', function() {
			console.log(e);
		}, false);
	</script>

Вывод: вместо того, чтобы вставлять однотипный слушатель в каждый элемент, можно назначить слушатель родительскому элементу.

Есть 2 модели распространения события, основанных на порядке перехвата события браузером. 
1. Capturing или 'захват события на стадии перехвата': по клику браузер проходит вниз по DOM, регистрируя событие сначала в ul>li>img.
2. Bubbling или 'захват события на стадии всплывания': браузер заметит событие сначала на самом нижнем уровне элемента (img) и передаст его вверх по цепочке вплоть до ul.

____________________________________________________________________

ОСТАНАВЛИВАЕМ РАСПРОСТРАНЕНИЕ СОБЫТИЙ (stopping propagation)

Распространение событий сэкономит кучу времени, позволив захватить событие в родительском элементе, а не регистрировать событие в каждом отдельном элементе. Но иногда приходится остановить распространение события по цепи DOM. Есть метод stopPropagation().
	document.getElementById('pink').addEventListener('click', function(e) {
		console.log('pink');
	e.stopPropagation();
	}, false);  	// должно быть всплытие, а не перехват

____________________________________________________________________

ОТМЕНЯЕМ ПОВЕДЕНИЕ ПО УМОЛЧАНИЮ

Для контроля поведения по умолчанию сущ. метод preventDefault().
	document.getElementById('grid').addEventListener('click', function(e) {
		e.preventDefault();	// default event перехватывается, выполняется след. код
		console.log('Clicked inside the UL');
	}, false); 

____________________________________________________________________

УДАЛЯЕМ ЭЛЕМЕНТЫ DOM С ПОМОЩЬЮ СОБЫТИЙ

	document.querySelector('.grid').addEventListener('click', function (e) {
		var removeTarget = e.target.parentNode;
		removeTarget.parentNode.removeChild();
		// метод .removeChild() ссылается на родителя эл-та, кот. хотим удалить - ul
		// прося parentNode, запрашиваем ul, и дальше нам надо удалить его дочерний элемент
	}, false);
Просто удалить li нельзя. removeChild() удаляет дочерний элемент, а значит, если мы хотим удалить li, нужно добраться до родителя ul.
____________________________________________________________________

РЕШАЕМ ПРОБЛЕМЫ С СОБЫТИЯМИ.mp4	(0202)

document.querySelector('.grid').addEventListener('click', function (e) {
	if (e.target.tagName === 'IMG') {
		console.log(this);
		var howmany = this.querySelectorAll('li').length;
		if (howmany > 1) {	
			var removeTarget = e.target.parentNode;
			removeTarget.parentNode.removeChild(removeTarget);
		} else {
			var photoTitle = e.target.alt;
			document.querySelector('#art p').innerHTML = "<p>You've picked: " + photoTitle + "</p>";
		};	// how many
	};	// check to see that I clicked on IMG only
}, false);	// click event

____________________________________________________________________

СОЗДАЕМ ЭЛЕМЕНТЫ DOM С ПОМОЩЬЮ СОБЫТИЙ

"Я выделяю ul с классом grid, потом добавляю слушатель событий".

Для создания элемента в JS нужно использовать метод createElement().

Создам var и передам элемент, кот. нужно создать. Впишу div и в памяти будет создан элемент. 
	var myElement = document.createElement('div');
Нигде на странице он больше не появится, только в памяти, так что нам нужно прикрепить его к DOM-элементу. Сейчас с ним можно делать что угодно, например, присвоить id или class.
	myElement.id = 'rollover';
	myElement.className = 'preview';		// просто class нельзя
Далее прикрепим элемент где-то на странице. Где конкретно - это важно: его нужно прикрепить на уровне элемента списка. Если напишем e.target, нам выдадут картинку, но img мы прикрепить не можем, потому что это не контейнер. Значит, нужно прикрепить к элементу списка, в кот. содержится картинка: нужно запросить родителя конкретной цели.
	e.target.parentNode.appendChild();		// так мы добавим элемент
	e.target.parentNode.appendChild(myElement);	// передаем имя элемента, кот. хотим прикрепить

Всегда есть 3 шага: 
1. Создаете элемент.
2. Меняете к-то свойства.
3. Прикрепляете элемент к существующему элементу в DOM.
Все готово!


<!> ВНИМАНИЕ !
.createElement('div');		// тут el с кавычками
но
.appendChild(myImg)	// тут var без кавычек


"Сделаю эту var источником местоположения картинки"
var imgLoc = e.target.src;

	e.target.addEventListener('mouseout', function handler(d) {		// это событие я назвал 'd'
		var myNode = d.target.parentNode <...>	// нужно передать 'd' target.parentNode
	}, false);

____________________________________________________________________

УДАЛЯЕМ СОБЫТИЕ

События в JS занимают место в очереди и остаются там, пока не будут вызваны. Так что, если нек. из них не удалить, возникают такие проблемы.


____________________________________________________________________

"В данном случае мне не надо передавать функции событие..."
highRes.addEventListener('load', function() {...} 
____________________________________________________________________

Атрибут data-*

В HTML5 появился новый универсальный атрибут, который можно добавлять к любому тегу. Правила написания атрибута простые:
- всегда начинаем с data-;
- используем только латинские буквы, (-), (:) и (_).

Вот несколько задач, где это может потребоваться:
1. Создание всплывающих подсказок без применения скриптов.
2. Определение стиля элемента на основе значения атрибута.
3. Получение и изменение значений через скрипты.

____________________________________________________________________

"songPlaying будет искать любой элемент в DOM с id player"
var songPlaying = document.querySelector('#player');

____________________________________________________________________

"Эта функция получит событие, а в событии мы вызовем var whichArt и сделаем ее целью события по клику, чтобы цель клика передавалась бы whichArt."
	function moveStart(e) {
		whichArt = e.target; 	// e,target - цель того, по чему мы кликнули
	}	
____________________________________________________________________











JS и AJAX (Асинхронный JS и XML)

AJAX позволяет создавать веб-приложения, кот. обновляют страницы без необходимости перезагрузки их с сервера.

AJAX - это разговор, происх. между сервером и вашим браузером.

AJAX - это не 1 технология, а группа совместно работающих. 
'Асинхронный' - значит, может запросить любую часть инфы с сервера в любое время, ему не нужно ждать перезагрузки страницы. Новый запрос мб вызван каким-либо событием: клик, наведение, что угодно. 
'JS' управляет событиями, кот. вызывают новые запросы, делает эти запросы на сервер и занимается обновлением только той части документа, кот. надо изменить. 
JS общается с сервером с помощью набора методов программирования 'API' и исп. XHR-запросы или XML-HTTP. 'XHR' позволяет браузеру посылать и получать данные с сервера.
____________________________________________________________________

ИСПОЛЬЗОВАНИЕ СИНХРОННЫХ XHR-ЗАПРОСОВ

Первый шаг в работе с AJAX - изучить API, кот. предоставляют браузеры для отправления и получения инфы. Способ получения доступа к API - исп. запрос XML-HTTP или объект XHR.

Необх. создать запрос к объекту XHR. 
Открывающая функция open() предусматривает 3 par (параметра): метод (POST/GET), расположение файла data и булин, указывающий на асинхронность запроса. 
* Запросы AJAX подчиняются правилу ограничения домена: нельзя запрашивать объекты данных с доменов, отличных от вашего. 
Сделаем запрос синхронным: браузер будет ждать завершения запроса, прежде, чем что-то сделать.
	var request = new XMLHttpRequest(); 
	request.open('GET', 'data.txt', false);	   // метод, расположение, асинхронность
	// запрос создан, но чтобы отправить на сервер нужна команда send()
	request.send();


API AJAX браузеров поддерживает свойство 'readyState' (состояние готовности запроса), где есть цифра, указывающая прогресс совершения запроса: 0 - запрос еще не был отправлен, а когда значение достигает 4 - операция отправления и получения запроса завершена.
Нужно сделать, чтобы наш код проверял значение readyState, и если оно = 4, значит запрос был получен и можно что-то сделать с возвращенными данными.

____________________________________________________________________

Создадим var modify и установим, чтобы она была равна элементу DOM с id update.
	var modify = document.getElementById('update');
Теперь, когда я обратился к этому div с помощью var modify, я могу исп. ее и изменить на что угодно внутренний код HTML. Я исп. запрос request и буду ждать текст ответа.
	modify.innerHTML = request.responseText; 
	
Поместим массив элементов в var modify.
	var modify = document.getElementsByTagName('li'); 
	modify[2].innerHTML = 'Текст для 3-го элемента списка'; 

Обрашаеммся ко 2 ul с помощью индекса [1], а затем получаем доступ к элементам li внутри него и присвоим 3-му li значение свойства responseText.
var modify = document.getElementsByTagName('ul')[1].getElementsByTagName('li');
modify[2].innerHTML = request.responseText;
	

"Умение работать с массивами - это ключ к изменению DOM с помощью AJAX"

____________________________________________________________________

ПАРСИНГ XML С ПОМОЩЬЮ AJAX

Каждый элемент внутри структуры XML рассматривается как отдельный узел. А элементы внутри элементов, включая и текст внутри элемента, также рассматриваются как узлы. Чтобы добраться до текста узла, можно использовать childNodes[0].

console.log(request.responseXML.getElementsByTagName('name')[1]);
// <name>Jonathan G. Ferrar II</name>
console.log(request.responseXML.getElementsByTagName('name')[1].childNodes[0]);
// "Jonathan G. Ferrar II"
console.log(request.responseXML.getElementsByTagName('name')[1].firstChild);
// "Jonathan G. Ferrar II"
console.log(request.responseXML.getElementsByTagName('name')[1].firstChild.nodeValue);
// Jonathan G. Ferrar II


Несмотря на то, что можно читать данные из любого формата, кроме XML, API AJAX был спроектирован с легким в использовании свойством .responseXML. Оно обычно и исп., чтобы читать файлы XML.

____________________________________________________________________

Несмотря на то, что AJAX был спроектирован для работы с файлами XML, он может читать содержимое любого текстового файла. Трюк заключается в том, как разобрать и перевести данные в объекты, кот. может манипулировать JS. Очевидный выбор - файлы JSON. Это способ структурирования данных, чтобы их было легко конвертировать в объекты JS.

Создам var items, установлю ее = объекту JSON и исп. команду .parse с текстом ответа из нашего запроса.
	var items = JSON.parse(request.responseText); // [Object, Object, Object, Object]

____________________________________________________________________

onclick, onmouseover и прочее - это обработчики событий.

onload применим только к window или body.
____________________________________________________________________

РАБОТА С JQUERY И AJAX

Вывести сообщение в JS:
	var request = new XMLHttpRequest();
	request.open('GET', 'data.txt', false);	    // Hello World
	request.send();
	document.writeln(request.responseText);

Вывести сообщение с jQuery:
	$('#update').load('data.txt');    // Hello World
____________________________________________________________________

ПРОСМОТР ДАННЫХ С ПОМОЩЬЮ JQUERY

Чтобы загрузить структурированные данные .json, в jQuery есть метод getJSON(). 

Вызовем метод getJSON() и поместим внутрь него неск. элементов: 1) имя файла, кот. хотим загрузить; 2) анонимную функция с параметром data, который получили из команды getJSON() в эту функцию.
-----------------------------------------------
	$.getJSON('data.json', function(data) {	// data получили из команды getJSON
		console.log(data); // массив объектов [Object, Object, Object ... ]
	})

Вместо цикла JS for...in будем исп. встроенное утверждение jQuery '.each'.
	
____________________________________________________________________

ПОДГОТОВКА ПРИЛОЖЕНИЯ AJAX LIVE SEARCH

<label> - это текст, кот. идет с полем ввода <input>.  Можно сделать, чотбы при клике по лейблу нас перепрасывало в поле ввода.

	<div id="searcharea">
		<label for="search">Live Search</label>
		<input type="search" name="search" id="search" placeholder="name or info" />
	</div>

____________________________________________________________________

'Получается, задав параметр функции, мы создаем внутри нее var?'
____________________________________________________________________

ПОИСК ДАННЫХ JSON

Как получать события из поля ввода и исп. эти события для управления поисковым функционалом нашего приложения. Мы можем проверять, происходит ли событие, когда пользователь взаимодействует с к-то элементом на странице. Это называется 'привязкой события к элементу'.

	// обратимся к элементу N и привяжем к нему событие keyup
	$('#search').keyup(function() {});

Регулярные выражения позволяют делать нечувствительные к регистру и более мощные поиски.

'Регулярное выражение будет брать поле поиска searchField и выполнять нечувствительный к регистру поиск, если написать "i".'
	var myExp = new RegExp(searchField, "i");

'Нужно найти регулярное выражение в поле имени (внутри тега name) или в поле биографии'.
	if ((val.name.search(myExp) != -1) || (val.bio.search(myExp) != -1)) {...}

____________________________________________________________________

СТИЛИЗАЦИЯ ПРИЛОЖЕНИЯ ПРИ ПОМОЩИ CSS

До сих пор мы занимались созданием функции живого поиска, кот. исп. AJAX для поиска по файлу данных JSON.

____________________________________________________________________




















ОСНОВЫ NODE.JS

"Т.к. мы вызвали функцию require() и присвоили ее var announce, то announce приобрела статус функции. Так что во 2 строке мы можем вызвать announce уже как функцию и передать ей значение".
	var announce = require('./announce');		// (модуль)
	announce('Node Essential Training');

Модули - это основополагающие составляющие для программ, выполняемых в Node.js. Модули помогают реализовать код в виде независимых, самодостаточных объектов.

	var http = require('http');	// http - модуль

"Переменной flight присваивается значение, которое возвращает функция require".
	var flight = require('./flight');

____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________

____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________

____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________

____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________

____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________

____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________


____________________________________________________________________
