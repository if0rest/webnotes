Лаврик

===================================================
HTML И CSS: ХИТРОСТИ БЛОЧНОЙ МОДЕЛИ
===================================================
Ширина элемента определяется как:
width + (margin + padding + border)*2
---------------------------------------------------
Есть 2 стандартных способа отмены обтекания (float):
1. Если надо 2-й эл-т поставить справа от "утекшего", мы пишем "overflow: hidden", убираем перекрытие, и он не наскакивает, проспукая слева от себя.
2. Чтобы обтекание вообще не состоялось, пишем "clear: both".
---------------------------------------------------
Вертикальные margin'ы не суммируются, а схлопываются в пользу наибольшего значения: если у верхнего блока mb:100px, а у нижнего - mt:80px, то внешний отступ будет 100px.
Это делалось до появления псевдоэлементов.
---------------------------------------------------
Расположить блок по центру с разными отступами вверху-внизу:
   margin: 30px auto 10px;
---------------------------------------------------
Отступы между блоками при "display:inline-bloсk" из-за переноса строк в HTML-коде. При 'display:flex' или 'float:left' такого нет.
---------------------------------------------------
СИТУАЦИЯ:
описанный для дочернего элемента margin, не растягивает родительский контейнер, однако смещение относительно страницы все же происходит.

   <div class="wrapper">
      <div class="inner">Здесь что-то написано.</div>
   </div>

   .wrapper {
		background: #aaa;
		border: 1px solid transparent;	/* кривой хак */
   }
	.inner {
		margin: 10px 0;
	/* отступы выйдут за пределы родителя, но не растянут его */
		display: block;
		display: inline;      	/* уберет отступы вовсе */
		display: inline-block;	/* отработает как надо */
	}

Универсальным боевым решением является 'overflow:hidden' для родителя, кот. запрещает margin'ам дочерних элементов выходить за его пределы. Т.е. если у элемента 'overflow:hidden', margin'ы из него не утекут.
	.parent	{ overflow: hidden }
	.child	{ margin: 10px 0 }

Еще проще - padding для parent, вместо margin для child.

Итоговый набор решений:
1. Рамка -
2. overflow:hidden +
3. padding для родителя +
---------------------------------------------------
СИТУАЦИЯ:
Родитель принимает высоту "нормального" элемента-ребенка и игнорирует высоту ребенка с float.
РЕШЕНИЕ 1 (с замечанием):
Присвоить родителю 'overflow:hidden'. В итоге от растянется, не выпустив ребенка за свои пределы.
* Этот прием спасает практически всегда, кроме ситуаций с абсолютно спозиционированным элементом, который лежит на стыке блоков, частично выходя за пределы родителя: в этом случае его обрежет.
РЕШЕНИЕ 2 (с замечанием):
Добавить крайний div без высоты и с 'clear:both'.
* Лишний div и небольшой '-' для SEO.
РЕШЕНИЕ 3:
Использовать псевдоэлемент ::after.
	.parent::after {
		content: '';
		display: block;
		clear: both;
	}
А лучше сразу отдельный класс .clearfix::after
---------------------------------------------------
ФИШКА
Псевдоэлементы умеют читать атрибуты тегов:
	el::after {
		content: attr(data-*)
	}
---------------------------------------------------
СИТУАЦИЯ:
Надо равномерно распределить блоки внутри родителя.
РЕШЕНИЕ:
	.parent {
		display: flex;
		justify-content: space-between;
	}
---------------------------------------------------



===================================================
ОСНОВЫ И ЭВОЛЮЦИЯ АДАПТИВНОЙ ВЁРСТКИ
===================================================
ВОПРОС:
"Начиная делать адаптивную верстку, как и в каких единицах мы задаем ширину главного элемента (обертки, которая делает цетровку сайта)?"
ОТВЕТ:
В свойстве 'max-width' в px.
Распространенная практика, когда создается div на всю ширину страницы, а внутри него обертка, цетрирующая контент.
   <header>
      <wrapper>
      ...
   .wrapper {
      max-width: 1024px;
      margin: 0 auto;
   }
---------------------------------------------------
"Нужно ли указывать min-width? Как правило, нет, хватает max-width. Зависит от того, как верстаете: от простого к сложному или наоборот. Несмотря на возгласы при Mobile First (триггером выступает min-width), всё равно все верстают под большие экраны, а потом адаптируют под малые."
---------------------------------------------------
Горизонтальные margin не схлопываются.
---------------------------------------------------
Родительскому блоку можно задать отрицательный margin.
   margin: 0 -1.5%;
Это заставит его сместиться на/под соседний элемент (при этом, сосед будет невозмутимо стоять, где стоял), и дочерние элементы последуют за ним.

<!> overflow:hidden отрицательные margin вырезает.
---------------------------------------------------
"У внутренних элементов вся сила в процентах".
---------------------------------------------------
viewport и initial-scale сработают только на мобильном устройстве. Десктопный браузер их проигнорирует.
---------------------------------------------------
height для адаптивной верстки - ЖЕСТЬ. Если уж О-о-очень хочется, то можно min-height.
---------------------------------------------------
ПОДВОДЯ ИТОГ...
1. Адаптировать просто и приятно ХОРОШУЮ верстку.
Если внутренние элементы прописаны в px или им заданы высоты - вы будете биться головой о стену.
Если верстка хорошая, пишем viewport, медиазапросы и исп. % как единицу измерения.
---------------------------------------------------



===================================================
ОСНОВЫ И ЭВОЛЮЦИЯ АДАПТИВНОЙ ВЁРСТКИ
===================================================
clearfix препятствует схлопыванию родителя по высоте, когда детям присвоено float:left.
---------------------------------------------------



===================================================
ТИПИЧНЫЕ ПРИЁМЫ АДАПТИВНОЙ ВЁРСТКИ
===================================================
БУРГЕР-МЕНЮ

1. Вариант со скриптом:
	$('.menuToggle').on('click'. function() {
	   $('.menu').slideToggle(300, function() {
			if ($(this).css('display') === 'none') {
				$(this).removeAttr('style');
	      }
	   })
	})

2. Вариант на чистом CSS:
	<label class="menuToggle" for="menuCheck">Меню</label>
			<input type="checkbox" id="menuCheck">
			<ul class="menu clearfix">
				<li><a href="#">Главная</a></li>

	#menuCheck { display: none }
@media ... {
	#menuCheck:checked + .menu { display: block }
}
---------------------------------------------------
"Тут предлагают высоту в % задать. Попробуем. Видите, не работает: ему не от чего высоту отсчитывать. Т.е. высота в % применяется, только если у родителя жестко задана высота в px. Тогда у ребенка сработает высота в %".
---------------------------------------------------
ПРОПОРЦИОНАЛЬНЫЕ ЭЛЕМЕНТЫ

"Кто знает, от какого значения будет расчитываться padding-top? От какого значения берем %? Прикол в том, что заданная в % высота элемента рассчитывается из пиксельной высоты родителя, а заданный в % padding рассчитывается из ШИРИНЫ РОДИТЕЛЯ"
ВЫВОД: «Заданный в % padding ребенка расчитывается из ширины родителя».

ПОЛНОСТЬЮ АДАПТИВНЫЙ ФРЕЙМ С YOUTUBE
«Как вставить iframe c YouTube, чтобы он пропорционально масштабировался при ресайзе страницы?»

================== CODE START ==================
	** HTML **
<div class="relation">
	<div class="relation__ratio"></div>
	<iframe class="relation__content" src="" allowfullscreen></iframe>
</div>

	** CSS **
.relation {
	position: relative;
	max-width: 600px;
}
.relation__ratio {
	padding-top: 56.25%;
	height: 0;	/* лишняя подстраховка */
}
.relation__content {
	position: absolute;
	height: 100%;
	width: 100%;
	top: 0;
	left: 0;
	border: 0;
}
================== CODE FINISH ==================
* Хорошая идея - намножить классы типа ratio_16x9, ratio_1x1 и т.д., и присваивать фреймам в зависимости от начальных пропорций видео.
	.ratio-1x1  { padding-top: 100% }
	.ratio-4x3  { padding-top: 75% }
	.ratio-16x9 { padding-top: 56.25% }
---------------------------------------------------
<!> Напоминаю про связку: float:left + overflow:hidden
---------------------------------------------------
REM
Значение самого корневого элемента (html) становится множителем.
Чем больше вложенность, тем сложнее рассчитывать em.

html { font-size: 16px }
h1 {
	font-size: 3rem;	// 16*3=42px
	margin: 1.5rem 0;
}
h2 {
	font-size: 2rem;
	margin: 1rem 0;
}

При адаптивной верстке мы просто меняем значение font-size у html, что автоматически изменит значения др. элементов, указанных в rem.
@media screen and (max-width) {
	html {
		font-size: 14px;
	}
}
---------------------------------------------------
---------------------------------------------------
---------------------------------------------------
---------------------------------------------------
---------------------------------------------------
---------------------------------------------------
---------------------------------------------------
---------------------------------------------------
