mysqli_fetch_row() - возвращает ряд данных и привязывает их к обычному []. Ключами к каждой из колонок будут целые числа. Если нам надо menu_name, то запрашиваем, что в колонке 1 (первая позиция в []).
mysqli_fetch_assoc() - то же самое, но результат будет возвращен в ассоциативном []. Ключами будут названия колонок.
mysqli_fetch_array() - то же, но результат либо в обычном, либо в аcсоц. либо оба [].
mysqli_fetch_object() - вытаскиваем данные и заполняем ими {}.

mysqli_insert_id() - просим mysql вставить запись без указания id (mysql приэтом исп. автоприращение)

Экранирование строк для MySQL:
mysqli_real_escape_string($connection, $menu_name);


include
require
echo
isset();    // сущ. ли var
unset();    // удалить var
print_r
var_dump
array_shift             // удаляет первый элемент []
array_unshift           // добавляет элемент в начало []
array_pop               // убирает последний элемент []
array_push($arr, 'val') // добав. элемент в конец []
array_flip;                                     // меняет местами ключи с их значениями
time()                                                      // время с 1970
date('Y-m-d H:i:s')
mktime(2,30,45,10,1,2009)     // созд. временную метку (H:i:s и m-d-Y)
checkdate(12,31,2000)         // проверка даты на существование
strtotime()

get_class_vars('Person')   // вернет все var внутри класса Person

Узнать дирректорию файла, с кот. работаете с помощью магич. константы:
echo __DIR__;

Проверить существование файла:
   file_exists(__FILE__);  // это неправильная запись


---------------------------------------------------------
ФУНКЦИИ ОТ ДУДАРЯ
---------------------------------------------------------

ДЛЯ РАБОТЫ С ТИПАМИ ДАННЫХ
   isset($x) - проверяет существование var $x.
   unset($x) - полностью удаляет var $x.

ПРОВЕРКА СООТВЕТСТВИЯ ТИПУ:
   is_numeric($x) - является ли $x набором цифр. И 15 и "15" вернет true.
   is_integet($x) - является ли числовым литералом.
   is_double() - является ли float, нецелочисленным.
   is_string() - является ли строкой.
   is_bool() - является булином.
   is_scalar() - является ли примитивом, простым литералом (не [] и не {}).
   is_null() - true, если var undefined.
   is_array() - является ли массивом.
   gettype($x) - узнать тип var.

СТРОКОВЫЕ ФУНКЦИИ
   $string = "This is example!";
   strlen($string) - количество символов в строке.
   strpos($string, "exa") - найти позицию символа в строке  // 8
   strpos($string, "is", 4) - найти <...>, начиная с 4 позиции // 5
      if (strpos($string, "T") == false) echo "T не найдено";
      else echo "T найдено";  // true, потому что [0] = null = false
      // нужно строгое равенство ===
   substr($string, 3);        // s is example
   substr($string, 3, 7);     // s is ex
   substr($string, 3, -2);    // s is exampl
   str_replace("is", "abc", $string);   // Thabc abc example!
   str_replace(["is", "ple"], ["abc", "123"], $string);     // Thabc abc exam123!

ПРОВЕРКА ОТПРАВЛЕННЫХ ПОЛЬЗОВАТЕЛЕМ ДАННЫХ
   htmlspecialchars() - преобразует спец. символы в HTML-сущности: '<' в '&lt;'
   // принимая данные от юзера, всегда применяем к ним эту функцию
   strtolower() - приведение к нижнему регистру
   strtoupper() - приведение к ВЕРХНЕМУ регистру
   trim("   delete spaces   ") - удаляет пробелы по краям

ФУНКЦИИ ДЛЯ РАБОТЫ С МАССИВАМИ
$array = [12, 17, 5, 23, 56];
   count($array) - считает кол-во элементов  // 5
   sort() - сортировка по возрастанию
   rsort() - сортировка по убыванию
   asort()
   arsort()
   alist()
   ksort() - сортировка по ключам ASC
   krsort() - сортировка по ключам DESC
   shuffle($array) - перемешать элементы в массиве
   in_array(10, $array); - проверяет наличие элемента в массиве
   array_merge($arr_1, $arr_2) - объединяет массивы, все элементы сохраняются
** $array = [1, 2, 3, 4, 5, 6, 7];
   array_slice($array, 1,)       // 2 3 4 5 6 7
   array_slice($array, 1, 2)     // 2 3
   array_slice($array, 1, -2)    // 2 3 4 5

САМЫЕ ЧАСТОИСПОЛЬЗУЕМЫЕ
   count()
   sort()
   unset($array[0]);

ФУНКЦИИ ДАТЫ
   time()
   microtime(true)
      $start = microtime(true);
      echo "Прошло: ".(microtime(true) - $start)." секунд";
   date("Y-M-D H:I:S");
   getdate();


==================================================================================
ФУНКЦИИ ДЛЯ РАБОТЫ С МАССИВАМИ
==================================================================================
array_change_key_case -- Возвращает массив, символьные ключи которого преобразованы в верхний или нижний регистр символов
array_chunk -- Разбить массив на части
array_combine --  Создать новый массив, используя один массив в качестве ключей, а другой в качестве соответствующих значений
array_count_values -- Подсчитать количество всех значений массива
array_diff_assoc -- Вычислить расхождение в массивах с дополнительной проверкой индекса
array_diff_key -- Вычислить расхождение в массивах, сравнивая ключи
array_diff_uassoc --  Вычислить расхождение в массивах с дополнительной проверкой индекса, осуществляемой при помощи функции, определённой пользователем
array_diff_ukey -- Вычислить расхождение в массивах, используя функцию обратного вызова для сравнения ключей
array_diff -- Вычислить расхождение в массивах
array_fill -- Заполнить массив определенным значением
array_filter --  Применяет фильтр к массиву, используя функцию обратного вызова
array_flip -- Поменять местами значения массива
array_intersect_assoc -- Вычислить схождение массивов с дополнительной проверкой индекса
array_intersect_key -- Вычислить пересечение массивов, сравнивая ключи
array_intersect_uassoc -- Вычислить пересечение массивов с дополнительной проверкой индекса, осуществляемой при помощи функции, определённой пользователем
array_intersect_ukey -- Вычислить пересечение массивов, используя функцию обратного вызова для сравнения ключей
array_intersect -- Вычислить схождение массивов
array_key_exists -- Проверить, присутствует ли в массиве указанный ключ или индекс
array_keys -- Выбрать все ключи массива
array_map --  Применить функцию обратного вызова ко всем элементам указанных массивов
array_merge_recursive -- Рекурсивно слить два или большее количество массивов
array_merge -- Слить два или большее количество массивов
array_multisort -- Сортировать несколько массивов или многомерные массивы
array_pad --  Увеличить размер массива до заданной величины
array_pop -- Извлечь последний элемент массива
array_product --  Вычислить произведение значений массива
array_push --  Добавить один или несколько элеметов в конец массива
array_rand --  Выбрать одно или несколько случайных значений из массива
array_reduce --  Итеративно уменьшить массив к единственному значению, используя функцию обратного вызова
array_reverse --  Возвращает массив с элементами в обратном порядке
array_search --  Осуществляет поиск данного значения в массиве и возвращает соответствующий ключ в случае удачи
array_shift --  Извлечь первый элемент массива
array_slice -- Выбрать срез массива
array_splice --  Удалить последовательность элементов массива и заменить её другой последовательностью
array_sum --  Вычислить сумму значений массива
array_udiff_assoc -- Вычислить расхождение в массивах с дополнительной проверкой индексов, используя для сравнения значений функцию обратного вызова
array_udiff_uassoc -- Вычислить расхождение в массивах с дополнительной проверкой индексов, используя для сравнения значений и индексов функцию обратного вызова
array_udiff -- Вычислить расхождение массивов, используя для сравнения функцию обратного вызова
array_uintersect_assoc -- Вычислить пересечение массивов с дополнительной проверкой индексов, используя для сравнения значений функцию обратного вызова
array_uintersect_uassoc -- Вычислить пересечение массивов с дополнительной проверкой индекса, используя для сравнения индексов и значений функцию обратного вызова
array_uintersect -- Вычислить пересечение массивов, используя для сравнения значений функцию обратного вызова
array_unique -- Убрать повторяющиеся значения из массива
array_unshift --  Добавить один или несколько элементов в начало массива
array_values -- Выбрать все значения массива
array_walk_recursive --  Рекурсивно применить пользовательскую функцию к каждому элементу массива
array_walk --  Применить пользовательскую функцию к каждому члену массива
array --  Создать массив
arsort --  Отсортировать массив в обратном порядке, сохраняя ключи
asort -- Отсортировать массив, сохраняя ключи
compact --  Создать массив, содержащий названия переменных и их значения
count -- Посчитать количество элементов массива или количество свойств объекта
current -- Возвратить текущий элемент массива
each --  Возвратить текущую пару ключ/значение из массива и сместить его указатель
end --  Установить внутренний указатель массива на его последний элемент
extract --  Импортировать переменные из массива в текущую символьную таблицу.
in_array -- Проверить, присутствует ли в массиве значение
key -- Выбрать ключ из ассоциативного массива
krsort -- Отсортировать массив по ключам в обратном порядке
ksort -- Отсортировать массив по ключам
list --  Присвоить переменным из списка значения подобно массиву
natcasesort --  Отсортировать массив, используя алгоритм "natural order" не принимая во внимание регистр символов
natsort --  Отсортировать массив, используя алгоритм "natural order"
next --  Передвинуть внутренний указатель массива на одну позицию вперёд
pos -- Alias of current()
prev -- Передвинуть внутренний указатель массива на одну позицию назад
range --  Создать массив, содержащий диапазон элементов
reset --  Установить внутренний указатель массива на его первый элемент
rsort -- Отсортировать массив в обратном порядке
shuffle -- Перемешать массив
sizeof -- Alias of count()
sort -- Отсортировать массив
uasort --  Отсортировать массив, используя пользовательскую функцию для сравнения элементов с сохранением ключей
uksort --  Отсортировать массив по ключам, используя пользовательскую функцию для сравнения ключей
usort --  Отсортировать массив по значениям используя пользовательскую функцию для сравнения элементов