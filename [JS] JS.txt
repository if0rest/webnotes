В этом примере из объекта document получено свойство createElement, которое является ссылкой на функцию. Эта функция вызвана с аргументом 'pre' в контексте объекта document.
	document.createElement('pre')

Метод - это свойство, являющееся ссылкой на функцию.

В JS только функции создают локальную область видимости.

Возьми за правило: переменная перед циклом!

Числовое значение = Числовой тип данных = Числовой литерал   |   Литерал = Примитив   |   Функция = объект   |   Объект-обертка = Функция-конструктор ("Функция, создающая новые объекты, называется конструктором")

Оператор new создает новый объект, используя функцию-конструктор, которая может быть как встроенной в javascript ( Date , String ) так и...

Операторы отношения - это <, >, <=, >=. Возвращают true или false.

NaN возвращается, когда мы делаем что-то, чего в обычной математике делать нельзя.

Если переменная содержит функцию, то var - тоже функция.

При обращении к несуществующим свойствам объекта получаем undefined.
У null и undefined нет объектов-оберток. Получим // TypeError

Для преобразования числа в логический литерал исп. такая запись:
	!!a	// true	!!0	// false
Числа в строку:
	(1 + "2")	// 12
	var.toString() - метод к переменной
	String() - функция-конструктор
Строки в число:
	var.parseInt("12")
	var.parseFloat("12.32")
	+"12"
____________________________________________________________________

О JAVASCRIPT

JS может проводить валидацию данных.

В JS все, что отделяется ";", называется инструкцией или statement. Инструкции могут писаться в одну строку.
----------------------------------------------------------------------------------------------------
Переменные (var) хранят в себе данные.
var x = 5; //можно без пробелов
var y=6;
var z;
z=x+y;
	или
var x=5, y=6, z; //обрати внимание на запятые
----------------------------------------------------------------------------------------------------
z = x + y	   //здесь "=" - это оператор присваивания
if(z == y)	   //здесь "=" - обычное равно (читается как "если z равно y")
{
условие
}
----------------------------------------------------------------------------------------------------
% (модус) ++ (инкремент) -- (дикремент)
если var 1 - число, а var 2 - строка текста, то происодит конкатенация, т.е. объединение значений в одну строку символов
Например,
var x=5, y="строка текста", z;
z=x+y		   Результат: 5строка текста
z=x+y+5	   Результат: 5строка текста5
Однако, если
var x=5, y=6, z;
z=x+y+"5"  Результат: 115 (где 11 - сумма, а 5 - "значение")
если
z=x-y-"5"   Результат: -6
----------------------------------------------------------------------------------------------------
var numberType = 56.01;   -   числовой тип данных
	var numberType = 56.01e3;	-  значит 56.01 * 10 в 3-й степени = 56010
	var numberType = 56.01e-3;	-  значит 56.01 * 10 в -3-й степени = 0.05601

var stringType = 'Компания "ООО Аксель"';   -   строковый тип данных

var arrayType = ['Владислав','Кирилл','Анна','Матвей'];   -   массив данных | [индексы или значения массива] | ['ключ, которому соответствует id']
	var arrayType = ['Влад','Ирина'];
	console.log(arrayType[0]);
	Получим: Влад	//потому что значения в массиве нумеруются с 0

var objectType = {key: value}; {ключ: значение}=свойство
	var objectType = {age: 14, sex: 'male', name: 'Владислав'};
	console.log(objectType.age);	// 14
	<!> В ключе значение мб любого типа: число, строка, еще 1 объект, массив данных и проч.

var booleanType = true/false;  //исп. для логич. кострукций: выполн./не выполн.

var nullType = null;   //условие будет | не будет выполняться

var undefinedType = undefined;
   if(nullType == undefinedType)	//"==" - нестрогое сравнение: сравнивает значение переменных, но не их тип данных
----------------------------------------------------------------------------------------------------
function имяФункции(параметр1, параметр2, etc);
document.getElementById('result').innerHTML = имяФункции(аргумент1, аргумент2, etc);

Параметры функции исп. при описании функции, аргументы - при вычислении.
----------------------------------------------------------------------------------------------------
var user;
user = {firstName: "Владислав"};		//если {}, то объект
console.log(user.lfirstName);		//обращаемся к свойству firstName объекта user
----------------------------------------------------------------------------------------------------
var user2, user3;
user2 = new Number(23);
user3 = new String("Возраст");

С помощью директивы/ключа new создаются объекты
----------------------------------------------------------------------------------------------------

Область видимости (Scope) - это совокупность переменных, объектов и функций, к которым мы имеем доступ в нашем скрипте и во время его исполнения. Она бывает глобальной и локальной.

function testFunction() {
            var testVar = 100;}
Читается так: внутри функции testFunction объявили переменную testVar со значением 100 (числовой тип данных)

<script>
var testVar2 = 200;         //глобальная переменная, ибо внутри скрипта
function testFunction() {
	var testVar = 100;      //определили локальную переменную внутри функции
	console.log(testVar2);  //сработает
}
console.log(testVar)	    //не сработает
</script>
К глобальной переменной можно обратиться из любого места скрипта, к локальной - только внутри функции. Если у локальной функции убрать директиву var, переменная станет глобальной (но это плохая практика).

function testFunction(parametr1, parametr2) - параметры функций ведут себя как локальные переменные, используются пределах данной функции
----------------------------------------------------------------------------------------------------
var v1 = "10+15";   //строковый примитив
var v2 = new String("10+15");   //объект, содержащий строковый тип данных
----------------------------------------------------------------------------------------------------
var ArrayString = v1.split('+');		//к переменной v1, содержащей строковый примитив, применяем метод split; '+' - это сепаратор
----------------------------------------------------------------------------------------------------
Строку можно превратить в массив.

____________________________________________________________________



JAVASCRIPT [SORAX]

API - набор функций для базового ввода-вывода. У JS его нет. Язык JS определяет функции для работы со строками, массивами, регулярными выражениями и т.д.

Инструкции в JS просто выполняются, тогда как выражения всегда возвращают какие-то значения. Когда интерпретатор видит выражение, он вычисляет его значение и заменяет выражение его значением. Например:
	выражение: 5+5	значение: 10
Выражения бывают простыми/первичными и сложными/составными. Простые (primitive) - те, что не включают в себя другие выражения: это идентификаторы, литералы и нек. ключевые слова.

Когда нам нужно сохранить какое-то значение, мы записываем его в переменную, и потом по имени  переменной мы можем получить ее значение. Для объявления переменной используется ключевое слово var, после кот. идет идентификатор, представляющий имя переменной. Инструкция с ключевым словом var называется "инструкцией объявления" (declaration statement).
Примеры инструкций объявления:
	var myVariable;
	var myVariable, myVariable2, myVariable3;
	var myVariable = 10, myVariable2 = 20, myVariable3 =30;	//инициализация переменных - присвоение первичных значений
После объявления и инициализации var, мы можем обращаться к ним откуда угодно.
id в JS могут начинаться с буквы, '_' и '$': var, _var, $var. Но не с цифры (напр, 5var). Это сделано, чтобы парсеру было проще различать id и числа.

Типы данных бывают примитивные и объектные.
// Примитивные типы
var myNumber = 777,				//числовой тип данных или числовой литерал
	 myString = "Some strings", //строковый
	 myBool = true,				//логический или булевый
	 myNull = null,					//означает отсутствие значения - нулевой литерал
	 myUndef = undefined;		//означает отсутствие значения - не литерал, но идентификатор
// Объектные типы
var obj = {name: "Sorax"},	//объекты
	 array = [1,2,3],				//массивы
	 regexp = /w+/g,			//регулярные выражения
	 func = function(){};		//функции
------------------------------------------
	console.log(typeof myNumber), где typeof - унарный оператор; вместо числа в консоли отобразится тип данных number
	console.log("Sorax".toUpperCase()), где toUpperCase - метод строкового литерала "Sorax"

Обрати внимание на имена var:
1) они начинаются с маленькой/строчной буквы;
2) используют нижний регистр (за исключением первой буквы каждого нового слова);		//верблюжья аннотация или CamelCase; такой стиль принят в JS

JS - язык динамической типизации. Это означает, что тип переменной автоматически определяется интерпретатором в зависимости от присвоенного значения, в связи с чем переменные в js не имеют типа.
Типы в JS можно разделить на ИЗМЕНЯЕМЫЕ(mutable) и НЕИЗМЕНЯЕМЫЕ(immutable). Все простые типы данных - неизменяемые. Например, измением свойство name объекта (var obj).
	var obj = {"Sorax"};
	obj.name = "Vladimir";
	console.log(obj.name);						//в консоли вместо Sorax получим Vladimir
	console.log(myString.toUpperCase());		//применяя метод toUpperCase, изменим консольное отображение, но не само значение
____________________________________________________________________

ОПЕРАТОР ПРИСВАИВАНИЯ

ОП - это оператор с побочным эффектом, а именно - запись в переменную к-либо значения.
	var a, b, c, d;
	a = b = c = d = 5;		//парсер обрабатывает слева-направо, но значение переменных в данном случае вычисляется справа-налево. Видится так:
	a = {b = c = d = 5}, но каково значение выражения в скобках? Идет последовательное вычисление, пока переменная "не упрется" в числовое значение. Итоговый вывод: если d=5, тогда с=5, тогда b=5, а значит a=5.
-----
Объекты обертки для простых типов (wrapper objects) предоставляют более широкие возможности при работе с этими типами. Чтобы создать такой объект, используем конструктор Number. Конструктор - это функция, кот. создает новые объекты; ее принято писать с большой буквы.

	var N = new Number(4000);
	console.log(typeof N);			//выдаст object
	var n = 5000;
	console.log(typeof n);			//выдаст number

Оператор new создает новый объект, используя функцию-конструктор.
-----

Чтобы закрепить:
	console.log(var1.toExponential(8));	//toExponential() - это метод, в конце идут () со значением
____________________________________________________________________

АРИФМЕТИЧЕСКИЕ ОПЕРАТОРЫ

Есть унарные операторы присваивания: + и -
	console.log(+10);		//исп. редко
	console.log(-10);		//исп. часто
а также ++ (инкремент) и -- (дикремент). Как и операторы присваивания, имеют побочный эффект, т.к. изменяют переменную, увелич. или уменьш. значение на 1.
	console.log(++i);		//в данном выражении оператор инкремента стоит до переменной (префиксный): он сначала > знач. на 1, потом возвращ. исходное знач. var
	console.log(i++);		//постфиксный
Пример применения:
	var i = 10;
	console.log(i++);		//10	отобразит 10, хотя в буфере уже 11
	console.log(i);		//11	проверяем текущее значение - 11
	console.log(++i);		//12	сразу 1+11 и сразу видим результат
	console.log(i);		//12

Есть бинарные операторы:
	console.log(5 + 10);		//получим 15
	console.log(7 - 3);		//4
	console.log(5 * 9);		//45
	console.log(10 / 3);		//3,333333333333333
	console.log(10 % 3);		//1	- остаток от полного деления 10 на 3 (10/3=9+1)

Присваивание с операций:
	var n = 100;
	n = n + 20;	или лучше	n += 20;
	console.log(n);	//120

Операторы отношений:
	console.log(5 > 10);		//false
	console.log(5 < 10);		//true
	console.log(10 >= 10);	//true
	console.log(8 <= 10);	//true
	console.log(8 >= 10);	//false

Сравнение на равенство/неравенство:
	console.log(10 === 10);		//true
	console.log(10 !== 10);		//false
	console.log(10 == "10");	//true	(сравнивает только значения var)
	console.log(10 === "10");	//false	(срав. знач+проверяет, чтобы var были 1 типа)	//не желательно использовать
Записывается именно 3 символам, т.к. "=" - занят под оператор присваивания, а "==" - сравнение с применением типов(мб только значений?).

Объект Math предоставляет методы для более сложных ариф. операций:
	console.log(Math.sqrt(25));		//5		корень квадратный
	console.log(Math.pow(3.5));		//243	возведение в степень
	console.log(Math.PI);			//константа - число Пи

NaN - Not A Number

	console.log("Hello there");			//Hello there
	console.log("Hello there".length);	//11

Управляющая последовательность для переноса строк (\n), табуляции (\t) и кавычек внутри строки (\")
	console.log("Another very long string");	//в одну строку
	console.log("Another \
	very long\
	string");	//все равно в 1 строку 	//после \ не должно быть символов или пробела
	console.log("Another \nvery long \nstring");		//в 3 строки
	console.log("Another \n\tvery \"long\" \n\t\tstring");	//с переносом, табуляцией и кавычками

	var string = "Hello";
	console.log(string + "there");	//Hello there		//происходит конкатенация

	var string = "Sometimes the same is different";
	console.log(string.charAt(0));	//S		метод charAt() возвращает символ, кот. стоит под опр. индексом

<!> Строка - это неизменяемый тип данных, поэтому методы никак не изменяют исходную строку, просто возвращают новую.

if {...} - условная инструкция if.

____________________________________________________________________

ЛОГИЧЕСКИЕ ОПЕРАТОРЫ

Оператор логического И записывается с помощью двух амперсантов (&&) и возращает истину только, когда оба его операнта истинны.
	console.log(true && false);	//false
	console.log(true && true);	//true
Логическое ИЛИ записывается с помощью 2 вертикальных линий ( || ). Возвращает истину, если хотя бы 1 из оперантов true.
	console.log(true || false);		//true
	console.log(false || false);		//false
Оператор логического отрицания (!). Если истина, то false, и наоборот.
	console.log(!true);		//false
	console.log(!false);		//true

var someString = "Non-empty string";
var newString = someString || "Default String";
console.log(newString);			//Non-empty string
В этом примере присваиваем переменной newString значение переменной someString в том случае, если значение последней истинно. И это так, поскольку строка не пуста. В правой же части логического ИЛИ можем прописать стандартное значение, кот. будет присвоено newString в том случае, если левый оперант логического ИЛИ принимает ложное значение.

____________________________________________________________________

ОПЕРАТОРЫ NULL И UNDEFINED

null - если значение 0. undefined - если значение не мб опеределено.
console.log(typeof null)				//object (баг js)
console.log(typeof undefined)		//undefined (вроде как идентификатор)

Несколько ситуаций, когда можно встретить undefined:
1) значение неинициализированной переменной:
	var temp;
	console.log(temp);		//undefined
2) если обратиться к несуществующему свойству объекта:
	var obj = {};
	console.log(obj.property);		//undefined
3) обращение к несуществующему элементу массива:
	var a = [1,2,3,4];
	console.log(a[4]);		//undefined
4) с некоторыми функциями:
	function greet(name) {
		return "Hello" + name;}
	console.log(greet("Sorax"))		//Hello Sorax
Функция конкатенирует строку Hello со строкой, кот. передали в качестве аргумента ("Sorax"). Если вызовем эту функцию без аргументов, то увидим:
	console.log(greet());		//Hello undefined
Т.е. когда мы не передаем в функцию к-то параметры, значение этих параметров будет undefined.
5) Если функция не возвращает никакое значение, то будет undefined.

Еще пару слов.
При сравнении на равенство с приведением типов null и undefined равны.
	console.log(null == undefined); 	//true
При обычном сравнении на равенство - не равны, т.к. имеют разные типы.
	console.log(null === undefined); 	//false


В своих скриптах вы будете использовать только операторы строгого сравнения (===). Есть также оператор нестрогого сравнения без приведения типов (==).
Оператор == сравнивает на равенство, а === - на идентичность. Плюс оператора === состоит в том, что он не приводит два значения к одному типу.

"Автоматическое" преобразование типов - не единственный способ преобразования. Для "явного" преобразования следует исп. конструкторы соотв. типов.
Например, с помощью конструктора Number можно перевести любое значение в числовой тип.
console.log(Number("555"));			//555
console.log(typeof(Number("555")));	//number , хотя у нас строка
console.log(String(4433));				//4433
console.log(typeof(String(4433)));		//string
console.log(Boolean(1));					//true
console.log(typeof(Boolean(1)));		//boolean
---------
console.log(!!5);							//true		!! - оператор логического отрицания. Одного его достаточно, чтобы перевести значение в лог. тип.
console.log(!!0);							//false		С ! мы получим инвертированное значение, поэтому !!
---------

Быстро преобразуем значение в строку:
	console.log(345 + "");			//345	//string
Преобразуем значение в число, используя унарный оператор +:
	console.log(+"454");				//345
	console.log(typeof +"454");		//number
Еще один способ преобразования числа в строку - метод toString():
	var number = 22;
	console.log(number.toString());
Для преобразования строки в число также есть 2 глобальные функции: parseInt и parseFloat. При исп. этих функций, помимо цифр, строка может содержать любые символы, которые будут игнорироваться.
	console.log(parseInt("45 px"));			//45	преобразует в цельночисленное значение
	console.log(parseFloat("12.45 em"));	//12.45	то же, что parseInt + парсит вещественные числа
Преобразование в строки Infinity и NaN:
	console.log(typeof (String(Infinity)));	//Infinity	//string
	console.log(typeof (String(NaN)));		//NaN		//string
Пустая строка при преобразовании в число становится 0:
	console.log(+"");		//0		//type number
При преобраз. любого значения в булевый тип, всегда получаем false (есть исключения):
	console.log(!!"");				//false					//Любые значения,
	console.log(!!NaN);			//false					//кроме этих 5,
	console.log(!!0);				//false					//при преобразовании
	console.log(!!null);			//false					//в логич. тип
	console.log(!!undefined);	//false					//дадут истину.
	console.log(!!"Hi");		//true
Когда преобразуете строку в число, перед числом в строке мб любое кол-во пустых символов, кот. будут просто проигнорированы, но не должно быть др. символов:
	console.log(+"     4"); 	//4
	console.log(+"   e  4"); 	//NaN
	console.log(+" 4   f"); 	//NaN
Если в строке до/после числа есть к-то символы, и строку надо преобраз. в число, исп. функцию parseInt или parseFloat:
	console.log(parseInt(" 4   f")); 	//4
Булевые значения также можно преобразовывать в числа и получить 0 или 1.
	console.log(+true);		//1
	console.log(+false);		//0


null и undefined не равны ни каким значениям, кроме null и undefined.

Операторы/сравнение возвращают значение.

console.log(String('\"4433\"'));				//"4433"
console.log(typeof(String('\"4433\"')));	//string

В языке JS есть автоматическая конвертация типов, что означает: если оператор ожидает увидеть в к-то месте программы значение опр. типа, то любое значение будет автоматически приведено к этому типу. Например, если 1 из оперантов оператора "+" является строка, то другой оперант также преобразуется в строку.

____________________________________________________________________

УСЛОВНЫЕ ИНСТРУКЦИИ

Благодаря if можно выполнить к-то инструкцию только в случае истинности опр. выражения. Она имеет следующий синтаксис:
	if (выражение) инструкция {составная инструкция}
Если выражение в скобках истинно, то инструкция выполняется.
	if (true) console.log("It's true");		//It's true
	if (false) console.log("It's false");	//инструкция просто не исполнится
В скобках мб абсолютно любое выражение, оно будет автоматически приведено к булевому типу. Часто можно увидеть выражения с операторами сравнения:
	var n = 5;
	if (n > 3) {
		n *= 3;
		console.log(n);}
-------------------------
	if (n < 3) {
		console.log(n);
		console.log("Hello");
	} else if (n > 4) {
		console.log("n is more that 4");}
Когда пишешь if, хорошей привычкой считается использовать блок инструкций {}, даже если он не содержит инструкций.
Пример использования else if:
	var name = "Sorax", homecity;
	if (name === "John") {
		homecity = "Boston";
	} else if (name === "Sorax") {
		homecity = "Belgorod";
	} else if (name === "Bill") {
		homecity = "LA";}
	console.log(homecity);
------------------------------------------------------------------
Есть аналогичная, но более удобная инструкция switch. Парсер будет по порядку сравнивать значение выражения в скобках с каждым из значений выражений, кот. идут после ключевого слова case. Дойдя до искомого выражения, будет выполнена соотв. инструкция и (ВАЖНО !) все остальные инструкции, стоящие ниже и помеченные меткой case. Если значение ни одного из выражений не подошло, выполнится инструкция с меткой default.
	switch(выражение2) {
		case выражение1: инструкции1
		case выражение2: инструкции2
		case выражение3: инструкции3
		default: инструкции}			//выполнится, если ни 1 из выражений не подошло
--------------------------------
	var name = "Sorax", homecity;
	switch (name) {
		case "John": homecity = "Boston";
		case "Sorax": homecity = "Belgorod";
		case "Bill": homecity = "LA";}
	console.log(homecity)	//LA 	wtf?
Чтобы получить верное значение, в конце каждой инструкции исп. инструкцию break.
	var name = "Sorax", homecity;
	switch (name) {
		case "John": homecity = "Boston"; break;
		case "Sorax": homecity = "Belgorod"; break;
		case "Bill": homecity = "LA";
		default: homecity = "Moscow";}
	console.log(homecity)	//Belgorod	FuckYeah!
break - это инструкция мгновенного выхода из цикла или инструкция switch. Благодаря ей все инструкции ниже выполняться не будут.

____________________________________________________________________

УСЛОВНЫЙ ОПЕРАТОР

Это единственный тернарный (имеющий 3 операнда) оператор в языке, поэтому его часто называют тернарным, а не условным. Имеет следующий синтаксис:
	условие ? выражение2 : выражение3
Выражение1 преобразуется к логическому типу. Если оно возвращает true, условный оператор возвращает значение выражения2, если false - значение выражения3.
	var x =10;
	var text = x > 10 ? "x больше 10" : x < 10 ? "х меньше 10" : "x равен 10";
	console.log(text);		//х равен 10
С условной инструкций это выглядело бы так:
	if (x > 10) {
		text = "х больше 10";
	} else if (x < 10) {
		text = "х меньше 10";
	} else {text = "x равен 10"}
	console.log(text); 	//х равен 10
Как видим, используя условный оператор получаем более компактный синтаксис. И если усл. функцию можно заменить на усл. оператор - лучше это сделать.

ПОКАЗАТЕЛЬНЫЙ ПРИМЕР

Пример 1.1
	var x = prompt("Введите значение до 10",0);
	var test = x===null || x==0? "Вы ничего не ввели" : x < 10 ? "Спасибо, что не бот" : x > 10 ? "Внимательней ознакомьтесь с условием" : "x равен 10";
Пример 1.2
	var x = prompt("Введите значение до 10",0);
	if(x === null || x == 0) {
		var test = "Вы ничего не ввели";
	} else if (x < 10) {
		var test = "Спасибо, что не бот";
	} else if (x > 10) {
		var test = "Внимательней ознакомьтесь с условием";
	} else {
		var test = "x равен 10";
	};
	alert(test);

<!> Если условную инструкцию if...else можно заменить на условный оператор '? : :' - ДЕЛАЙТЕ.

____________________________________________________________________

ОПЕРАТОР ЗАПЯТАЯ

"," является бинарным оператором и имеет такой синтаксис:
	выражение, выражение
Оператор сначала вычисляет значение левого операнда, затем правого, и ВОЗВРАЩАЕТ в итоге ЗНАЧЕНИЕ ПРАВОГО ОПЕРАНДА.
	var test = (15,20);
	console.log(test);					//20
	console.log(test, "Hello");		//20 "Hello"
	console.log((test, "Hello"));		//Hello	потому что правый операнд

____________________________________________________________________

ЦИКЛЫ

Циклы - это вид инструкций, нужны для многократного повторения отдельных  инструкций в скриптах. Их 4 вида.
1)	for (выражение; выражение; выражение) инструкция
	for (инициализация; условие; инкремент) тело цикла
		инициализация - присваивание переменным начального значения
		тест - условие; если оно true, то тело цикла выполняется, если false - нет
		инкремент/декремент - обновляет значение счетчика
		тело цикла - как правило, явл. составной инструкцией, но мб обычной и даже пустой. Однократное выполнение цикла - одна итерация, 2-кратное - 2 итерации.
Т.о. мы инициализируем счетчик, проверяем и обновляем его значение.
Любое из 3 выражений можно пропустить. То же самое с телом цикла. Однако ; должны стоять все.
	for(; ;);  	//бесконечный цикл, кот. ничего не делает
	for(; ;)console.log("hi");		//hi	беск. цикл, кот. повесит браузер

<!> В JS циклы, условные и блочные инструкции не создают отдельной области видимости. Только функции.

----------------------------------------------
Инициализация выполняется 1 раз в начале, условие проверяется на каждой итерации перед выполнением тела цикла и инкремент выполняется на каждой итерации после выполнения тела цикла.
	var i;
	for(i = 0; i < 10; i++) {console.log(i);}		//0 1 2 3 4 5 6 7 8 9
	console.log(i); 	//10
Обратный счет:
	for(i = 10; i > 0; i--) {console.log(i);}		//10 9 8 7 6 5 4 3 2 1
	console.log(i); 	//0
Поскольку 0 при преобразовании в лог. тип возвращает false, можно выкинуть инкремент и записать условие так:
	for (i = 10; i--;) {console.log(i);}		//9 8 7 6 5 4 3 2 1 0		//часто нас не волнует значение i, нам важно кол-во итераций

<!> В цикле неважно постфиксный или префиксный инкремент/декремент, значения будут одинаковыми.

----------------------------------------------
Есть вариант с циклом while:
	var i = 0;
	while (i < 10) {console.log(i++);}	//0 1 2 3 4 5 6 7 8 9
	Однако. Если мы можем двигаться к 0, лучше к 0. Т.е.:
	var i = 10;
	while (i > 0) {console.log(i--);}		//10 9 8 7 6 5 4 3 2 1
	-- or --
	while (i--) {console.log(i);}			//9 8 7 6 5 4 3 2 1 0
При написании циклов важно помнить, что условие проверяется на каждой итерации. Т.е. если итераций 100 000, то (значение выражения) будет вычисляться 100 тыс раз, поэтому, чем проще выражение, тем быстрее будет работать скрипт.
----------------------------------------------
Еще есть цикл do..while. Его отличие - условие проверяется после тела цикла.
	do инструкция while (выражение)
Т.о. мы можем убедиться, что тело цикла будет выполнено хотя бы 1 раз независимо от истинности выражения.
	var i = 0;
	do console.log(i++); while (i < 3)		//0 1 2

____________________________________________________________________

ФУНКЦИИ

function - это к-то кол-во инструкций (проще говоря, кусок кода), кот. определяется 1 раз и потом мб вызван неограниченное кол-во раз.
Аргументы - это переменные, кот. мы передаем в нашу функцию. Внутри функции мы может с ними что-то делать, а после вернуть к-то значение (для этого предусмотрено ключевое слово return).
	function идентификатор(аргументы/переменные) {
		инструкции
		return выражение}				//возвращение значения
	идентификатор(аргументы);		//вызов функции
Пример:
	function greet(name) {
	return "Hello " + name}
	greet("Sorax");					//не увидим результат, т.к. интерпретатор сразу забывает значение выражения
	console.log(greet("Sorax"));		//Hello Sorax
Поскольку функция возвращает строку, можем сразу вызывать к-нибудь методы объекта string:
	console.log(greet("Sorax").toUpperCase());		//HELLO SORAX

Инструкция объявления функции - все, что начинается с function и кончается }.

Точка вызова функции - строка в коде, вызывающая функция и передающая аргументы.

---------------------------------------------------------------------
function func(name, surname) {
	return "Имя: " + name +"\n"+ "Фамилия: " + surname;}
console.log(func("Владимир", "Хапров"));
Вернет:
	// Имя: Владимир
	// Фамилия: Хапров
---------------------------------------------------------------------

Функцию также можно определить, если присвоить к-то переменной выражение определения функции:
	var greet = function(name) {		//имя функции можно пропустить (анонимная ф-ция)
	return "Hello " + name};
	console.log(greet("Sorax"));		//Hello Sorax
	console.log(greet());				//Hello undefined , ибо аргумент неинициализирован

"Выражение определения функции" и "Инструкция объявления функции" - это разные вещи, и интерпретатор понимает их по-разному.

"Поскольку функции в JS являются объектами, мне больше нравиться объявлять их таким образом:
	var greet = function(name) { return "Hello " + name; };
поскольку такое объявление лучше отражает суть происходящего."


Чтобы получить все переданные аргументы внутри функции мы можем исп. объект arguments. Этот объект ведет себя и выводится в консоль как массив, поэтому мы можем обращаться к опр. аргументам при помощи индексов.
	var greet = function(name) {
	console.log(arguments);				//["Sorax", 34, 23, 26]
	console.log(arguments[2]);			//23	//в массиве счет индексов с 0
	return "Hello " + name}
	console.log(greet("Sorax", 34, 23, 26));
У объекта arguments есть неск. полезных свойств:
	console.log(arguments.length)		//4		//вернет кол-во аргументов


Поскольку функции в JS являются объектами, мы можем передавать функции в функции в качестве аргументов, а также возвращать функции из функций.
Передача функции в качестве аргументов может использоваться для реализации т.н. callback'ов. Т.е. для передачи функции, кот. будет выполнена после выполнения функции, в кот. она передается.
	var func = function() {
	return function() {
	console.log("Hi");}
	};
	func()()		//Hi

Функция мб вызвана сразу после определения в том случае, если мы исп. выражение определения. После этого ВО мы можем прописать круглые скобки с аргументами и т.о. получим выражение вызова.
	var greeting = function(name) {		//присваиваем не функцию, а значение ф.
		return "Hello " + name;
	}("Sorax");		// выражение вызова
	console.log(greeting);		//Hello Sorax
Если в этой функции будет много инструкций, то, посмотрев на первую строчку, можно будет подумать, что мы присваиваем переменной функцию, хотя на самом деле мы присваиваем ей значение функции. Для большей ясности выражение вызова берут в ( ):
	var greeting = (function(name) {	// скобка тут
		return "Hello " + name;
	} ("Sorax")); 	// и тут
	console.log(greeting);

Ф, кот. вызывается сразу после определения, называется "анонимной самовызывающейся функцией". Разумеется, она мб неанонимной: можно дать ей имя после ключевого слова function, но смысла в этом нет.

____________________________________________________________________

ОБЛАСТЬ ВИДИМОСТИ И ЦЕПОЧКИ (scope, scope chain)

Область видимости переменной (scope) - это часть программы, где эта var опр. и доступна. Переменные по scope делятся на глобальные и локальные. Глобальные - вне к-либо функций, локальные - внутри. Локальная имеет > приоритет.
	var i = 5;
	var func = function() {
		var i = 10;
		console.log(i);}
	func();				//10	//одноименная локальная var имеет > приоритет
В JS только функции создают локальную область видимости.


----------------------------------------------------------------------------------------------
Функции в JS мб вложенными:
	var i = 5;
	var func = function() {
		var i = 10;
		console.log(i);	// 10
		var innerFunc = function() {	// вложенная функция
			var i = 15;			// вложенная Ф переопределяет var
			console.log(i); };	// 15
		innerFunc(); };		// вызов вложенной функции
	func();			// 10  15  (с красных строк)

Вложенные функции создают цепочки областей видимости. Когда обращаемся к var i, интерпретатор первым делом проверяет первую область видимости в цепочке:
	var innerFunc = function() {
		var i = 15;
		console.log(i); };
Если в этой функции не окажется var i, то интерпретатор попытается найти var в следующей области видимости цепочки, т.е. в функции funk:
	var func = function() {
		var i = 10;
		console.log(i);};
----------------------------------------------------------------------------------------------
А что, если обратиться к var до ее объявления? Логично, что интерпретатор увидит обращение к необъяленной var	i и возьмет значение из внешней функции. Но в JS интерпретатор заранее знает об объявлении всех var внутри функции, поэтому при выполнении скрипта в консоль выведется undefined.
Такое поведенеи назвали 'подъем', потому что интерпретатор поднимает все объявления о var в начало функции. Т.е. он заранее знает о существовании всех переменных, хотя может не знать их значений. И если обратиться к еще неинициализированной, но объявленной var, вернется undefined:
	var i;
	console.log(i);	// undefined
	i = 15;
Т.о. в начало поднимается только объявление о var без инициализации.

* Продолжение в конце "Javascript-джедай #14 - Цепочки областей видимости"

____________________________________________________________________

ЗАМЫКАНИЕ

При выполнении ф. исп. та область видимости переменных (scope), кот. существовала при объявлении этой ф. Это назыв. 'лексической областью видимости'.

"Присвоим переменной функцию ..."

С каждой функцией связана цепочка областей видимости переменных, и функция вместе с этой цепочкой называется замыканием. Поэтому, строго говоря, каждую ф. можно назвать замыканием.
Это возможно благодаря тому, что когда интепретатор выполняет к-либо функцию, например, нашу первую Ф, он создает объект, кот. будет содержать все локальные var для этого вызова Ф. В частности, var i.
	var func = function() {
		var i = 10;
		return function() {	// возвращаемая функция
			return i;
		}
	}
И любые Ф, кот. мы опр. внутри функции func, например наша возвращаемая Ф, сохраняют ссылку на этот объект с локальными var. И этот объект сущ. только в случае, если есть Ф, кот. на него ссылаются. Если бы в Ф func не было бы никаких вложенных Ф, то не было бы способа получить доступ к var i, и у интерпретатора не было бы повода хранить эту var после выполнения Ф. Поэтому объект, содержащий эту var, был бы уничтожен сразу после выполнения Ф.

Напишем простой счетчик:
	var counter = (function(){	// var counter присваивается фукция, кот. возвра-
		var count = 0;
		return function(){		// щается из анонимной self-calling функции
			return count++;}		// возвращ. знач. var count, увелич. на 1
	}());		//замыкание удобно создавать при помощи анонимных самовызывающихся функций (self-calling function)
	console.log(counter());		//0
	console.log(counter());		//1
	console.log(counter());		//2 и т.д.
Т.о. довольно просто создали Ф, кот. не принимает никаких аргументов и при этом возвращает разные значения при разных вызовах. В этом заключается вся прелесть замыканий: они позволяют исп. Ф не просто как подпрограммы, они позволяют сделать Ф немного более умными благодаря, как в нашем примере, возможности сохранения к-то данных. Замыкание позволяет реализовать что-то вроде инкапсуляции данных.
В нашем примере мы можем получить или изменить var count только при помощи вложенных Ф, поэтому var count условно можно считать приватной.

Как правильно читать:
	var counter = function(num) {	 // Ф. будет принимать к-то число num
		var count = 0;
		return function() {
			count = num !== undefined ? num : count;
			// если аргумент был передан, т.е. num !== undefined, мы присваиваем счетчику это число, иначе значение остается тем же
			return count++;
		}
	}());
* Продолжение в "Javascript-джедай #15 - Замыкания"

____________________________________________________________________

ОБРАБОТКА ИСКЛЮЧЕНИЙ

Возможны ситуации, когда вы не можете знать точно, какие данные получите. В таких случаях вам нужно иметь возможнось генерировать и обрабатывать исключения.
С точки зрения интерпретатора, сам код, кот. мы пишем, является внешними данными, и по отношению к интепретатору JS можно сказать, что мы являемся пользователями, поскольку исп. его возможности для выполнения скриптов, кот. мы пишем.

Если переменная содержит функцию, то var - тоже функция.

	var myError = new Error("My Error Message");
	console.log(myError.name);		// Error
	console.log(myError.message);	// My Error Message

Допустим, у нас есть функция calculate, кот. принимает n и по какой-то причине мы ожидаем получить n не больше 10. Если получаем n > 10, то мы не хотим выполнять дальше функцию и кидаем исключение. Если с n все норм то возвращаем то-то.
	var anotherFunc = fucntion(n) {
		if (n > 10) throw new Error("n should be less than 10");
		return n + 10;
	}
Конечно, кидать исключения следует в крайнем случае, когда на правильности данных держится весь смысл выполнения вашего скрипта. В большинстве случаев можно обойтись без исключений.

throw - это инструкция.

КАК ОБРАБАТЫВАТЬ ИСКЛЮЧЕНИЯ

Для этого есть инструкция try/catch/finally. Она имеет такой синтаксис.
<!> { } - часть инструкции, а не часть блочных инструкций. Обязательны!
	try {
		инструкции	// кот. могут бросить исключения
	} catch (идентификатор) {	// обычно id 'error' или 'e'
		инструкции	// ловим это исключение
	} finally {
		инструкции
	}
Блок catch и finally могут отсутствовать, но не одновременно.
В блок try помещаем инструкции, кот. могут бросить исключение. В блоке catch мы ловим это исключение, т.е. туда мы помещаем инструкции, кот. будут выполняться, если в блоке try произошло к-то исключение. При этом в него передается выражение, кот. было в инструкции throw и для него в скобка мы можем прописать любое понравившееся имя. В блок finally мы помещаем инструкции, кот. будут выполняться независимо от того, произошли к-то исключения в блоке try или нет.

____________________________________________________________________

ОБЪЕКТЫ

С объектами в JS связано очень много.

'Объектом' называется набор свойств, который представляют собой пару имя-значение.
	{ имя: значение, имя: значение }

Свойство объекта = поле объекта.

Для обращения к полям obj исп. 'выражение обращения' или 'выражение доступа'. У них 2 синтаксиса:
	выражение.идентификатор
	выражение[выражение]
У них есть отличия. Благодаря [] мы можем подставлять любое выражение, мы можем формировать это имя-свойство динамически.
	console.log(person["age"]);
Идентификатор же дб прописан в коде программы, иначе никак.
	console.log(person.age);

Значением любого свойства мб функция, и этом случае такое свойство называют методом.
Поскольку в JS функции явл. obj, понятие 'метод' является исловным. Технически в JS нет разницы между обычными свойствами и методами. Возможно, правильней будет сказать, что в JS нет методов, мы просто делаем функции значениями к-то свойств.

Еще 1 способ создания obj - при помощи функции-конструктора и оператора new.

Другой способ - метод create() класса Object. Он принимает первым параметром объект, кот. будет явл. прототипом первого объекта.
	var object = Object.create({x: 10, y: 20});	// x и y - наследованные свойства obj
	console.log(object);
	console.log(object.hasOwnProperty("x")); 	// false, потому что наследованные
	object.x = 20;		// родное свойство
	console.log(object.hasOwnProperty("x")); 	// true
В консоли мы увидим свойства объекта, но, на самом деле, это свойства, наследованные от прототипа. Это можно проверить с помощью: console.log( object.hasOwnProperty("x") ).
	var object = Object.create(null);	// null , если не хотим передачи свойств


ИТОГО ЕСТЬ 3 СПОСОБА СОЗДАНИЯ ОБЪЕКТА:
	(1) var object = { property: value };						// обычный
	(2)	var object = new Object( property: value );		// через функцию-конструктор
	(3) var object = Object.create({ property: value });	// через метод create() прототип


ДОБАВИТЬ И УДАЛИТЬ СВОЙСТВО ОБЪЕКТА:
	object.x = 10;
	delete object.x;
Для удаления сущ. оператор delete. Оператором delete можно удалить только неродные свойства объекта. Наследованные можно удалить только напрямую у самого прототипа.

Для проверки наличия свойства у объекта есть бинарный оператор in.
	console.log("property" in object);
Оператору in по барабану, наследованное свойство или родное. Если оно есть, вернет true.

____________________________________________________________________

this И НЕПРЯМОЙ ВЫЗОВ МЕТОДОВ

	var person = {
		name: 'Sorax',
		greet: function(){
			return 'Hello, ' + person.name + '!';	// person на this
		}
	};
	console.log(person.greet());		// Hello, Sorax!

В этом примере мы берем только 1 свойство объекта и только 1 раз, но в реальности обращений мб много. Если в этом случае потребовалось изменить имя объекта, пришлось бы изменять его во всез обращениях. Что еще более важно, у объекта может не быть имени. Поэтому для обращения к текущему объекту, внутри кот. вы опр. метод, есть ключевое слово this. Если в примере выше изменить person на this, все будет работать.
Поскольку функции в JS явл. объектами, мы можем объявить эту функцию где угодно, а внутри нашего объекта просто вставить на нее ссылку:
	var greet = function() {
		return "Hi! My name is " + this.name + "."; }
	var person = {
		name: 'Sorax',
		greet: greet };
	console.log(person.greet());	// Hi! My name is Sorax.

Мы можем создать еще 1 объект со своими свойствами, но с тем же методом greet, и получить новый результат.
	var anotherPerson = {
		name: 'Somebody',
		greet: greet };
	console.log(person.greet());	// Hi! My name is Somebody.

Т.о., 1 и та же функция, будучи вызвана как метод разных объектов, возвращает разные строки, поскольку при разных вызовах this указывает на разные объекты. Если вызвать функцию напрямую, то this укажет на глобальный объект:
	console.log(greet());	// Hi! My name is [object Window].

ПРО МЕТОДЫ apply и call смотри в одноименном видео.

____________________________________________________________________

АКСЕССОРЫ И АТРИБУТЫ СВОЙСТВ

Для аксессоров в объектном литерале предусмотрен спец. синтаксис.
	var person = {
		get age() {},
		set  age() {}
	};
Функции get и set называют соответственно 'гетером' и 'сетером'. Эта пара функций в нашем случае заменит обычное свойство age. Когда мы обратимся к свойству age, будет вызвана функция get, когда мы попытаемся изменить ее значение, будет вызвана функция set.

	var person = {
		name: "Sorax",
		get age(){
			return "Hello from getter!";
		},
	//	set age(){}
	};
	console.log(person.age);		// Hello from getter!

Сеттер принимает значение и внутри него мы можем что угодно делать с этим значением, нарпимер присвоить к-то свойству нашего объекта. Для хранения возраста нужно создать еще одно свойство, и оно не может иметь то же самое имя, что аксессор, поэтому _age.
	var person = {
		name: "Sorax",
		_age: 20,
		get age(){		// перепишем геттер по-нормальному
			return this._age;
		},
		set age(value){
			this._age = value;
		}
	};
	console.log(person.age);		// Hello from getter!

Поразглядывай неторопливо:
	var person = {
		name: "Sorax",
		_age: 20,
		get age(){
			return this._age;	// return (this._age + 10)
		},
		set age(value){
			this._age = value;
		}
	};
	console.log(person._age);   // _age - вызов свойства напрямую
	console.log(person.age);    // age - вызов геттера, вернется 20
	person.age(30);	// неправильная передача значения, age - не функция
	person.age = 30;				// теперь _age = 30

Интересный пример. Думаю, разберешься.
	var person = {
		name: "Sorax",
		_age: 20,
		get age() { return this._age; },
		set age(value) {
		this._age = value < 0 ? 0 : value > 122 ? 122 : value; }
	};
	person.age = 180;
	console.log(person.age);		// 122
	person.age = -80;
	console.log(person.age);		// 0
	person.age = 34;
	console.log(person.age);		// 34

Помимо имени и значения каждое СВОЙСТВО имеет 'атрибуты': writable, enumerable, configurable. Эти 3 атрибута, как и само value, можно получать и изменять при помощи объекта 'дескриптор свойств'. Чтобы его получить, достаточно воспользоваться статическим методом getOwnPropertyDescriptor() класса Object. Первый аргумент - объект, второй - имя свойства.
	console.log( Object.getOwnPropertyDescriptor(person, "name"); )
	// Object {value: "Sorax", writable: true, enumerable: true, configurable: true}
	console.log(Object.getOwnPropertyDescriptor(person, "age"));
	// Object {enumerable: true, configurable: true, get: function, set: function}
Обрати внимание, что в аксессоре нет атрибута 'writable', поскольку доступ для записи опр. наличием сеттера: если сеттера нет, то writable: true.

Для опр. или переопр. атрибутов свойств можем исп. статический метод defineProperty(). Он принимает 3 параметра: объект, свойство и дескриптор.
----------                                     ----------
	Object.defineProperty(person, "gender", {
		value: "male",
		writable: false,
		enumerable: false,
		configurable: false
	})

НЕМНОГО О ЦИКЛЕ for...in.

Слева от ключевого слова in указываем ИД, кот. будет исп. для отдельных свойств объекта 'person'. В теле цикла выведем свойство property в консоль.
	for (property in person) {
		console.log(property);	// name, _age, age
	};
В итоге выводятся все свойства объекта, в том числе наследованные. Свойство gender не выводится, поскольку в его дескрипторе атрибут 'enumerable' установлен в false.

Помимо цикла для этих целей можно исп. статический метод keys(). Он вернет массив всех свойств, причем только перечисляемых (enumerable).
	console.log( Object.keys(person) );	// ["name", "_age", "age"]

Также для проверки атрибута 'enumerable' есть метод propertyIsEnumerable(). Причем этот метод уже не является методом класса Object, а вызывается непосредствено у самого объекта. Он будет возвращать true только для ненаследованных свойств.
	console.log( person.propertyIsEnumerable("gender") );	// false

Атрибут 'configurable' предназначен для опр. возможности изменения атрибутов этого свойства. Если у свойства изначально 'configurable: false', то изменить значения других атрибутов уже не удастся. Если:
	Object.defineProperty (person, "gender", {... configurable: false });
то
	Object.defineProperty (person, "gender", { writable: true });
	// Cannot redefine property: gender

Также есть метод 'defineProperties( объект, {...} )'. Второй аргумент - объект с парами свойство-дескриптор. В дескрипторе также можно прописывать геттеры и сеттеры.
	var o = {};
	Object.defineProperties(o, {
		x: { value: 10, 	writable: false },
		y: { value: 20, 	writable: false	},
		r: { get: function() { return Math.sqrt(this.x * this.x + this.y * this.y) }
		};
	});
	o.x = 16;
	console.log(o, r);

РАСШИРЯЕМОСТЬ ОБЪЕКТОВ - возможность добавления новых свойств. Для проверки объекта на расширяемость сущ. статический метод isExtensible().

... Заебался писать. Если надо, то - "Javascript-джедай #19 - Аксессоры и атрибуты свойств"

____________________________________________________________________

ПРОТОТИПЫ И НАСЛЕДОВАНИЕ

Все объекты или объектный тип данных можно назвать 'ссылочным типом'. Когда присваиваем var число или строку, она хранит значение (это касается любых примитивов). Когда мы присваиваем var объект, var хранит ссылку на объект.

Пример работы с var:
	var a = 10, b = 20;
	a = b;		// теперь var a хранит значение 20
	b = 15;
	console.log(a);	// 20

C объектами это работает иначе, т.к. var хранят не значения, а ссылки.
	var a = {x: 10}, b = {x: 20};
	a = b;		// теперь обе var ссылаются на 1 объект
	console.log(a.x);		// 20
	b.x = 15;
	console.log(a.x);		// 15
--------------------------------------------------------------------------------------

Практически любой объект в JS имеет второй связанный с ним объект - 'прототип'. Объект наследует свойства своего прототипа,и все свойства прототипа будут доступны через дочерний объект. Это называется 'Prototypal Inheritance' или 'наследованием, основанном на прототипах'. Это единственный тип наследования в JS.

Наследование в JS - это очень просто. Вы просто создаете объект, кот. дб прототипом, затем создаете на основе него новые объекты при помощь 'Object.create()' и имеет доступ ко всем свойствам прототипа.
----------                                   ----------
	var ObjectProto = { name: "Sorax" };		// прототип
	var object = Object.create(ObjectProto);	// создание obj на основе прототипа
	console.log(object.name);	// Sorax

Зачем все это нужно? Допустим, в вашей программе вам нужно создавать много однотипных объектов, и каждый раз прописывать все свойства и одинаковые методы было бы утомительно + значительно раздувало бы объем кода.
	var Person = {
		constructor: function(name, age, gender) {
			this.name = name;
			this.age = age;
			this.gender = gender;
			return this;
		},
		greet: function() {
			console.log("Hi, my name is " + this.name);
		}
	};
	// Теперь мы можем создавать объекты при помощи Object.create(). И поскольку этот метод возвращает новый объект, мы можем сразу вызывать его метод constructor(), в кот. передадим имя, возраст и пол.
	var person = Object.create(Person).constructor("John", 35, "male");
	console.log(person);		// constructor {name: "John", age: 35, gender: "male"}
	console.log(person.name);	// John
	person.greet();			// Hi, my name is John

'Класс' - это условное понятие, под кот. понимают множество объектов, наследующих свойства от 1 прототипа. В нашем случае все объекты, наследующие свойства от прототипа Person, будут иметь 1 класс.
Это только 1 способ реализации класса в JS.s

Чтобы определить, явл. ли объект прототипом другого объекта, есть метод isPrototypeOf().
	console.log( Person.isPrototypeOf (person) );	// true

"В этом примере мы создали прототип и объект, наследующий его свойства".
Порядок создания объекта на основе прототипа:
1. Объявляется var.
2. var присваивается метод Object.create(Имя_прототипа).
3. var вызывает метод прототипа, чтобы передать аргументы: ProtoMeth("arg", 123, true).
4. Затем создается объект со свойствами прототипа и уникальными значениями.

"Допустим, нам надо создать класс (прототип) WebDeveloper, экземпляры (объекты) которого..."

____________________________________________________________________

КОНСТРУКТОРЫ И КЛАССЫ

Конструктор - это функция, кот., будучи вызвана с ключевым словом new, возвращает новый объект. К. принято называть с большой буквы.
Внутри К. ключевое слово this указывает на новый создаваемый объект.

	var Person, person, anotherPerson;
	Person = function(name) { this.name = name };
	// В этом примере К просто принимает имя и присваивает его соответствующему свойству объекта.
Затем мы можем вызывать эту функцию с new и получать новые объекты.
	person = new Person("Jack");
	console.log(person);		// Person {name: "Jack"}
	anotherPerson = new Person("Bruce");
	console.log(anotherPerson.name);		// Bruce

"В этом примере при помощи конструктора Person мы опр. класс Person и создали 2 экземпляра/объекта".

* Но чем К отличаются от обычных функций? Ничем. Любая функция в JS потенциально явл. К и любую функцию можно вызывать с new.

'КЛАСС' - это множество всех объектов, наследующих свои свойства от 1 прототипа.

Помимо того, что каждая функция потенциально явл. К, она также имеет свойство prototype, в кот. хранится прототип, свойства кот. будут наследовать все объекты, создаваемые при помощи К.
	console.log(Person.prototype);	// Object { constructor: function }

Изначально это пустой объект, но мы можем вешать на него любые свойства и методы, и они будут доступны всем экземплярам класса.

	Person.prototype.greet = function() {
		console.log( "Hello, my name is "+ this.name );
	};	// создаем конструктор
	person = new Person("Jack");	// присваиваем К и передаем аргумент
	person.greet();	// Hello, my name is Jack

Что же касается свойства prototype, оно сущ. только у функций, и оно хранит прототип, от кот. будут наследовать свои свойства все объекты, кот. будут создаваться этой функцией при помощи new.
// Т.е. функция-конструктор как бы хранит в себе прототип.

Что касается создания дочерних классов.
	Developer = function(name, skills) {
		Person.apply(this, arguments);
		this.skills = skills || [];
	};
	// и для наследования лучше исп. Object.create()
	Developer.prototype = Object.create(Person.prototype);
	// Но здесь свойство constructor будет указывать на функцию Person, а нам надо Developer. Но это легко исправить.
	Developer.prototype.constructor = Developer;


Метод toString() исп. во всех случаях, когда объект преобразуется в строку. Например, если попытаться канкатенировать строку с объектом, то интерпретатор вызовет метод toString() нашего объекта.
	console.log(""+developer);		// {object Object}

Мы можем переопределить этот метод на прототипе нашего класса:
	Person.prototype.toString = function() { return this.name; };

Массив при преобразовании в строку выглядит след. образом:
	console.log( [1, 2, 3].toString() );	// 1,2,3
	// просто строка, содержащая элементы, разделенные запятыми
При этом элементами массива мб объекты, и в этом случае toString() нашего массива будет вызывать методы toString() каждого элемента массива:
	console.log( [1, 2, 3, [4, 5, 6], {x: 7}].toString );		// 1,2,3,4,5,6,[object Object]


Функции JS явл. объектами, а потому наследуют методы от Object.prototype. И метод toString у функции возвращает исходный код функции.

АТРИБУТ class ОБЪЕКТОВ JS

Когда вызываем метод toString объектов получаем { object Object }, где Object - класс объектов. Этот класс нельзя изменить, и метод toString - единственный способ для получения класса объекта.

____________________________________________________________________

ЦЕПНЫЕ ВЫЗОВЫ МЕТОДОВ


	var string, newString;
	string = "Sometimes the sometimes same is different";
	newString = string
		.replace("is", "is not")	// заменим "is" на "is not"
		.concat(" actually")			// добавим что-нибудь в конец
		.toUpperCase()						// преобразуем все к верхнему регистру
		.replace(/ /g, "\n")			// заменим пробелы на переносы строк
		.slice(10);								// уберем первые 10 символов
	console.log(newString);	/*	THE
									SOMETIMES
									SAME
									IS
									NOT
									DIFFERENT
									ACTUALLY	*/
Здесь каждый метод возвращает новую строку, и если нам не нужно хранить промежуточные результаты, мы можем не созранять их в отдельные var, а просто вызывать методы по цепочке таким образом, обрабатывая строку, как нам нужно.

____________________________________________________________________

JSON И СЕРИАЛИЗАЦИЯ ОБЪЕКТОВ

'Сериализация объектов' - это преобразование объектов в строки. Это нужно для удобства хранения и передачи информации. Например, если надо получать к-то данные с сервера во время работы приложения, можно исп. JSON или XML. Или, например, в том же JSON можно хранить данные локально, исп. localStorage.

По синтаксису JSON представляет собой небольшое подмножество JS. В JSON можно хранить: объекты, массивы, строки, числа, true|false и null. Любые другие значения при сериализации превращаются в null.

Для преобразования объекта в строку в JSON-формате есть статический метод JSON.stringify():
	var user = {
		name: "Frank",
		id: 42345
	};
	var userData = JSON.stringify(user);
	console.log(userData);			// {"name":"Frank","id":42345}
	console.log(typeof userData);	// string
----------------------------------------------------------------------------------------
Чтобы получить из строки объект есть метод JSON.parse().
	console.log(JSON.parse(userData));		// Object {name: "Frank", id: 42345}

____________________________________________________________________

МАССИВЫ

'Массив' - упорядоченный набор элементов, каждый из кот. имеет свой порядковый номер или индекс. Элементами массива могут быть значения абсолютно любых типов, в том числе объекты и другие массивы.
	var array = [1, 3, 4];
	console.log(array[2]);		// 4

По индексу можно не только получать элемент, но изменять или создавать.
	var months = ["January", "February", "March", "April"];
	months[4] = "May";		// ["January", "February", "March", "April", "May"]

У каждого массива есть свойство .length, кот. хранит (кол-во элементов в массиве +1)
	console.log(months.length);	// 5

Добавить элемент в конец массива можно таким, не самым лучшим, образом:
	var months = ["January", "February", "March", "April", "May"]
	months[months.length] = "June";
	console.log(months);		// ["January", "February", "March", "April", "May", "June"]

Элементы массива не обязательно должны идти под последовательными индексами. Никто не мешает сделать так:
	months[20] = "Something";
	console.log(months);		// ["January", ... , "June", 20: "Something"]

Нужно сказать, что 'длина массива' - это не кол-во элементов в нем, а индекс последнего элемента +1.

Массивы являются объектами. У массива есть функция-конструктор Array(), при помощи нее можно создавать новые массивы. При этом аргументы, кот. мы передаем в конструктор, будут элементами массива. *
	var myArray = new Array(34, 123, 1521);
	console.log(myArray);	// [34, 123, 1521]

* Кроме случая, когда передаем 1 аргумент: тогда он станет длиной массива. Но смысла в этом нет, т.к. массивы бывают только динамическими.

В литерале массива можно пропускать элементы:
	var thirdArray = [, , , 23]		// [3: 23]
	// первые 3 эл-та = undefined, а эл-нт под 3 идексом имеет значение 23
Интересно, что у такого массива length=2, а не 3.

Интересный момент: индексы массивов по сути то же, что имена свойств объектов. Они так же хранятся в виде строк.
	months[20] = "Something";
	// так, число 20 преобр, в "20", кот. присваивается строка "Something"

На самом деле, ничто не мешает исп. строки вместо индексов. Но это не на 100% то же самое, что имена свойств.
	months["someProperty"] = "someValue";	[... , someProperty: "someValue"]

Когда добавляем элементы с разными индексами, автоматом обновляется свойство length. Это единственное отличие индексов от имен свойств. И это то, что делает массивы массивами, поскольку в остальном с ними можно обращаться, как с обычными объектами.

Если мы присвоим свойству length к-то значение, то все элементы в массиве, с индексами больше этого значения, удалятся из массива.
	months.length = 4;	// элементы, начиная с 5-го индекса, будут удалены

____________________________________________________________________

ES5 МЕТОДЫ МАССИВОВ

1. Метод forEach():
	var array = ["Some string", "Another string", "Third string", "JavaScript", "Sorax"];
	array.forEach( function(element, index, array){
		console.log(element)} );	/*	Some string
										Another string
										Third string
										JavaScript
										Sorax	*/
Или преобразовать все строки к верхнему регистру:
	array[index] = element.toUpperCase(); });
	console.log(array);	// ["SOME STRING", "ANOTHER STRING", "THIRD STRING", "JAVASCRIPT", "SORAX"]

Метод ' every() ' вернет булевое значение. Он вернет true, если для всех элементов выполнено к-то условие, и false, если найдется хотя бы 1 элемент, для кот. оно не будет выполнено.
Например, проверим, все ли строки в массиве имеет длину > 4 символов:

	var array = ["Some string", "Another string", "Third string", "JavaScript", "Sorax"];
	console.log(array.every(function(e){return e.length > 4}));
-------------------------------------------------------------------------------------------------
Аналогично работает метод ' some() ', но он возвращает true, если в массиве есть хотя бы 1 элемент, кот. выполняет условие.
Проверим, есть ли в массиве хоть одна строка, содержащая букву 'z'.

	var array = ["Some string", "Another string", "Third string"];
	console.log(array.some(function(e) {return e.indexOf('z') !== -1} ));		// false
-------------------------------------------------------------------------------------------------
Метод ' reduce() ' возвращает к-то 1 значение, кот. получается в результате выполнения функции для каждого элемента массива с возможностью сохранения промежуточного результата. Другими словами, на каждой интерации, помимо того, что вы будете иметь ссылку на текущий элемент массива, в вашем распоряжении также будет var с промежучтоным результатом, кот. сформировался в результате выполнения предыдущих итераций.

	var numbers = [1,2,3,4,5,6];
(1)	var reduced = numbers.reduce(function(a, b) {
(2)		return a + b;		// 21
		// можно перемножить числа, кратные 3:
		return a * (b % 3 === 0 ? )		// 18
		// возведение в степень:
		return Math.pow(a,b);
	});
(3)	console.log(reduced);

(1) Этот callback будет вызван с 4 аргументами (a, b, index, array), но нам интересны первые 2, где первый - промежуточное значение, а второй - значение текущего элемента массива.
(2) Чтобы сложить все элементы массива, достаточно написать. На каждой итерации к промежуточному начению прибавляется текущее.
(3) Результатом вычисления будет новое промежуточное значение, кот. будет исп. уже на след. итерации.
-------------------------------------------------------------------------------------------------
Методы 'indexOf' и 'lastIndexOf' для поиска элемента в []. Работают аналогично соответствующим методам работы со строками.
В примере ниже индекс первого вхождения 3 в массив = [2], последнего = [5].
	var numbers = [1, 2, 3, 4, 5, 3, 6];
	console.log( numbers.indexOf(3) );		// 2
	console.log( numbers.lastIndexOf(3) );	// 5
Если искать элемент, кот. нет в массиве, то аналогично другим методам работы со строками, получим -1:
	console.log( numbers.indexOf(10) );	// -1

____________________________________________________________________

ОБЪЕКТ MATH

Рассмотрим некоторые его методы.

// .pow(число, степень) - возведение в степень.
	console.log( Math.pow (2,5) );	// 32
// .sqrt() - возвращает квадратный корень числа
	Math.sqrt (400);	// 20
// .abs() - чтобы взять модуль числа
	Math.abs (300);	// 300
// .round() - округление до целого числа
	Math.round (9.6);		// 10 , потому что .6 >= 5
	Math.round (9.2);		// 9
// .floor() и .ceil() - для принудительного округления в < или > сторону
	Math.floor(9.6);	// 9
	Math.ceil  (9.2);	// 10
// .min() и .max() - возвращают < или > число из передаваемых аргументов
	Math.min (6, 9, 2, 5);		// 2
	Math.max (6, 9, 2, 5);		// 9
// .exp() - возводит число 'е' в указанную степень
	Math.exp (1);		// 2.718281828459045
// .log() - возвращает натуральный логорифм числа
	Math.log (5);		// 1.6094379124341003

Также есть всевозможные тригонометрические функции:
	Math.sin	(1);		// 0.8414709848078965	- синус
	Math.cos	(1);		// 0.5403023058681398	- косинус
	Math.tan	(1);		// 1.5574077246549023	- тангенс
	Math.atan	(1);		// 0.7853981633974483	- арктангенс
	Math.asin	(1);		// 1.5707963267948966	- арксинус
	Math.acos	(1);		// 0						- арккосинус
Все углы в радианах (sin, cos, tan) принимают значение угла в радианах и (atan, asin, acos) возвращают значение угла в радианах.

Также есть константа PI:
	console.log(Math.PI);	// 3.141592653589793
	console.log(Math.cos (Math.PI) );	// -1

* Остальное смотри в видео.

-------------------------------------------------------------------------------------------------

'Самый полезный метод'

Math.random() - не принимает никаких аргументов и просто возвращает произвольнео число от 0 до 1.
	console.log( Math.random() );	// 0.24840311964130102

Чтобы получить произвольное число в диапазоне от -10 до 10, мы можем:
	console.log( -10 + Math.random() * 20 );	// 6.904897514933346 - рандом

Поскольку это не очень удобно писать, можно написать функцию, кот. будет принимать min и max значения и возвращать Math.random() * на разницу между max и min числом +min число. При помощи такой функции мы можем получать рандомные числа в любом диапазоне.
	var getRandom = function(min, max) {
		return Math.random() * (max - min) + min;
	};
	console.log(getRandom(10, 20));	// 18.285427359686103
	console.log(getRandom(-100, 100));	// 75.55082538356811

____________________________________________________________________

WINDOW

Объект window является глобальным и стоит на вершине иерархии всех объектов. У него много всяких свойств и методов, среди кот. есть разные конструкторы.

Говоря о window, нельзя обойти вниманием глобальные var. 'Глобальные переменные' - это var, объявленные вне к-либо функций. На самом деле, все глобальные var становятся свойствами объекта window. Т.е. когда мы пишем коде имя глобальной var, интерпретатор ищет одноименное свойство объекта window.
	window.myVar = 500;
	console.log(myVar);	// 500
или
	var myVar = 500;
	console.log(window.myVar)	// 500

То же самое работает с глобальными функциями.
	console.log(window.parseInt("1000px", 10));	// 1000

То же самое с конструкторами. Они также висят на глобальном объекте.
	var array = new window.Array(10, 20, 30);
	console.log(window.array)	// [10, 20, 30]

Даже объект 'console' является свойством объекта window.
	window.console.log(window.array)	// [10, 20, 30]

Просто мы можем не писать window всякий раз, он и так подразумевается.

На window есть несколько объектов, кот. стоит рассмотреть раньше других:
	document, location, navigator, screen, history

Функция 'setTimeout()' позволяет выполнить к-то функцию, спустя некоторый промежуток времени. Первый аргумент - callback (функция, кот. нужно выполнить), второй - кол-во милисекунд.
	setTimeout(function() {
		console.log("2 seconds passed");
	}, 2000);

Функция 'setInterval()' выполняет функцию многократно с указанным интервалом.
	var i = 0;
	setInterval(function() {
		console.log(i++);
	}, 1000);

Функции 'setTimeout()' и 'setInterval()' возвращают значение, и мы можем присвоить значение к-то var и посмотреть, что это за значение.
	var i = 0;
	var timer = setInterval(function() {}, 200);
	console.log(timer);	// 1

1 - это id счетчика. Его мб передать в Ф clearInterval(), кот. остановит счетчик.
	window.onclick = function() {
		clearInterval(timer);	// при клике по окну счетчик остановится
	};
Также есть функция clearTimeout(), кот. работает аналогичным образом.

---------------------------------------------------------
Это любопытно!

	var start = function() { console.log("Started!") };
	confirm("Start?") && start();
	// Интересная запись: если OK, то выполняется функция

	console.log(
		prompt("Your age?") >= 18
		? "Access granted"
		: "Access denied"
	);	// интересное оформление записи
---------------------------------------------------------

В JS есть возможность програмно открывать окна. Как правило, эта фича исп. для показа рекламы. Открывает окно без тулбара, только с адресной строкой.
	window.open("http://google.com");

____________________________________________________________________

LOCATION

Как перенаправлять пользователя:
	location.href = "http://google.com";
либо напрямую:
	location = "http://google.com";

Из примечательного.
Есть 2 функции, кот. не являются методами объекта location, но имеют отношение к адресу: encodeURI() и decodeURI().
1. encodeURI() - принимает строку и заменяет в ней все не ASCI-символы на эскей(?)-последовательность.
	console.log(encodeURI("http://google.com/page?name=Какое-то_имя"));
	// http://google.com/page?name=%D0%9A%...BE_%D0%B8%D0%BC%D1%8F
2. decodeURI() - наоборот берет URL с эскей-послед. и возвр. норм. строку
	console.log(decodeURI("http://google.com/page?name=%D0%9A%D0%B0%D0%BA%D0%BE%D0%B5-%D1%82%D0%BE_%D0%B8%D0%BC%D1%8F"));
	// http://google.com/page?name=Какое-то_имя

____________________________________________________________________

ПАРСИНГ

Парсинг - преобразование HTML-кода в набор некоторых сущностей (элементов страницы), над кот. можно оперировать программно. После парсинга все эти символы превращаются в иерархическую структуру - 'дерево объектов'.

Поскольку мы хотим иметь возможность управлять содержимым страницы программно из наших скриптов, браузер должен предоставить соответствующий интерфейс, т.е. набор классов, объектов, методов и свойств, при помощи кот. мы можем рулить этим внутренним представлением. Такой интерфейс называется DOM. Проще говоря, DOM - это промежуточное звено между кодом на JS и нативным кодом браузера (С++).

Как уже было сказано, иерархия элементов страницы в DOM является деревом объектов, и отдельные объекты этого дерева называются 'нодами' (node - узел). Все ноды являются экземплярами класса Node и соответственно наследуют методы и свойства от Node.prototype. У класса Node есть много разных подклассов, кот. обозначают ноды к-то конкретных видов. Почти для всех тэгов HTML есть свой класс. Также есть классы для атрибутов, обычного текста и всего документа.

____________________________________________________________________


























УЧЕБНИК

Процесс выполнения скрипта называется интерпретацией, .т.к. выполняется интерпретатором.

Апплет - программа на Java, кот. можно подключить к HTML при помощи тэга applet. Подписанный Java-апплет может всё то же, что и обычная программа,
установленая на компьютере, правда, понадобится согласие пользователя при открытии такого апплета.

*** Либо async либо defer ***
Одновременно указывать async и defer не имеет смысла, в этом случае браузер использует только async.
*** Атрибуты async/defer — только для внешних скриптов ***
Атрибуты async/defer работают только в том случае, если назначены на внешние скрипты, т.е. имеющие src. При попытке назначить их на обычные скрипты <script>...</script>, они будут проигнороированы.

*** Быстрое комментирование ***
"Ctrl+/" - для однострочных и "Ctrl+Shift+/" - для многострочных (нужно выделить блок и нажать сочетание клавиш).

Чтобы перевести JS-код в режим полного соответствия современному стандарту EcmaScript 5 (ES5), нужно указать специальную директиву use strict. Директива выглядит как строка "use strict"; или 'use strict'; и ставится в начале скрипта.
	"use strict";		// этот код будет работать по современному стандарту ES5
"use strict"; также можно указывать в начале функций, тогда строгий режим будет действовать только внутри функции.

Браузер IE8 поддерживает только совсем старую версию стандарта JavaScript, а именно ES3. К счастью, многие возможности современного стандарта можно добавить в этот браузер, подключив библиотеку ES5 shim , а именно скрипты es5‐shim.js и es5‐sham.js из неё.

КОНСТАНТА  -  это переменная, которая никогда не меняется. Как правило, их называют большими буквами, через подчёркивание. Например:
	var CONSTANTA = "сложные, не требующие изменений данные, к кот. проще обратиться через var";
	var COLOR_GREEN = "#0F0";
• Технически, константа является обычной переменной, то есть её можно изменить, но мы договариваемся этого не делать.
• Константы используют вместо строк и цифр, чтобы сделать программу понятнее и избежать ошибок.

ПРАВИЛА ИМЕНОВАНИЯ ПЕРЕМЕННЫХ
1. Никакого транслита. Только английский.
2. Использовать короткие имена только для переменных «местного значения».  Название дб понятным. Иногда для этого нужно использовать несколько слов.
3. Переменные из нескольких слов пишутся вместеВотТак. Этот способ записи называется «верблюжьей нотацией» или «camelCase».
4. Имя переменной должно максимально чётко соответствовать хранимым в ней данным.
* Смысл имени переменной - это «имя на коробке», по которому мы сможем максимально быстро находить нужные нам данные.
* Не нужно бояться переименовывать переменные, если вы придумали имя получше.

• Булевый (логический) тип «boolean». У него всего два значения: true (истина) и false (ложь). Как правило, такой тип используется для хранения значения типа да/нет.
• null - специальное значение, которое имеет смысл «ничего» или «значение неизвестно». Например, var age = null.
• undefined - «значение не присвоено». Если переменная объявлена, но в неё ничего не записано, ее значение undefined. В явном виде undefined обычно не присваивают, так как это противоречит его смыслу. Для записи в переменную «пустого» или «неизвестного» значения используется null.
• object - используется для коллекций данных и для объявления более сложных сущностей. Объявляются при помощи {...}, например: var user = { name: "Вася" };

----------------------------------------------------
ТИПЫ ДАННЫХ:
1. number / число 								ǁ
2. string / строка									ǁ
3. boolean / логичекий тип					> ПРИМИТИВНЫЕ ТИПЫ ДАННЫХ
4. null / значение неизвестно					ǁ
5. undefined / значение не присвоено		ǁ
6. object / объект
----------------------------------------------------
ИТОГО есть 5 «примитивных» типов: number, string, boolean, null, undefined и 6-й тип - object. Оператор typeof x позволяет выяснить, какой тип находится в x, возвращая его в виде строки.

* Функции не являются отдельным базовым типом в JavaScript, а подвидом объектов. Но typeof выделяет функции отдельно, возвращая для них "function". На практике это весьма удобно, так как позволяет легко определить функцию.

<!> Если хотя бы один аргумент является строкой, то второй будет также преобразован к строке, произойдет конкатенация. Приведение к строке - особенность исключительно бинарного оператора "+".

Унарный плюс преобразует строку в число. Например:
	var apples = "2";
	var oranges = "3";
	alert( apples + oranges );	// "23", так как бинарный плюс складывает строки
Зато
	alert( +apples + +oranges );	// 5, число, оба операнда предварительно преобразованы в числа
Унарный плюс имеет приоритет выше, чем у обычного «сложения».

<!> Инкремент/декремент можно применить только к переменной. Код 5++ даст ошибку. Правильно: i++.
Вызывать эти операторы можно не только после, но и перед переменной: i++ (называется «постфиксная форма») или ++i («префиксная форма»).
* Постфиксная форма i++ отличается от префиксной ++i тем, что возвращает старое значение, бывшее до увеличения.

<!> Операторы сравнения возвращают логическое значение.

• Пустая строка, как и false, при преобразовании к числу дают 0.
• Для проверки равенства без преобразования типов используются операторы строгого равенства === и !==. Если тип разный, то они всегда возвращают false.

Интуитивно кажется, что null/undefined эквивалентны нулю, но это не так. Они ведут себя по-другому.
1. Значения null и undefined равны == друг другу и не равны чему бы то ни было ещё. Это жёсткое правило буквально прописано в спецификации языка.
2. При преобразовании в число null становится 0, а undefined становится NaN.

<!> Значение undefined вообще нельзя сравнивать.
<!> Вывод: любые сравнения с undefined/null, кроме точного ===, следует делать с осторожностью.

ИТОГО
• В JavaScript есть логические значения true (истина) и false (ложь). Операторы сравнения возвращают их.
• Строки сравниваются побуквенно.
• Значения разных типов приводятся к числу при сравнении, за исключением строгого равенства === (!==).
• Значения null и undefined равны == друг другу и не равны ничему другому. В других сравнениях (с участием >,<) их лучше не использовать, так как они ведут себя не как 0.


ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ parseInt, toString
• parseInt("11000", 2) - переводит строку с двоичной записью числа в число.
• n.toString(2) - получает для числа n запись в 2-ной системе в виде строки.
	var access = parseInt("11000", 2); 		// получаем число из строки
	alert( access ); 							// 24, число с таким 2‐ным представлением
	var age = access.toString(2);			// обратно двоичную строку из числа
	console.log(age);							//11000

<!> Осторожно, приоритеты!
В JavaScript побитовые операторы ^, &, | выполняются после сравнений ==.
Например, в сравнении a == b^0 будет сначала выполнено сравнение a == b, а потом уже операция ^0, как будто стоят скобки (a == b)^0.
Обычно это не то, чего мы хотим. Чтобы гарантировать желаемый порядок, нужно ставить скобки: a == (b^0).

* Данные/значение/число в двоичном виде или двоичной системе счисления. 2-ная система счисления, 32-битное число.


ОКРУГЛЕНИЕ

Так как битовые операции отбрасывают десятичную часть, то их можно использовать для округления.
	console.log( 5.123 );			// 5.123
	console.log( ~5.123 );		// -6
	console.log( ~~5.123 );		// 5
Подойдёт и Исключающее ИЛИ (^) с нулём:
	alert( 5.123 ^ 0 ); 			// 5
Последнее даже более удобно, поскольку отлично читается:
	alert(12.3 * 14.5 ^ 0); 		// (=178) "12.3 умножить на 14.5 и округлить"
У побитовых операторов достаточно низкий приоритет, он меньше чем у остальной арифметики
	alert( 1.1 + 1.2 ^ 0 ); 		// 2, сложение выполнится раньше округления

Обращение битов - это побитовое НЕ (~). При таком формате представления числа ‐n = ~n + 1. Или, если перенести единицу: ~n = ‐(n+1).

Проверка на ‐1 пригождается, например, при поиске символа в строке. Вызов str.indexOf("подстрока") возвращает позицию подстроки в str, или ‐1 если не нашёл.
	var str = "Проверка";
	if (~str.indexOf("верка")) {	 	// Сочетание "if (~...indexOf)" читается как "если найдено"
	  alert( 'найдено!' );}


УМНОЖЕНИЕ И ДЕЛЕНИЕ НА СТЕПЕНИ 2

Оператор a << b, сдвигая биты, по сути умножает a на 2 в степени b. Например:
	alert( 1 << 2 );		// 1*(2*2) = 4
	alert( 1 << 3 );		// 1*(2*2*2) = 8
	alert( 3 << 3 );		// 3*(2*2*2) = 24
Оператор сдвига в другую сторону a >> b, производит обратную операцию: целочисленное деление a на 2 b .
	alert( 8 >> 2 ); 		// 2 = 8/4, убрали 2 нуля в двоичном представлении
	alert( 11 >> 2 );		 // 2, целочисленное деление (менее значимые биты просто отброшены)


БАЗОВЫЕ UI ОПЕРАЦИИ: alert, prompt, confirm.

	alert( "Привет" );
	prompt("Заголовок", "Текст внутри поля ввода");	// для пустого поля укажи ""	// всегда указывайте "", ибо проблемы с IE
	confirm("Вопрос?");	// выводит окно с вопросом и 2 кнопками: OK=true и CANCEL(Esc)=false
Например:
	var virgin = confirm("Вы и правда девственник?");		// вызовет модальное окно с вопросом
	alert(virgin);	//вернет true или false
РЕЗЮМЕ
• alert выводит сообщение.
• prompt выводит сообщение и ждет, пока пользователь введет текст, а затем возвращает введенное значение или null, если ввод отменен (CANCEL/ Esc ).
• confirm выводит сообщение и ждет, пока пользователь нажмет «OK» или «CANCEL» и возвращает true/false.
-----------------------------------------------------------
	var year = prompt("В каком году что-то там?", "");
	if(+year == 2011 ) alert("Верно! Молодчина!");
	else alert("А вот и неправильно!")
Правильнее будет так:
	var year = prompt("В каком году что-то там?", "");
	if(year == 2011 ) alert ("Верно! Молодчина!");
	else alert ("А вот и неправильно!")
------------------------------------------------------------


if - это оператор.
	if (условие) {команда};
	if (year != 2011) {alert( 'А вот и неправильно!' );}
Оператор if (...) вычисляет и преобразует выражение в скобках к логическому типу, где: число 0, пустая строка "", null, undefined и NaN = false. Остальные значения = true.
Например, такое условие никогда не выполнится:	if (0) { ... }		// 0 преобразуется к false
А такое — выполнится всегда:	if (1) { ... }		// 1 преобразуется к true
----------------------------------------------------------------------------------------


ОПЕРАТОР ВОПРОСИТЕЛЬНЫЙ ЗНАК '?'

Проверка возраста:
	var access;
	var age = prompt("Сколько вам лет?","");
	if ( age > 14 ) { access = true;
	} else { access = false;}
	alert(access);
Оператор вопросительный знак '?' позволяет делать это короче и проще. Он состоит из трех частей:
	условие ? значение1 : значение2
Проверяется условие, затем если оно верно, возвращается значение1, если неверно - значение2. Например:
	var age = prompt("Сколько вам лет?","");
	access = (age > 14) ? true : false;
	alert(access);
В данном случае можно было бы обойтись и без оператора '?', т.к. сравнение само по себе уже возвращает true/false:
	var age = prompt("Сколько вам лет?","");
	var access = age > 14;
	alert(access);


НЕСКОЛЬКО ОПЕРАТОРОВ '?'

Последовательность операторов '?' позволяет вернуть значение в зависимости не от одного условия, а от нескольких. Например:
	var age = prompt('Ваш возраст?','');
	var message = (age < 3) ? 'Здравствуй, малыш!' :
	  (age < 18) ? 'Привет!' :
	  (age < 100) ? 'Здравствуйте!' :
	  'Какой необычный возраст!';
	alert( message );
-------------------------------------------------------------
var age = prompt("Укажите свой возраст:","");
var modal = (age >= 18) ? alert("Добро пожаловать") : (условие2) ? операция2 : (условие3) ? операция3;
-------------------------------------------------------------
Например:
	var age = prompt('Каков ваш возраст?', 18);
	var message = (age < 3) ? 'Здравствуй, малыш!' :	// '?' проверяет сначала age < 3, если true - возвращает 'Здравствуй, малыш!'
	  (age < 18) ? 'Привет!' :								// если false - идет за ':' и проверяет age < 18. Если это верно — возвращает 'Привет!'
	  (age < 100) ? 'Здравствуйте!' :						// иначе проверка age < 100 и 'Здравствуйте!
	  'Какой необычный возраст!';						// если ничего из этого не верно, то 'Какой необычный возраст!'.
	alert( message );
То же самое через if..else:
	if (age < 3) { message = 'Здравствуй, малыш!';
	} else if (a < 18) { message = 'Привет!';
	} else if (age < 100) { message = 'Здравствуйте!';
	} else { message = 'Какой необычный возраст!'; }




------------------------ ОБРАТИ ВНИМАНИЕ !!! ------------------------
Обычный if:
	if ( условие ) { операция }
Если нужно проверить несколько вариантов условия:
	if ( условие1 ) { операция1;
	} else if ( условие2 ) { операция2;
	} else { операция3 }
Оператор '?' (нуждается в объявлении переменной):
	var x = ( условие ) ? операция1(если true) : операция2(если false)		// 3-го не дано
Несколько операторов '?'
	var x = значение
	var y = ( условие1 с var x ) ? операция1 : ( условие2 с var x ) ? операция2 :  ( условие3 с var x ) ? операция3 : операция4
-------------------------------------------------------------------------------




ЛОГИЧЕСКИЕ ОПЕРАТОРЫ

Для операций над логическими значениями в JS есть || (ИЛИ), && (И) и ! (НЕ). Хоть они называются «логическими», но могут применяться к значениям любого типа и возвращают также значения любого типа.
1. || ( ИЛИ )
	result = a || b;
Логическое ИЛИ работает следующим образом: если хотя бы один из аргументов true, то возвращает true, иначе - false.
Обычно оператор ИЛИ используется в if, чтобы проверить, выполняется ли хотя бы одно из условий, например:
	var hour = 9;
	if (hour < 10 || hour > 18) {
	alert( 'Офис до 10 или после 18 закрыт' ); }
Про «КОРОТКИЙ ЦИКЛ ВЫЧИСЛЕНИЯ». Допустим, вычисляются несколько ИЛИ подряд: a || b || c || .... Если первый аргумент true, то результат заведомо будет true, и остальные значения проигнорируются. Оператор ИЛИ вычисляет ровно столько значений, сколько необходимо до первого true. При запуске примера ниже присвоение x не произойдёт:
	var x;
	true || (x = 1);	// если бы false, произошло бы присваивание x=1
	alert(x); 		// undefined, x не присвоен
Его используют, в частности, чтобы выбрать первое «истинное» значение из списка:
	var undef; // переменная не присвоена, т.е. равна undefined
	var zero = 0;
	var emptyStr = "";
	var msg = "Привет!";
	var result = undef || zero || emptyStr || msg || 0;
	alert( result );		 // выведет "Привет!" ‐ первое значение, которое является true
Оператор ИЛИ возвращает то значение, на котором остановились вычисления (причём, не преобразованное к логическому типу). Если все значения «ложные», то || возвратит последнее из них.
Оператор || вычисляет операнды слева направо до первого «истинного» и возвращает его, а если все ложные - то последнее значение.
2. && (И)
Оператор && возвращает true, если оба аргумента истинны, а иначе false. && возвращает первый false и заканчивает вычисления.
	// Первый аргумент ‐ true,
	// Поэтому возвращается второй аргумент
	alert( 1 && 0 ); // 0
	alert( 1 && 5 ); // 5
	// Первый аргумент ‐ false,
	// Он и возвращается, а второй аргумент игнорируется
	alert( null && 5 ); // null
	alert( 0 && "не важно" ); // 0
Итак, оператор && вычисляет операнды слева направо до первого «ложного» и возвращает его, а если все истинные то последнее значение.
* Приоритет у && больше, чем у ||.
	alert( 5 || 1 && 0 );	// 5
3. ! (НЕ)
Действия:
	1. Сначала приводит аргумент к логическому типу true/false.
	2. Затем возвращает противоположное значение.
Например:
	alert( !true );	// false
	alert( !0 ); 	// true
В частности, двойное НЕ используются для преобразования значений к логическому типу:
	alert( !!"строка" );	// true
	alert( !!null );		// false


<!> ВЫЗОВ alert НЕ ВОЗВРАЩАЕТ ЗНАЧЕНИЯ - ВОЗВРАЩАЕТ undefined.

-----------  ЗАДАНИЕ  -----------
Проверка if внутри диапазона:
	if (age >=14 && age <=90)
Проверка if вне диапазона с использованием оператора НЕ !:
	if (!(age >=14 && age <=90))
Проверка if вне диапазона:
	if (age<14 && age>90)
-------------------------------------


"0 в логическом контексте есть false"
**************************
'ИЛИ' возвращает первое true либо последнее false
'И' возвращает первое false либо последнее true
**************************

console.log(+"a12")	//NaN




ПРЕОБРАЗОВАНИЕ ТИПОВ ДЛЯ ПРИМИТИВОВ

Всего есть три преобразования:
1. CТРОКОВОЕ ПРЕОБРАЗОВАНИЕ.
Происходит, когда требуется представление чего-либо в виде строки. Например, его производит функция alert.
	var a = true;
	alert( a ); 	// "true"
Можно осуществить преобразование явным вызовом String(val):
	alert( String(null) === "null" );	// true
Для явного преобразования также применяется оператор "+", у которого один из аргументов строка (+ ""). В этом случае оба аругмента приводятся к строке:
	alert( true + "test" ); // "truetest"
	alert( "123" + undefined ); // "123undefined"
----------------------------------------------------------------------------------
2. ЧИСЛЕННОЕ ПРЕОБРАЗОВАНИЕ.
Для преобразования к числу в явном виде можно вызвать Number(val) либо поставить перед выражением унарный плюс "+":
	var a = +"123"; // 123
	var a = Number("123"); // 123, тот же эффект
	alert( +"   \n  123   \n  \n" ); // после обрезания пробельных символов останется "123"
	console.log(+true)	// 1	и 0, если +false
При сравнении разных типов происходит численное преобразование:
	alert( "\n0 " == 0 );  // true
	При этом строка "\n" преобразуется к числу, как указано выше: начальные и конечные пробелы обрезаются, получается пустая строка "", которая равна 0.
***	ВСПОМНИ: сравнение строк происходит побуквенно и основывается на числовом значении символов в кодировке Unicode.
С логическими значениями.
	alert( "\n" == false );	// true	, потому что "\n"=0 и false=0 при численном преобразовании
	alert( "1" == true );		// true		та же история
Здесь сравнение "==" снова приводит обе части к числу. В первой строке слева и справа получается 0, во второй 1.
СПЕЦИАЛЬНЫЕ ЗНАЧЕНИЯ
Интуитивно, значения null/undefined ассоциируются с нулём, но при преобразованиях ведут себя иначе.
Для более очевидной работы кода и во избежание ошибок лучше не давать специальным значениям участвовать в сравнениях > >= < <=. Используйте в таких случаях переменные-числа или приводите к числу явно.
----------------------------------------------------------------------------------
3. ПРЕОБРАЗОВАНИЕ К ЛОГИЧЕСКОМУ ЗНАЧЕНИЮ (логическое преобразование).
Преобразование к true/false происходит в логическом контексте, таком как if(value), и при применении логических операторов.
Все значения, которые интуитивно «пусты», становятся false. Их несколько: 0, пустая строка, null, undefined и NaN. Остальное, в том числе и любые объекты - true.
Полная таблица преобразований:
	ЗНАЧЕНИЕ			ПРЕОБРАЗУЕТСЯ В
	undefined, null 		false
	Числа					Все true, кроме 0, NaN — false.
	Строки 				Все true, кроме пустой строки "" — false
	Объекты 				Всегда true
Для явного преобразования используется двойное логическое отрицание !!value или вызов Boolean(value).
<!> Обратите внимание: строка "0", как и строка из пробелов, становится true.
	alert( !!"0" ); // true
	alert( !!" " ); // любые непустые строки, даже из пробелов ‐ true!
Два значения могут быть =, но одно из них в логическом контексте true, другое false. Например, равенство в следующем примере верно, так как происходит численное преобразование:
	alert( 0 == "\n0\n" ); // true
А в логическом контексте левая часть даст false, правая true:
	if ("\n0\n") { alert( "true, совсем не как 0!" ); }
При равенстве - численное преобразование, а в if - логическое, только и всего.
----------------------------------------------------------------------------------
ИТОГО в JavaScript есть три преобразования:
1. Строковое: String(value) — в строковом контексте или при сложении со строкой. Работает очевидным образом.
2. Численное: Number(value) — в численном контексте, включая унарный плюс +value. Происходит при сравнении разных типов, кроме строгого равенства.
3. Логическое: Boolean(value) — в логическом контексте, можно также сделать двойным НЕ !!value.
Особым случаем является проверка равенства с null и undefined: они равны друг другу, но не равны чему бы то ни было ещё.
null == undefined != anything else


<!> String(value), Number(value), Boolean(value) - являются объектами-обертками, приводящие значение к соответствующему типу данных.
<!> value + ""	 +"value"		    !!value
<!> Если if(), то результатом будет boolean.

<!> ВАЖНО ЗАПОМНИТЬ <!>
1. Оператор "‐" работает только с числами, так что он сразу приводит "" к 0.
2. null при численном преобразовании становится 0
3. undefined при численном преобразовании становится NaN
4. При == с null преобразования не происходит, есть жёсткое правило: null == undefined и только.
5. +null == +"\n0\n" = true 	И левая и правая часть == преобразуются к числу 0.

____________________________________________________________________


------------------------------   ЦИКЛЫ   ------------------------------

1. ЦИКЛ while
	while ( условие ) { код, тело цикла }	// пока условие верно, выполняется код из тела цикла.
Например, цикл ниже выводит i пока i < 3:
	var i = 0;
	while (i < 3) { alert( i );		// пока истинно выражение (i < 3), будет выводиться alert
	  i++; }	// цикл совершает три итерации
Повторение цикла по-научному называется «ИТЕРАЦИЯ».
Условие в скобках интерпретируется как логическое значение, поэтому вместо while (i != 0) обычно пишут while (i):
	var i = 3;
	while (i) { alert( i );	// при i, равном 0, значение в скобках будет false и цикл остановится
	  i‐‐; }
2. ЦИКЛ do..while		* редко используется, т.к. while нагляднее
	do {
	  // тело цикла
	}while (условие);
Цикл, описанный, таким образом, сначала выполняет тело, а затем проверяет условие.
3. ЦИКЛ for
Чаще всего применяется цикл for:
	for (начало; условие; шаг) {
	  // ... тело цикла ...
	}
Пример цикла, который выполняет alert(i) для i от 0 до 2 включительно (до 3):
	var i;
	for (i = 0; i < 3; i++) { alert( i ); }
Поток выполнения: начало → (если условие → тело → шаг) → (если условие → тело → шаг) → т.д.
-------------------------------------------------------------------------
* На заметку. В цикле также можно определить переменную:
	for (var i = 0; i < 3; i++) { alert(i); }	// 0, 1, 2
Эта переменная будет видна и за границами цикла, в частности, после окончания цикла i станет равно 3.
-------------------------------------------------------------------------
ПРОПУСК ЧАСТЕЙ for. Любая часть for может быть пропущена.
Можно убрать начало:
	var i = 0;
	for ( ; i < 3; i++) { alert( i ); }	// 0, 1, 2
Можно убрать и шаг:
	var i = 0;
	for (; i < 3;) { alert( i ); }		// цикл превратился в аналог while (i<3)
А можно и вообще убрать все, получив бесконечный цикл:
	for (;;) {}	// будет выполняться вечно
<!> При этом сами точки с запятой ; обязательно должны присутствовать, иначе будет ошибка синтаксиса.


ПРЕРЫВАНИЕ ЦИКЛА break
	var sum = 0;
	while (true) {
		var value = +prompt("Введите число", '');
		if (!value) break;		// (*)
		sum += value; }
	alert( 'Сумма: ' + sum );
Директива break в строке (*), если посетитель ничего не ввёл, полностью прекращает выполнение цикла и передаёт управление на строку за его телом, то есть на alert.
Вообще, сочетание «бесконечный цикл + break» - отличная штука для ситуаций, когда условие прерывания находится не в начале-конце цикла, а посередине.

СЛЕДУЮЩАЯ ИТЕРАЦИЯ: continue
Директива continue прекращает выполнение текущей итерации цикла. Она прерывает не весь цикл, а только текущее выполнение его тела, как будто оно закончилось. Её используют, если понятно, что на текущем повторе цикла делать больше нечего. Например, цикл ниже использует continue, чтобы не выводить четные значения:
	for (var i = 0; i < 10; i++) {
	if (i % 2 == 0) continue;
	alert(i); }

МЕТКИ ДЛЯ break/continue
Бывает нужно выйти одновременно из нескольких уровней цикла. Например, внутри цикла по i находится цикл по j, и при выполнении некоторого условия мы бы хотели выйти из обоих циклов сразу:
outer:  for (var i = 0; i < 3; i++) {
			for (var j = 0; j < 3; j++) {
				var input = prompt('Значение в координатах '+i+','+j, '');	// если отмена ввода или пустая строка
				if (!input) break outer; }		// завершить оба цикла
		}
		alert('Готово!');
В коде выше для этого использована метка. Метка ставится перед циклом и имеет вид "имя:" (без кавычек). Можно также выносить ее на отдельную строку:
outer:
	for (var i = 0; i < 3; i++) { ... }
Вызов break outer ищет ближайший внешний цикл с такой меткой и переходит в его конец. В примере выше это означает, что будет разорван самый внешний цикл и управление перейдёт на alert. Директива continue также может быть использована с меткой, в этом случае управление перепрыгнет на следующую итерацию цикла с меткой.



"Имеется цикл с некоторой вложенностью циклов. Интерпретатор проверяет for(начало; условие; ) и, если все норм, опускается на уровень ниже, к следущему циклу и так далее. Дойдя до конечного цикла, интерпретатор произведет нужное кол-во итераций, пока условие этого цикла не перестанет выполняться, после чего поднимется на уровень выше и выполнит условие предпоследнего цикла."


ИТОГО

JavaScript поддерживает три вида циклов:
• while - проверка условия перед каждым выполнением.
• do..while - проверка условия после каждого выполнения.
• for - проверка условия перед каждым выполнением, а также дополнительные настройки.
Чтобы организовать бесконечный цикл, используют конструкцию while(true). При этом он, как и любой другой цикл, может быть прерван директивой break. Если на данной итерации цикла делать больше ничего не надо, но полностью прекращать цикл не следует - используют директиву continue.
Обе этих директивы поддерживают «метки», которые ставятся перед циклом. Метки - единственный способ для break/continue повлиять на выполнение внешнего цикла.

____________________________________________________________________

С префиксным инкрементом:
	var i = 0;
	while (++i < 5) alert( i ); // 1 2 3 4
С постфиксным инкрементом:
	var i = 0;
	while (i++ < 5) alert( i ); // 1 2 3 4 5
ПОТОМУ ЧТО сначала происходит сравнение, а потом увеличение. Затем срабатывание alert. Т.е.:
				var i = 0;
итерация1	while ( 0 < 5) -> true -> 0+1=1 -> alert ( 1 )  ->
				var i = 1;
итерация2	while ( 1 < 5) -> true -> 1+1=2 -> alert ( 2 )  ->   итерация2 <...>

Или так:
	var i = 0;
	while (++i < 5) alert( i );  =  ( (1 + 0) < 5 )  ->  alert(1)
	var i = 4;
	while (i++ < 5) alert( i );  =  ( (4 < 5) + 1 )  ->  alert(5)

____________________________________________________________________

Выведите четные числа:
	for (var i = 2; i <= 10; i++) {
		if(i % 2 == 0) {console.log(i) }	// 2 4 6 8 10
	}

Повторять цикл, пока ввод неверен:
	var num;		// вероятно, всегда нужно объявлять var перед loop
	do {num = prompt("Введите число больше 100?", 0);}
	while (num <= 100 && num != null);		// проверка (num != null) -  null означает, что посетитель нажал «Отмена», в этом случае цикл прекратится.
Кстати, сравнение num <= 100 при вводе null даст true, так что вторая проверка необходима.


Требуется получить от пользователя значение более 100. Если 0 - повтор цикла. Если Отмена - цикл завершится.
Вариант 1
	var a;
	do {
		prompt("Введите число от 100",0);
	} while (a < 100 && a !== 0);	// НЕВЕРНО: иницилизируй переменную a=prompt...
Вариант 2
	var a;
	do { a = prompt("Введите число от 100",0);
	} while (a < 100 && a !== 0);	// НЕВЕРНО: при Отмене цикл повторяется. Используй null вместо 0.
Вариант 3
	var a;
	do { a = prompt("Введите число от 100",0);
	} while (a < 100 && a !== null);	// ВЕРНО.   * Не забудь ';' после while


____________________________________________________________________

Длина length – не количество элементов массива, а последний индекс + 1.

А лучше почитай здесь (очень годно): https://learn.javascript.ru/array

____________________________________________________________________


____________________________________________________________________

// Создание объекта из строки
var srt2obj = new String('Строка');
// String {0:"С", 1:"т", 2:"р", 3:"о", 4:"к", 5:"а", length: 6, [[PrimitiveValue]]: "Строка"}

// Строковый примитив и объект
var v1 = "10 + 15";
var v1 = new String("10 + 15");
// интерпретация в исходный код -> вычисление арифметического выражения
console.log( eval(v1) );		// 25
// .valueOf конвертирует {} в примитив
console.log( eval( v2.valueOf() ) );		// 25

eval(str) - интерпретирует строку как исходный код.
	var strPrim = '10+15',
		strObj = new String(strPrim);
	console.log(
		eval(strPrim)				// 25
		eval(strObj.valueOf())	// 25
	);
____________________________________________________________________

ЗАХВАТ ЭЛЕМЕНТОВ

Метод 1:	document.getElementById('идентификатор') - существует только в контексте объекта document.
Метод 2:	elem.getElementsByTagName('tag') - ищет все элементы с заданным тегом внутри элемента elem (вообще любого) и возвращает их в виде списка.
Метод 3:	elem.getElementsByClassName('className') - возвращает коллекцию элементов с классом className. Находит элемент и в том случае, если у него несколько классов, а искомый - один из них. Как и getElementsByTagName, этот метод может быть вызван и в контексте DOM-элемента, и в контексте документа.
Метод 4:	elem.querySelectorAll('css') - возвращает все элементы внутри elem, удовлетворяющие CSS-селектору 'css'. Один из самых часто используемых и полезных методов при работе с DOM.

Остальное здесь - https://learn.javascript.ru/searching-elements-dom

____________________________________________________________________

$(function() {
   var myModal = new jBox('Modal', {
      attach: '.oneclick',
      title: 'Быстрый заказ',
      width: 300,
      closeButton: 'title',
      content: $('.oneclick-content'),
      draggable: 'title',
      repositionOnOpen: false,
      repositionOnContent: false,
   });
})

$(document).ready(function() {
      var jBoxModal = new jBox('Modal', {
      attach: '.oneclick-btn',
      trigger: 'click',
      title: 'Быстрый заказ',
      content: $('.oneclick-content'),
      //id: 'parentID + '-'modal',
      preventDefault: true,
      responsiveWidth: true,
      responsiveHeight: true,
      width: 300,
      closeButton: 'title',
      animation: true,
      ajax: {
         getURL: 'https://ajaxresponse.com/jESSda',
         getData: 'data-ajax',
         reload: 'strict',
         setContent: true,
         spinner: true
      }
   });
});
____________________________________________________________________


____________________________________________________________________



------------------------------+
Список всех элементов указанного типа:
	document.forms|links|images
==============================+




Чтобы избежать конфликта с др. библиотеками из-за символа '$', присвоим ему новое обозначение ($j).
	var $j = jQuery.noConflict();

=================================================+

Все события можно разделить на 4 типа:
1. События браузера (window): resize, scroll etc.
2. Документа.
3. Мыши.
4. Клавиатуры.
--------------------------------------------------+
$('li').first().siblings();
.eq($('li').length - 1);
.closest('ul'); - /ближайший div/
.offsetParent(); - /ближайший позиционированный родитель/
$('#a + li') - /ближайший li на тек. уровне вложенности/
.on('event') - /позволяет слушать неск. событий и вешать неск. обработчиков/
.off('event') - /чтобы отключить обработку события/
	$(window).off() - /снять все события с window/
.one() - /разовый вызов обработчика для кажд. эл-та выборки/
.trigger() - /выполнить люб. событие и запустить его обработчик/
	$('button').trigger('click');
--------------------------------------------------+
$(function() {
	$(window).on('resize scroll', {user: 'Some string'}, function(e) {
		$('#resize-text').text('');
		$('#scroll-text').text('');
	});
// С передачей {}
	$(window).on({
		resize: function() {
			$('#resize-text').text('')
		},
		scroll: function(e) {
			$('#scroll-text').text('');
			console.log(e.data.user);
		}, {user: 'Test string'}
	})
});
==================================================+


==================================================+
Создание элементов:
==================================================+
$('<div></div>') вызывается .createElement()
$('<div><p>...</p></div>') вызывается .innerHTML=...
$('<tag>', {attr: 'val', event: func}).appendTo('parent') - вторым параметром передается {} атрибутов создаваемого тега, кот. может содержать не только атрибуты HTML-тега, но F-обработчики его событий.

Вставка узлов в DOM-дерево:
.wrap, .wrapInner, .wrapAll()- позволяет оборачивать одни элементы другими
	$('.list').wrap('<div></div>') - обернет .list
	.wrapInner('<div></div>') - обернет эл-ты внутри .list
	$('a').wrapAll('<li></li>') - сгруппирует найденные элементы, переместив их с изначальных позиций, и обернет группу целиком






Плагины для Brackets:
------------------------
Autoprefixer
Beautify
Brackets Color Picker
Brackets Icons
Brackets Sort Text
colorHints
CSSFier
Custom Region Code Folding
Emmet
Everyscrub
Indent Guidess
jQuinter
Minifier
Minimap
Overscroll
Quick Search
QuickDocsJS
QuickFormTool
quickJS
Response for Brackets
Special Html Characters