Прежде чем установить CMS, нужно создать БД и пользователя.

CMS - инф. система или комп. программа, исп. для обеспечения совместного процесса создания, редактирования и управления содержимым сайта.

Модуль - это специальная программа, кот. расширяет или изменяет стандартные возможности (ядра CMS).

=================================================================
МАССИВЫ. ФУНКЦИИ PHP:

• is_array - проверяет, является ли переменная массивом.
	echo (is_array($fred)) ? "Это массив" : "Это не массив";

• count - считает кол-во элементов на верхнем уровне. Вторым параметром (0/1) включается рекурсивный подсчет еще и всех элементов в подмассивах.
	echo count($jokes);
	echo count($jokes, 1);

• sort - сортирует исходный массив. Возвращает TRUE, если успешно. Поддерживает флаги.
	sort($fred, SORT_NUMERIC);
	sort($fred, SORT_STRING);
• rsort - реверсивная сортировка.
	rsort($fred, SORT_NUMERIC);
	rsort($fred, SORT_STRING);

• shuffle - в случайном порядке. Меняет исходный [].

• explode - на основе сепаратора разбивает строку на элементы и помещает их в [].
	$temp = explode('*', "Это*предложение*со*звездочками");

• extract - превращает пары «ключ — значение» из массива в $ PHP. Полезно при работе с $_GET и $_POST. Извлекаемые $ могут переписать уже определенные. Чтобы избежать этого, есть доп. параметр:
	extract($_GET, EXTR_PREFIX_ALL, 'prefix');	// $prefix_var

• compact - создать массив из $ и их значений. Антоним extract.
	$fname = "Doctor";
	$sname = "Who";
	$contact = compact('fname', 'sname');	// '$' не нужен
Полезна при отладке, когда нужно быстро просмотреть несколько $ с их значениями:
	$j = 23;
	$temp = "Hello";
	$address = "1 Old Street";
	$age = 61;
	print_r (compact (explode (' ', 'j temp address age')));

=================================================================



if (!isset($_COOKIE['visits']))
{
	$_COOKIE['visits'] = 0;
}
$visits = $_COOKIE['visits] +1;
setcookie('visits', $visits, time() + 3600 * 24 * 365);
include 'welcome.html.php';
-------------------------------------------------------------
Статические  веб-страницы,  которые  регулярно  генерируются  заново,  обновляя содержимое, называются полудинамическими. Если вы используете эту модель для высоконагруженных страниц своего сайта, то сможете значительно снизить требования к ресурсам веб-сервера со стороны компонентов, основанных на базе данных.
-------------------------------------------------------------
• file_get_contents. Открывает файл, считывает содержимое и возвращает его в виде строки. Файл хранится на жестком диске сервера или, как в случае с браузером, загружается по URL с помощью PHP. В случае ошибки функция возвращает FALSE.
• filе_put_contents. Открывает файл и записывает в него указанные данные. Допускает использование различных параметров 1 . Например, вы можете сделать так, чтобы файл не перезаписывался целиком (как это происходит по умолчанию), а только добавлялись данные в его конец.
• file_exists. Проверяет, существует ли файл с заданным именем. Если такого файла нет, функция возвращает FALSE.
• сору. Копирует файл.
• unlink. Удаляет файл с жесткого диска.
-------------------------------------------------------------
include_once полезно использовать с Ф., т.к. мы не можем опр. Ф > 1 раза.
-------------------------------------------------------------
if (!is_uploaded_file($_))
$file = file_get_contents($_FILES['upload']['tmp_name']);
if (!$file)
---------------------------------------------------------------------
Cоздать несколько записей одним запросом, используя (,):
INSERT INTO users (name, surname, age, sex)
   VALUES ('Alex', 'Smith', '18', 'male'),
          ('Maria', 'Vitte', '22', 'shemale'),
          ('Ivan', 'Sidorov', '20', 'male');

Или, в случае с PDO, отключить режим автоматического выполнения запросов (инициировать транзакцию):
try {
   $pdo->beginTransaction();  // инициация транзакции
   $pdo->exec($sql1);         // первый запрос
   $pdo->exec($sql2);         // остальные накапливаются
   $pdo->exec($sqln);
   $pdo->commit();      // единоразовое выполнение всех запросов
} catch (PDOException $e) {
   echo 'Произошел сбой. Причина: ' . $e->getMessage();
   $pdo->rollBack();
}
---------------------------------------------------------------------
Получить последний id:
$pdo = ...;
$sql = '...';
$pdo->exec($sql);
$last_id = $pdo->lastInsertId();
-------------------------------------------------------------




"Любая CMS - это набор задокументированных функций + архитектура".

Есть разница между одинарными и двойными кавычками.
	$test = 'Test string';
	$str1 = 'Hello world! $test!';		// Hello world! $test!
	$str2 = "Hello world! $test!";	// Hello world! Test string!
<!> Программы, в кот. исп. одинарные кавычки, работают быстрее, т.к. интерпретатору не нужно тратить время на разбор строки с "".

'include() или require()?' В случае с функцией, лучше исп. require_once(). Она включится только раз, а если не включится, мы получим ошибку. Функции не мб определены > раза.

Функция в PHP не видит глобальных var. Чтобы это исправить, нужно объявить var с ключевым словом global. Повторная инициализация не требуется.
	$x = 10;
	function test() {
		global $x;
		echo $x;
	};
Локальные var функции не видны за ее пределами.

Интересная область видимости: static. Ключевое слово static говорит, что после выполнения функции нужно сохранить значение данной var.
	function test() {
		static $z=0;
		$z++;
		echo $z.'<br>';	// при последующих вызовах значение $z будет +1
	};

$GLOBALS - глобальный массив var. По умолчанию PHP при определении и инициализации var помещает их значения в глобальный массив. Т.о. через $GLOBALS можно обращаться к var.
	echo $GLOBALS['x'];
Можно вывести содержимое $GLOBALS с помощью команды print_r:
	print_r($GLOBALS);


ВЫВОД ИНФОРМАЦИИ
	$var1 = "Значение 1";
	$var2 = "Значение 2";

	echo $var1;
	echo($var1);
	echo($var1,$var2);    // Ошибка
Есть нюанс с двойными и одинарными кавычками:
	echo("$var1");
	echo('$var1');			// $var1
	echo("$var1,$var2");
	echo('$var1,$var2');    // $var1,$var2
	echo "Выводим значение переменной var1: $var1";	// обрати внимание на "... $var"
	echo "Один текст: $var1 <br>", "Другой текст: $var2";
Когда исп. echo с (), мы можем вывести только 1 var или 1 строку с неск. var.
	echo($var1, $var2); 	// Ошибка! Можно только 1 var
	echo ("Значение первой переменной: $var1 <br> Значение второй: $var2");
	echo("Выводим: ".$var1); 	// сработает четко	// можно в и ' '

Можно вставить var из другой var.
	$var1 = "Значение 1";
Способ 1:
	$var = $var1;
	echo($var); 	// Значение 1
Способ 2:
	$var = 'var1';
	echo("${$var}");	// Значение 1


Вывод значения МАССИВА:
	echo("$array['key']");		// Ошибка!
	echo($array['key']);	// value
	echo("{$array['key']}");	// value - (когда хотим вывести и текст и значение var)
	echo("Значение массива: {$array['key']}");	// Значение массива: value

Также есть команда вывода 'print'. Но в отличии от echo, 'print' не может принимать несколько значений через запятую, потому что не понимает их. Но есть выход: исп. точечную конкатенциюпри перечислении значений.
	print("Значение массива: {$array['key']}");	// Значение массива: value
	print "Текст 1: {$array['key']}"."<br>"."Текст 2: {$array['key']}";
C запятой будет ошибка:
	print "Текст 1: {$array['key']}","<br>","Текст 2: {$array['key']}";

	// echo "Значение массива: {$array['key']}";
	// echo "Значение первое","Значение второе";
	// echo ("Значение массива: {$array['key']}");
	// echo ("Значение первое, Значение второе");
	// echo ("Значение первое, <br> Значение второе");

Еще один способ вывода значения переменной: <?=$var?>. Как правило, это исп. для подстановки в HTML-код:
	<?php
	$array = array('key' => 'Содержимое параграфа');
	?>
	<p><?=$array['key']?></p>	// в документе выведется значение ключа массива

--------------------------------------------------------------------------------------------------------------------

ИТОГО:

'echo' просто выводит текст, значение var и т.д.
'print' может исп. как функция, кот. возвращает 1.
	$var = 'someValue';
	if (print ($var)) {		// если 1 или true		// (!print ($var)) - наоборот
		echo "Условие выполнено!";
	};

__________________________________________________________________________________

Ресурсы в PHP - это такие интерфейсы, вроде посредников между PHP и к-то внешними ресурсами.
__________________________________________________________________________________

КОНСТАНТЫ

Константы создаются с помощью предопределенной функции 'define()'. У нее есть 2 парамметра:
имя константы и значение.
	define('CONSTANT_NAME', '1.0');

Значение константы задается 1 раз и не может меняться, однако имя менять можно.

В PHP есть встроенные, "волшебные", К. Они обособляются 2-м подчеркиванием.
	define('__CLASS__');
_______________________________________________________________________________________

ОПЕРАТОРЫ

Бинарный оператор 'xor' применяется, когда только один из операндов должен вернуть true, либо все сразу.
	$a = true;
	$b = false;
	$c = true;
	if ($a xor $b)		// true:   true || false
	if ($a xor !$b)		// false:   true || true
	if ($a xor (!$b xor $c))	// true:   true || true || true
	if (!$a xor !$b xor $c)	// false:   false || true || true
	if (!$a xor !$b xor !$c)	// true:   false || true || false

Строковые операторы:
	'.' - конкатенация
	',' - комбинация
	'.=' - присваивание и конкатенация

Пример:
	$string = 'Привет, ';
	$string .= 'Владимир';
	echo $string;
	echo '<p>'.$string.'</p>';
	echo '<p>'.'Владимир'.'</p>';


ОПЕРАТОРЫ МАССИВОВ (+, ==, != / <>, ===, !==)

Результатом конкатенации двух вложенных массивов будет массив с полным набором предложенных свойств, за исключением свойств-дубликатов.
	$array_1 = array(
		'id' => 'Value 1',
		'title' => 'Value 2'
	);
	$array_2 = array(
		'id' => 'Value 3',
		'title' => 'Value 4',
		'slug' => 'Common value'
	);
	echo '<pre>';
	print_r($array_1 + $array_2);
	echo '</pre>';
Получим:
	Array
	(
		[id] => Value 1
		[title] => Value 2
		[slug] => Common value
	)


	$array1 = ['id' => 'Value 1', 'title' => 'Value 2'];
	$array2 = ['id' => 'Value 1', 'title' => 'Value 2'];
	if ($array1 == $array2) {echo 1;} else {echo 0;}


_______________________________________________________________________________________

Подчключение PHP-файлов (require, include)

Когда index.php включает файл header.php, он также наследует всю его область видимости. Т.е. подключаемые файлы обоюдно наследуют scope друг друга.
Файлы PHP могут подключаться глобально либо в рамках функции.
	require 'app/footer.php';

'include()' хорошо исп., когда к-то файл дб подключен, но мб и не подключен.

_______________________________________________________________________________________

УСЛОВНАЯ УПРАВЛЯЮЩАЯ КОНСТРУКЦИЯ if

// Не true синтаксис:
	<?php
	$menu_items = array();
	if (count($menu_items)){
		echo '<li><a href="#">Пункт 1</a></li>';
		echo '<li><a href="#">Пункт 1</a></li>';
	} elseif (count($menu_items)>3) {
		echo 'Количество элементов массива меньше 2';
	} else {
		echo 'Other';
	}
	?>
// true синтаксис:
	<?php if (count($menu_items)): ?>
	<li><a href="#">Пункт 1</a></li>
	<?php elseif (count($menu_items)): ?>
	<?php endif; ?>

Тернарный оператор:
	$menu_items = array();
	count($menu_items) ? $menu_items = 10 : $menu_items = 0;
	$menu_items = count($menu_items) ? 10 : 0;

_______________________________________________________________________________________

МАССИВЫ

М бывают гомогенными и гетерогенными. В первом случае все элементы содержат одинаковый тип данных, во втором - разные.

М бывают индексированными (1) и ассоциативными (2). В индексированном массиве элемент вызывается посредством индекса, в ассоциативном - посредством ключа.
(1)	$my_array = array('val1', 'val2', 'val3');
(2)	$my_array = array(
		'key1' => 'val1',
		'key2' => 'val2',
		'key3' => 'val3'
	);
-----------------------------------------------------------
Массив индексированный двумерный:
	$category_1 = array (
		'category_id' => 1,
		'category_title' => 'Путешествия',
		'category_slug' => 'travel'
	);
	$category_2 = array (
		'category_id' => 2,
		'category_title' => 'Жизнь',
		'category_slug' => 'life'
	);
	$categories = array ($category_1, $category_2);
	?>
	<pre>
		<?= print_r($categories)?>
		или так
		<?=$categories[1]['category_title']?>
	</pre>
-----------------------------------------------------------
Массив, содержащий неск. массивов:
	$category_1 = [
		'category_id' => 1,
		'category_title' => 'Путешествия',
		'category_slug' => 'travel',
	];
	$category_2 = [
		'category_id' => 2,
		'category_title' => 'Жизнь',
		'category_slug' => 'life',
	];
	$categories = [
		$category_1,
		$category_2,
		['category_id' => 3,
		'category_title' => 'Спорт',
		'category_slug' => 'sport']
	]; ?>
	<pre>
	<?= print_r($categories)?>
	</pre>

_______________________________________________________________________________________

ЦИКЛЫ

1. while()
	$i = 0;
	while($i <= 6) {
		$i++;
		echo '<li><a href="#">Пункт'.' '.$i.'</a></li>';
	}

2. for()
	for ($i = 1, $count = count($categories); $i <= $count; $i++) {		// + можно добавить шаг ,$count++
		echo '<li><a href="#">'.'Пункт '.$i.'</a></li>';
	}

3. foreach($массив_для_обхода as $var) - специализированный цикл для массивов в PHP.
	foreach ($categories as $category) {	// каждый элемент categories[] заносится в $category
	echo '<li><a href="#">Пункт</a></li>';
	}
---------------------------------------------
	foreach ($categories as $category) {
	echo '<li><a href="/category.php?id='.$category["category_id"].'">'.$category["category_title"].'</a></li>'; }
Компактный синтаксис:
	<?php foreach ($categories as $category): ?>
		<li><a href="/category.php?id='<?= $category["category_id"] ?>'"><?= $category["category_title"]?></a></li>
	<?php endforeach; ?>
_______________________________________________________________________________________









PHP [Lynda.com]

PHP позволяет создавать динамические страницы, содержимое кот. может меняться в зависимости от обстоятельств, как то: взаимодействие с польз. или хранилищем данных в БД. PHP - это "заряженная" версия HTML.

The Stack
	LAMP. WAMP, MAMP, XAMP
		Linux, Windows
		Apache
		MySQL
		PHP
_______________________________________________________________________________________

ВЫВОД ДИНАМИЧЕСКОГО ТЕКСТА

Главной отличительной особенностью PHP явл. возможность выводить динамический текст. Именно это отличает сайт на PHP от сайта на HTML.

Команда/функция 'echo' - выводит то, что запросит пользователь. Это эхо, кот. отзывается.
	<?php echo "Hello World!"; ?><br/>
	<?php echo "Hello"." World!"; ?><br/>
	<?php echo 2+3; ?><br/>	// 5

_______________________________________________________________________________________

ОТСЛЕЖИВАНИЕ ОПЕРАЦИЙ

'Цикл запрос-ответ в PHP' описывает коммуникацию между браузером и сервером в процессе обработки запроса пользователя.

Цикличный процесс:
От браузера через сервер мы обращаемся к файловой системе. Обрабатываем файл, обращаясь к БД столько раз, сколько требуется для обработки, и в итоге генерируется HTML, кот. отправляетсяо братно в браузер.
PHP обрабатывается сразу, когда Apache получает нужный файл. Этот процесс называется 'циклом запрос-ответ'.
Многое из того, что мы изучим (например, редирект заголовка, буферизация вывода, настройка куков) осуществляется в этом цикле.
_______________________________________________________________________________________

ПЕРЕМЕННЫЕ

П - это символическое представление значений. Можно сказать, что это обозначение, кот. на что-то ссылается.

Если файл имеет расширение .php, значит, в него можно поместить php-код.

Установим символическое указание от var к числу 10:
	$var1 = 10;
Переменная $var1 теперь указывает на число 10. Если мы будем говорить о $var1, мы будем говорить о 10. Если 'echo $var1;',	то 10.
	<?php
		$var1 = 10;
		echo $var1;
		echo '<br>';
		$var1 = 100;
		echo $var1;
	?>

Переменные могут указывать на что угодно, это просто символическое представление чего-то большего.


СТРОКА

	$greeting = "This string";
	$target = "has ended.";
	$phrase = $greeting + $target;		// 0
	$phrase = $greeting . $target;		// This stringhas ended.
	$phrase = $greeting ." ". $target;	// This string has ended.

<!> HTML-теги следует помещать вне php-кода либо внутрь, исп. echo "<tag>".
<!> Переменная не определяется внутри 'одинарных' кавычек.
	echo '$phrase <br/>';	// $phrase + красная строка
	echo "$phrase <br/>";	// This string has ended. + красная строка
	echo "$phraseAgain<br/>"; 	// Undefined variable + redS
	echo "{$phrase}Again<br/>";	// This string has ended.Again + redS
	echo "\{$phrase /}Again";   // \{This string has ended. /}Again

_______________________________________________________________________________________

ФУНКЦИИ СТРОК

Еще 1 способ конкатенации:
	$first = "The quick brown fox";
	$second = " jumped over the lazy dog.";
	$third = $first;
	$third .= $second;	// The quick brown fox jumped over the lazy dog.

	<?php echo strtolower($third); ?>
	strtolower() - это имя функции, и функции часто принимают что-то как аргумент: они вводят что-то в функцию, возвращая как результат. В примере выше сначала выполниться функция strtolower(), затем ее результат будет передан функции echo. Т.о. мы с помощью 1 функции обращаемся к другой.

-------------------------------------------------------------------
$third = "The quick brown fox jumped over the lazy dog.";

Lowercase: 			<?php echo strtolower($third);?>		// the quick brown fox jumped over the lazy dog.
Uppercase: 			<?php echo strtoupper($third);?>		// THE QUICK BROWN FOX JUMPED OVER THE LAZY DOG.
Uppercase first: 		<?php echo ucfirst($third);?>			// The quick brown fox jumped over the lazy dog.
Uppercase words: 	<?php echo ucwords($third) ;?>		// The Quick Brown Fox Jumped Over The Lazy Dog.

Length:				<?php echo strlen($third) ;?>									// 45
Trim:					<?php echo "A". trim(" B C D "). "E" ;?>						// AB C DE
Find:					<?php echo strstr($third, "brown") ;?>							// brown fox jumped over the lazy dog.
Replace by string:	<?php echo str_replace("quick", "super-fast", $third) ;?>		// The super-fast brown fox jumped over the lazy dog.

Repeat:			<?php echo str_repeat($third, 2);?>		// 2x The quick brown fox jumped over the lazy dog.
Make substring:	<?php echo substr($third, 5, 10);?>		// uick brown
Find position:		<?php echo strpos($third, "brown");?>	// 10
Find character:	<?php echo strchr($third, "z");?>			// zy dog.
_______________________________________________________________________________________

ЦЕЛЫЕ ЧИСЛА / INTEGERS

	$var1 = 3;
	$var2 = 4;

Basic Math:			<?php echo (1+2+$var1) * $var2 / 2 - 5 ;?>	// 7
Absolute value:		<?php echo abs(0 - 300);?>					// 300
Exponential:			<?php echo pow(2,8);?>	// степень		// 256
Square root:			<?php echo sqrt(100);?>						// 10
Modulo:				<?php echo fmod(20, 7);?>	// func по %		// 6
Random:				<?php echo rand();?>							// 10139
Random (min, max):	<?php echo rand(1, 10);?>						// 6

Приращение:
// изначально $var2 = 4, но с каждым вычислением значение меняется
+=  <?php  $var2 += 4;  echo $var2;  ?>   // 8
-=   <?php  $var2  -= 4;  echo $var2;  ?>   // 4
*=   <?php  $var2  *= 3;  echo $var2;  ?>   // 12
/+   <?php  $var2  /= 4;  echo $var2;  ?>   // 3

Increment 1:	<?php $var2 += 1; ?>
Increment 2:	<?php $var2++; ?>
Decrement:	<?php $var2--; ?>

При сложении числа со строкой, содержащей число, строка преобразуется в число, а прочие символы отбрасываются. Это "небрежное программирование".
	echo 1 +"2 houses"; 	// 3

_______________________________________________________________________________________

НЕЦЕЛЫЕ или ПЛАВАЮЩИЕ ЧИСЛА

Целые и плавающие числа хранятся в памяти по-разному.

	echo $float = 3.14;
	echo $float + 7;		// 10.14
	echo 4 / 3;				// 1.3333333333333
	echo 4 / 0;				// Ошибка!

'Округление'. Сколько знаков после запятой?
	$float = 3.14;
	echo round($float, 1);	// 3.1
	echo ceil($float);			// 4 - округление в > сторону
	echo floor($float);		// 3 - округление в < сторону

Есть проверка на целое, плавающее и просто число:
<?php
    $float = 3.14;
    $integer = 3;
    echo "Is {$integer} integer? " . is_int($integer) ."<br/>";		// 1
    echo "Is {$float} integer?" . is_int($float) ."<br/>";

    echo "Is {$integer} float?" . is_float($integer) ."<br/>";
    echo "Is {$float} float?" .is_float($float) ."<br/>";				// 1

    echo "Is {$integer} numeric?" . is_numeric($integer) ."<br/>";	// 1
    echo "Is {$float} numeric?" . is_numeric($float) ."<br/>";			// 1
    ?>

_______________________________________________________________________________________

МАССИВЫ

М - это упорядоченная коллекция объектов с целочисленными индексами.
Проще говоря, мы можем взять объект, например, strings или integers, сгруппировать их и держать их позиции в группе в опр. порядке, чтобы мы могли обращаться к ним, исходя из их позиций.
Можно представить массив как выдвижной ящик с множеством секций. Каждая секция пронумерована и может содержать документ (значение). При обращении к массиву по указываем номер секции и получем документ из нее.
Массив мб привязан к var, что упрощает задачу в случае обращения к большой коллекции инфы, просто исп. имя var.

Для присваивания var массива исп. ключ array.
	$numbers = array();
	// Задан пустой массив (без объектов), привязанный к var numbers
	$numbers = array(4, 8, 15, 16, 23, 42);
	// Теперь он содержит числовые значения, кот. можно извлечь по индексу
	echo $numbers[1];	// 8

При работе с [] можно исп. функцию 'print readable' (отобразить читаемое). Это хороший способ исправить неполадки и увидеть, что внутри массива.
	echo print_r($mixed);

Массив может содержать разные типы объектов:
	$mixed = array(6, "fox", "dog", array("x", "y", "z"));
	echo $mixed[3][2];	// z
Изменим значение объекта по индексу 2:
	$mixed[2] = "cat";
Есои неизвестна длина массива, можно добавить значение в конец:
	$mixed[] = "last val";

"C помощью возможностей массива мы можем присвоить большой совокупности данных 1 единственную var. Представьте, что у нас есть 1000 emails, нам бы не хотелось создавать для них 1000 var. Вместо этого мы можем назначить для них массив и потом исп. 1 единственную var, чтобы извлекть каждый email по своему индексу по одному".

"Массив хранит инфу в опр. порядке, пока мы его не измеим. Он хорош, чтобы хранить ul. Мы можем отсортировать всю 100 emails, и в массиве они будут храниться в нужном нам порядке. Вы можете представить, как нам будет помогать массив, когда мы начнем извлекать данные из БД? Мы можем отыскать 50 объектов, отсортированных в алфавитном порядке по фамилии и хранить их в массиве".

В PHP 5.4 добавлена короткая запись synt массива (не раб. в > ранних версиях):
	$array = [1,2,3];

_______________________________________________________________________________________

АССОЦИАТИВНЫЙ МАССИВ

АМ - объектно-индексированная коллекция объектов. Он не упорядочен, т.к. не имеет числовой индексации, вместо них - метки.
	$assoc_array = array("key" => "val", "key2" => "val2");

Проводя параллель с картотекой, вместо пронумерованной секции - секция с меткой (ключ). Документ в АМ - это значение. Комбинация метки и значения называется 'пара ключ-значение'.

Всегда имеется последовательность из ключей и значений, кот. содержатся в АМ.

Когда важен порядок объектов, исп. обычный массив. Когда порядок не важен, а важно удобство работы с метками, исп. АМ.
Например, если у нас есть 100 клиентов, нам удобней хранить и в []: порядок этих клиентов нам важен. Но инфу о каждом клиенте я хочу хранить в АМ.

	// вместо индексирования по позиции - индекс. по ключу
	echo $assoc_array["key"];	// val

Присваивание как в обычном массиве, только не по индексу, а по ключу.

У обычного и ассоциативного массивов очень много общего:
	$numbers = array(4, 8, 15, 16, 23);
	$numbers = array(0=>4, 1=>8, 2=>15, 3=>16, 4=>23);

_______________________________________________________________________________________

ФУНКЦИИ МАССИВОВ

	$numbers = [2,23,15,42,16,4];
	echo count($numbers);	// 6 - кол-во объектов
	echo max($numbers);	// 42
	echo min($numbers);	// 2

Sort:             <?php echo sort ($numbers);   print_r($numbers) ?>
Reverse sort:  <?php echo rsort ($numbers);  print_r($numbers) ?>
<!>Обе функции являются деструктивными, т.е. вносят конечные изменения в исходный массив. При повторном вызове мы получим массив измененного вида.
<!> При сортировке строк, те выстроятся по алфавиту.

'Как превратить массив в строку?'
Т.е. скомбинировать значение, чтобы получить строку? Для этого предусмотрена функция implode("разделитель между элементами", $array):
	$numbers = array(2, 4, 15, 16, 23, 42);
	echo $num_string = implode(" * ", $numbers);	// 2 * 4 * 15 * 16 * 23 * 42

'Как превратить строку в массив?'
explode() - противоположность implode(). Каждый раз, как обнаружится строка " * ", она будет исп. как разделитель при создании нового элемента массива.
	print_r(explode(" * ", $num_string));
	// Array ( [0] => 2 [1] => 4 [2] => 15 [3] => 16 [4] => 23 [5] => 42 )

'Находится ли данный элемент в [ ]? Содержит ли массив это значение?'
	echo in_array(15, $numbers);	// 1

_______________________________________________________________________________________

БУЛЕВЫ

true = 1
false = пусто

Проверка на Boolean:
	echo is_boolean($true_or_false_boolean);	// 1

Булины наиболее полезны при работе с условиями.

_______________________________________________________________________________________

NULL

NULL - это отсутствие значения.

	$var1 = null;
	$var2 = "";
	echo  is_null($var1);	// 1
	echo  is_null($var2);	// empty
	echo  is_null($var3);	// 1 + Notice: Undefined variable

'Как выяснить, определена ли var?'
	echo  isset($var1);	// empty
	echo  isset($var2);	// 1
	echo  isset($var3);	// empty

"Иметь значение NULL все равно, что не быть определенной, но это не совсем одно и то же".

В PHP за 'empty' мб принято:  "",  null,  0,  0.0,  "0",  false,  array().
	$var3 = "0";
	echo  empty($var1);	// 1
	echo  empty($var2);	// 1
	echo  empty($var3);	// 1

_______________________________________________________________________________________

ПРЕОБРАЗОВАНИЕ И ПРИВЕДЕНИЕ ТИПОВ

Мы видели, как PHP конвертирует функцию булевого типа true в строку "1", когда выводит ее на страницу. Это 'жонглирование или преобразование типов', когда PHP делает это для нас находу.
Можно самим задать тип напрямую - это называется 'кастинг' или 'приведение'.

Есть 2 способа приведения:

1. Функция settype(), содерж. два аргумента: 1) элемент, кот. будет приведен к др. типу, и 2) тип, кот. хотим установить.
	settype($var, "integer");
2. Или просто написать желаемые тип в скобках перед элементом, кот. будет приведен. Здесь integer - это не строка, а инструкция для PHP.
	(integer) $var
Типы, кот. можем использовать, значения, кот. можем предоставлять для приведения, - это те типы, кот. недавно рассматривали:
	string   int   integer   float   array   bool   boolean

	settype($count, "integer");	// приведение типа 1
		echo gettype($count);
	$count2 = (string) $count;	// приведение типа 2
		echo gettype($count2);

<!>Важно:
settype() - выполняет замещение: воздействуя на var, меняет ее тип. Т.е. преобразует с заменой.
В случае с '(type) $var' этого не происходит. Например:
	$test1 = 3;
	$test2 = 3;
	settype($test1, "string");
	(string) $test2;
	echo gettype($test1);	// string
	echo gettype($test2);	// integer
Тип $test2 не изменился, потому что это изменение не последнее, оно имеет место как 1 из действий, а в случае с $test2 - как конечное действие. Конвертирование происходит во время назначения, это не пермонентное изменение для самого элемента. Важно отдавать отчет, что перед нами: integer или string? Мы исп. приведение, когда нужна конвертация одного тип в другой.

_______________________________________________________________________________________

КОНСТАНТЫ

К - противоположность переменным. Если var могут менять значение, то К - нет. Они пишутся в ВЕРХНЕМ регистре и без $. Значение К нельзя изменить или переопределить.

Единственный способ задать постоянное значение - исп. определяющую функцию. Нельзя просто исп. =, чтобы задать значение.
	$max_width = 980;				// переменная
	define("MAX_WIDTH", 980);		// постоянная
	echo MAX_WIDTH;				// 980
При определении К мы исп. "", но дальнейшая работа с К проводится без них. Кавычки исп. только при опр К.

Вспомните схему, кот. мы рассм., изучая цикл запрос-ответ. Когда наш скрипт начинает работу, он находит опр. постоянную. Она остается опр., пока скрипт не отобразит HTML пользователю. Но в этот момент К отключается, все в нашем коде откл до след. цикла запрос-ответ. К установлена и не меняется во время выполнения PHP-скрипта, ее значение фиксировано.
Когда она пригодится? Допустим, есть путь к файлу, кот. хотите закрепить...3

_______________________________________________________________________________________

УСЛОВНЫЕ ВЫРАЖЕНИЯ

	if (expression) statement;

Выражение может принимать булевое значение.

_______________________________________________________________________________________

ЛОГИЧЕСКИЕ ОПЕРАТОРЫ

Присваивание	=
Равенство		==
Тождество		===
Сравнение 		> < >= <= <>(больше или меньше)
Не равно 		!=
Тожд. не равно	!==

and:	&&
or:		||
not:	!


"Скажем, у нас есть форма, принимающая инфу, и мы не хотим, чтобы значение 0 и 0.0 отклонялись, будучи допустимыми. Мы можем сказать: 'Если значение не введено, т.е. поле пустое, или введено не в числовом формате, то echo...' Если поле не пустое, и значение числовое"
<?php
	// don't reject 0 or 0.0
	$quantity = null;
	if (empty($quantity) && !is_numeric($quantity)) {
		echo "You must enter a quantity.";
	}
;?>

__________________________________________________________________________________

ОПЕРАТОРЫ switch

Похожи на условные операторы тем, что они управляют потоком кода в приложении.

Имя функции switch. За ним аргумент - значение, кот. будет сверяться с каждым контрольным примером. В {} - список контр. примеров. Каждый начинается с case, далее идут тестовые значения, с кот. будет сравниваться НАШЕ значение, а после инструкции, кот. следует выполнить. Если ни с одним из значение НАШЕ не совпадет, выполнится инструкция default.
Заметьте, что процесс прохождения через каждый из примеров и сверка на каждом этапе. Очень похоже на if...else и elseif. Разница в том, что мы тестируем значение на равенство.
	switch (value) {
		case test_value1: statement;
		case test_value2: statement;
		default: statement
	}
Сравнение на равенство - простое. Обычно мы не работаем с булевым типом, а вот со строками - часто! С ними можно делать многое.

'Наткнувшись на первое совпадение, switch выполнит его и все следующие за ним утверждения'.
switch выполняет инструкцию из совпадения, а затем он принимает за совпадение каждый пример, кот. идет после. Если мы не хотим такого поведения, нужно добавить оператор break.
	$a = 3;
	switch ($a) {
	case 0: echo "a equal 0"; break;
	case 1: echo "a equal 1"; break;
	case 2: echo "a equal 2"; break;
	case 3: echo "a equal 3"; break;
	case 4: echo "a equal 4"; break;
	default: echo "a is not 0, 1, 2, 3, 4";


	$year = 2013;
	switch (($year - 4) % 12) {
		case  0:	$zodiac = 'Rat';		break;
		case  1:	$zodiac = 'Ox';		break;
		case  2:	$zodiac = 'Tiger';		break;
		case  3:	$zodiac = 'Rabbit';	break;
		case  4:	$zodiac = 'Dragon';	break;
		case  5:	$zodiac = 'Snake';	break;
		case  6:	$zodiac = 'Horse';	break;
		case  7:	$zodiac = 'Goat';		break;
		case  8:	$zodiac = 'Monkey';	break;
		case  9:	$zodiac = 'Rooster';	break;
		case 10:	$zodiac = 'Dog';		break;
		case 11:	$zodiac = 'Pig';		break;
	}
	echo "{$year} is the year of the {$zodiac}.";


	$user_type = 'customer';
	switch ($user_type) {
		case 'student':	echo "Welcome!";	break;
		case 'press':		echo "Greetings!";	break;
		case 'customer':	echo "Hello!";			break;
	}
	Если мы хотим, чтобы для 'press' и 'customer' выполнялась одна инструкция, поставь их рядом и удали инструкцию у вышестояшего примера.
	case 'student': echo "Welcome!"; break;
	case 'press':
	case 'customer': echo "Hello!"; break;

__________________________________________________________________________________

ЦИКЛЫ

Циклы позволяют писать код, кот. будет выполняться больше 1 раза, без необходимости прописывать код снова и снова. Код выполнится раз, затем вернется к началу и выполнится снова, причем каждый новый раз не означает выполнение того же самого. Значение var может меняться после каждого цикла, так что логические значения в цикле выполняют разные задачи.

<!> 2 важные вещи относительно цикла:
1) Для цикла нужно условие - выражение, кот. позволит ему выполняться.
2) Что-то в условии должно изменяться в ходе выполнения каждого цикла.
Если этого нет, мы получим бесконечный цикл.

1. while

	while ( выражение-аргумент ) {	// оценивается как true или false
		инструкция;		// то, что будет выполняться снова и снова, пока выражение true
	}

	while ($count <= 10) {
		echo $count;
		$count += 1;
	}

'В цикле while приращение опционально: может быть или нет'.

2. for
То же, что в JS.
	for ( $count = 20; $count >= 1; $count-- ) {
		if ($count % 2 == 0) {
			echo "{$count} - четное<br/>";
		} else {
			echo "{$count} - нечетное<br/>";
		}
	}

3. foreach

Отличается от предыдущих тем, что не имеет условия и нет механизма для приращения. Данный цикл работает с массивами, с каждой позицией [], пока не дойдут до конца. Циклы while и for не остановятся и продолжат работу, пока заданные условия выполняются. foreach не завершится, пока не закончатся позиции в []. Конец [] - конец цикла.

Все, что мы делаем, это говорим: "Присваивай каждое значение var и выполняй цикл".

	foreach ($array as $value) {
		statement;
	}
	// $array - рабочий массив
	// as - спецслово
	// $value - каждый раз, проходя цикл, этой var будет = каждое значение из нашего []

'foreach возьмет массив, на кот. указывает $ages, и каждое значение массива будет временно задано $age. В ходе каждого цикла у нас будет доступ к $age'.
	$ages = [4, 8, 15, 16, 25, 34];
	foreach ($ages as $age) {
		echo "Age: {$age}<br/>";
	}
"Представьте, что у вас есть список из 15 последних заказов пользователя, кот. нужно ему вывести. foreach начнет с начала списка, обработает каждый из них и, дойдя до конца, - готово!"


Чтобы цикл foreach работал с ассоциативными [], нужно изменить его синтаксис:
	foreach ( $array as $key => $value ) {
		statement;
	}

	$person = [
		"first_name" => "Vladimir",
		"last_name" => "Khaprov",
		"address" => "Agapkina 22",
		"city" => "Tambov",
	];
	foreach ($person as $attributes => $data) {
		$attr_nice = ucwords (str_replace ("_", " ", $attributes));
		echo "{$attr_nice}: {$data}<br/>";
	}

__________________________________________________________________________________

ФУНКЦИЯ continue

	for ($count = 0; $count <=10; $count++) {
		if ($count == 5) {continue;}		// говорит начать цикл с начала
		echo $count ." ";	// 0 1 2 3 4 6 7 8 9 10
	}

Выведем только нечетные числа:
	for ($count = 0; $count <=10; $count++) {
		if ($count  % 2 == 0) {continue;}		// говорит начать цикл с начала
		echo $count ." ";	// 1 3 5 7 9
	}

Как только код доходит до continue, цикл начинается с начала. continue говорит: "Здесь закончили, двигаемся дальше!"

for ($i=0; $i<=5; $i++) {
	if ($i % 2 == 0) { continue(1); }   // вернись на 1 цикл назад
		for ($k=0; $k<=5; $k++) {
			if ($k == 3) { continue(2); }	// вернись на 2 цикла назад, к первому for
			echo $i . "-" . $k . "<br/>";
	}
}

continue прерывает выполнение цикла и запускает его сначала - инициирует новую итерацию цикла. break прерывает цикл полностью, после чего интерпретатор спускается вниз по коду.

__________________________________________________________________________________

ФУНКЦИЯ break

Это такой режиссер, кот. после неск. прослушиваний говорит: "Вот оно! Вы получаете работу. Все остальные прослушивания отменяются". break останавливает весь процесс.

В случае, если цикл, содержащий break, находится внутри другого цикла, то при срабатывании break прервется выполнение только внутреннего цикла.
	Если
		for () {
			...
			for () {
				...
				break;		// прервет только внутренний цикл
				break(2);	// апнет на 2 lvl и прервет внешний цикл
			}
		}
	то break прервет выполнение только внутреннего цикла.

<!> Наблюдение <!>
В JS циклам задаются 'метки:', в PHP - функциям дописывается аргумент, поднимающий выполненеи цикла на неск. уровней: continue(1) - значит, продолжать выполнение через 1 цикл выше.

__________________________________________________________________________________

УКАЗАТЕЛИ МАССИВА

"По сути мы говорим, возьми значение, на кот. указывает курсор [], привяжи его к $ages и, если это действительно к-то значение, то выполняй цикл. Если ни какого значения не оказывается, то завершай цикл. Конечно, внутри [] у нас имеется инкремент - next(), кот. перемещает указатель на след. позицию, чтобы current() мог извлечь что-то новое с каждым циклом".
	while ( $age = current($ages) ) {
		echo $age . ", ";
		next($ages);
	}

Похожий процесс при работе с БД: мы будем отыскивать много инфы в БД, как в [], и будем передвигаться в базе по рядам, перемещая курсор во время движения. foreach для этого не подходит, поскольку курсор в БД не такой, как курсор в массиве. Подобный, но не такой.

__________________________________________________________________________________

ФУНКЦИИ

Ф - это код, кот. выполняет конкретную задачу. Код, упакованный в единый блок, чтобы по необходимости вызывать его для выполнения задачи.

Мы задаем для функ данные и аргументы для работы, и функ возвращает нам запрошенные данные. Основное назначение функ - предоставлять ей входные данные и получать взамен выходные.

"Мы как бы говорим PHP взять этот блок кода в {} и придержать его на случай необх. Когда я обращусь за ним по имени функции, возьми входные данные, что я ввел, и выполни код, и верни мне выходные данные".

<!> Функцию НЕЛЬЗЯ переопределять.

Отличная практика: работая с функциями, всегда иметь возвращенное значение.
	return $result;

ВАЖНО: return прерывает выполнение функции, как continue - выполнение цикла.

'Лучше оставлять оператор echo за пределами функции, а вместо него исп. возврат значения (return). Так больше гибкости.'

__________________________________________________________________________________

ВОЗВРАТ МНОЖЕСТВА ЗНАЧЕНИЙ

Функция возвращает только одно значение - это строгое правило. Однако, в качестве значения можно исп. массив.

Вариант вывода 'НЕОЧЕНЬ':
	function add_subt($val1, $val2) {
		$add = $val1 + $val2;
		$subt = $val1 - $val2;
		return [$add, $subt];
	}
	$result = add_subt( 10, 5 );
	echo "Add: " . $result[0] . "<br/>";
	echo "Subt: " . $result[1] . "<br/>";

Вариант вывода с функцией list(). Используем list(), чтобы присвоить значение [] переменной.
	list( $add_result, $subt_result ) = add_subt( 20, 7 );
	echo "Add: " . $add_result . "<br/>";
	echo "Subt: " . $subt_result . "<br/>";

Я думаю, list() очень удобна, т.к. позволяет брать любые элементы, кот. мы только что упаковали в [], извлекать их из функций, а также немедленно возвращать нам и присваивать зачения var, кот. можно дать оч понятные имена.

__________________________________________________________________________________

УСТАНОВКА ЗНАЧЕНИЙ АРГУМЕНТОВ ПО УМОЛЧАНИЮ

Обычная установка значения:
	function paint($color) { return "The color of the room is {$color}.<br/>"; }
	echo paint("blue");	// The color of the room is blue.

По умолчанию:
	function paint ( $room="office", $color="red" ) {
		return "The color of the {$room} is {$color} . <br/>";
	}
	echo paint();		// The color of the office is red.
или
	function paint ( $room="office", $color="red" ) {
		return "The color of the {$room} is {$color} . <br/>";
	}
	echo paint();						// The color of the office is red.
	echo paint("bedroom", "blue");	// The color of the bedroom is blue.
	echo paint("bedroom", null);	// The color of the bedroom is .
	echo paint("bedroom");			// The color of the bedroom is red.

__________________________________________________________________________________

ССЫЛКИ И URL

Запрос начинается с браузера, двигается на сервер, сервер обрабатывает наш PHP и возвращает в браузер HTML-страницу. Это цикл запрос-ответ.
На сервере ничего не произойдет, если пользователь не отправит к-нибудь инфу. Для этого есть 3 способа:
1) URL и ссылки  (получают запрос GET)
2) Формы с кнопкой Submit  (отправляют запрос POST)
3) Cookies  (COOKIE - способ получить инфу на кажд. запрос)

__________________________________________________________________________________

ИСПОЛЬЗОВАНИЕ ЗНАЧЕНИЯ GET

Как посылать запросы от 1 страницы к след., исп. параметры запроса URL?

Параметры запроса - это часть URL, кот. идет после '?'. Это предоставление доп. параметра, в кот. нуждается страница.

Формат всегда такой:
	имя_параметра=значение_параметра
	somepage.php?page=2
Часто эти параметры корректируют поведение кода, генерируя возврат HTML.

Можно послать больше параметров, исп. '&':
	somepage.php?category=7&page=3

Когда бы ни был сделан запрос на страницу, PHP автоматом берет все параметры запроса, отправленные с URL, и помещает их в ассоциативный массив, где мы можем получить к ним доступ. Такой массив называется 'супер-глобальной var'. Она связана с переходом var между страницами посредством параметров URL. Она называется " $_GET " - это имя супер-глобальной, куда PHP вставляет параметры запроса.
GET - это http-метод, связывающий ссылки и url.

"Ссылка отправляет параметры, кот. помещаются в супер-глобальную var $_GET"

---------------------------------------------------------------------------------------
Пример извлечения параметров из URL:
При клике по ссылке отправляются параметры запроса:
	<?php
		$id = 2;
		$name = "Olga";
	?>
	<a href="second_page.php?id=<?php echo $id?>&name=<?php echo $name?>"><?php echo $link_name ; ?></a>
Параметры загружаются в $_GET и затем извлекаются из него:
	<pre>
		print_r($_GET);
		$name = $_GET["name"];
		echo $name;
	</pre>
---------------------------------------------------------------------------------------

__________________________________________________________________________________

КОДИРОВАНИЕ ЗНАЧЕНИЙ GET

В URL может содержать большинство символов, за исключением 'зарезервированных'. Исп. последних в исходном виде повлечет проблемы, поэтому их следует кодировать - приводить к опр. виду: % + 16-ричное число. Далее вставляем кодированный символ в URL, где он декодируется и переконвертируется обратно.

   !      #     $    %    &      '    (     )     *    +    ,     /     :     ;    =     ?   @    [     ]
|%21|%23|%24|%25|%26|%27|%28|%29|%2A|%2B|%2C|%2F|%3A|%3B|%3D|%3F|%40|%5B|%5D|


PHP позволяет кодировать URL через функцию 'urlencode ($string);'.
Она берет буквы, числа, '_', '-' и пропускает их без изменений, а вот зарезервированные символы преобразуются в 16-ричный эквивалент: знак '%' и 2 числа 16-ной системы. Пробелы преобразуются в +.
	$company = urlencode("Johnson & Johnson");	// при присваивании var
	<a href="any_page.php?company=<?php echo urlencode($company)?>">Ссылка</a>  // в URL

<!> Кодирование символов - только для GET-запросов.

Есть также функция 'rawurlencode()'. Как urlencode(), только пробелы конвертируются не в '+', а в '%20', благодаря чему ОС осущ. корректный поиск файлов. В URL применяется до '?'.

<!> 'rawurlencode()' - для пути, 'urlencode()' - для строки запроса.


	$page = "William Shakespear";
	$quote = "To be or not to be";
	$link1 = "/bio/". rawurlencode($page)."?quote=". urlencode($quote);
	$link2 = "/bio/". urlencode($page)."?quote=". rawurlencode($quote);
	echo $link1;		//	/bio/William%20Shakespear?quote=To+be+or+not+to+be
	echo $link2;		//  /bio/William+Shakespear?quote=To%20be%20or%20not%20to%20be
	Во 2 случае ОС будет дословно искать каталог "William+Shakespear".

__________________________________________________________________________________

КОДИРОВАНИЕ ДЛЯ HTML

Нужно вывести в HTML следующий текст:	" <Click> & learn more "
	<a href=""> <Click> & learn more </a>		// & learn more

Для корректного вывода воспользуемся PHP-функцией 'htmlspecialchars()':
	<?php $linktext = "<Click> & learn more"; ?>
	<a href=""><?php echo htmlspecialchars($linktext); ?></a>

Однако 'htmlspecialchars()' кодирует только 4 символа: < > & ".
Для остальных символов предусмотрена функция 'htmlentities()'.

__________________________________________________________________________________

ВКЛЮЧЕНИЕ И ТРЕБОВАНИЕ ФАЙЛОВ

Функция include("url_to_php") подключает один файл к другому.

Включение удобно исп. для функций: мы можем опр. их один раз и все. Можно разбить их на категории по типу: функции-формы, функции для БД, основные. У нас будет неск. файлов с разными ф.

Кроме include() есть еще 3 подобных ф:
1. require() - почти, что include(), но если файл не будет найден, будет выведена Fatal Error. "Я требую этот файл! Без него работать не буду". include() позволит работать без файла.
2. include_once() - хранит в [] путь к файлам, кот. уже включены. Когда вы включаете файл, он добавляет свой путь в массив, и если мы попросим включить этот файл снова, функция проигнорирует запрос, поскольку увидит, что он уже включен. Это полезно в случае с функциями, т.к. их нельзя переопределить.
3. require_once() - вместо простого включения - требование.

__________________________________________________________________________________

ПЕРЕАДРЕСАЦИЯ СТРАНИЦ ИЛИ РЕДИРЕКТ

Для редиректа помести php-код в самое начало документа.
	header("Location: basic.html");
	exit;	// чтобы не отсылать данные, содерж. после header()

Для удобства исп. можно упаковать код выше в функцию.
-------------------------------------------------------
	<?php
	function redirect_to($new_location) {
		header("Location: {$new_location}");
		exit;
	}
	$logged_in = $_GET['logged_in'];
		if ($logged_in == "1") {
			redirect_to("basic.html");
		} else {
			redirect_to("http://www.google.com");
		}
	?>
-------------------------------------------------------

__________________________________________________________________________________

БУФЕРИЗАЦИЯ ВЫВОДА

Данные, прежде чем быть отправленными на сервер, помещаются в буфер, где они еще доступны для редактирования.

Настроить буферизация можно способами:
1) Редактирование PHP.ini.
	Значение параметра "output_buffering" изменить на 'off', 'on', 'integer'.
2) Вносить изменения в каждую страницу.
	ob_start() - запуск буфера вывода.
	ob_end_flush() - команда закончить работу с буфером.
Т.о., станица должна начинаться с ob_start(), а заканчиваться ob_end_flush(). Важно располагать ob_start() перед любым контентом! Иначе отправится часть HTML, заголовки - будет слишком поздно.

Итак, что выбрать: включить буфер в настройках PHP.ini или в приложении? Лучше в ini, чтобы не забыть включить его на странице. Включили раз, и он включен постоянно. Однако, если мы выложим это на сервер, где настройка выключена, это НЕ БУДЕТ РАБОТАТЬ. Поэтому, если у вас нет контроля над PHP.ini другого сервера, рекомендую исп. постраничный метод и убедиться, что это сделано во всем приложении.


__________________________________________________________________________________

СОЗДАНИЕ ФОРМ

Создание страниц с формами для отправки данных - это 2 способ получения данных пользователя. Он может кликнуть по ссылке или набрать URL, что одно и тоже, или отправить форму. Ссылки и URL - 'GET-запрос'. Отправка формы - 'POST-запрос'.

В случае с GET-запросом PHP берет все параметры запроса и помещает их в ассоциативный [], кот. привязывает к супер-глобальной var $_GET. Тоже самое c POST-запросом: все значения, внесенные в форму, будут помещены в ассоц. [] -> $_POST.

	<form action="form_processing.php" method="POST">

GET-запрос идет из URL, POST-запрос - со страницы.

В отличии от GET-запроса POST-данные не нуждаются в кодировании/декодировании.
POST-данные упаковываются отдельно и не пересекаются с тем, что происходит в строке запроса.

-------------------------------------------------------------------------------------
form.php:
	<form action="form_processing.php" method="POST">
		Username: <input type="text" name="username" value=""/><br/>
		Password: <input type="password" name="pass" value=""><br/>
		<br/>
		<input type="submit" name="submit" value="Submit"/>
	</form>
form_processing.php:
	<?php
		$username = $_POST["username"];
		$password = $_POST["pass"];
		echo "{$username}: {$password}";
	?>
-------------------------------------------------------------------------------------
	<?php
		if (isset($_POST["username"])) {
			$username = $_POST["username"];
		} else {
			$username = "";
		}
		if (isset($_POST["password"])) {
			$password = $_POST["password"];
		} else {
			$password = "";
		}
	?>
-------------------------------------------------------------------------------------
	<?php
	// 	boolean_test ? value_if_true : value_if_false;
		$username = isset($_POST['username']) ? $_POST['username'] : "degfault";
		$password = isset($_POST['password']) ? $_POST['password'] : "default";
		echo "{$username}: {$password}";
	?>


ПРОВЕРКА ПРАВИЛЬНОСТИ ВВЕДЕННЫХ ДАННЫХ
----------------------------------------------------------------------------------------
<?php
	require_once("included_functions.php");

	function redirect_to($new_location) {
		header("Location: {$new_location}");
		exit;
	}

	if (isset($_POST['submit'])) {
		// form was submitted
		$username = $_POST['username'];
		$password = $_POST['password'];

		if ($username == "Vladimir" && $password == "1234") {
			// successful login
			redirect_to("basic.html");
		} else{
			$message = "There was some troubles";
		}
	} else {
		$username = "";
		$message = "Please log in";
	}
?>
__________________________________________________________________________________

ОБНАРУЖЕНИЕ ПОДАЧИ ФОРМЫ

Ситуация:
Мы отправили форму с данными, другая страница их получила, и в массиве $_POST были созданы ключи со значениями. При обновлении страницы массив $_POST сохраняет ключи с данными, но при переходе по URL, он эти данные теряет. Почему? Потому что содержимое массива $_POST формируется POST-запросом, кот. передает указанные в форме ключи со значениями, а работая с полем URL, мы создаем GET-запрос, кот. работает с собственной супер-глобальной var $_GET.

Чтобы $_POST сохранял данные, можно исп. isset().
	<?php
		if (isset($_POST["username"])) {			// если ключ содержит значение,
			$username = $_POST["username"]; // сохраним его в var
		}
		if (isset($_POST["password"])) {
			$password = $_POST["password"];
		}
		echo "{$username}: {$password}";
	;?>

Однако, если к-то из ключей окажется пустым, мы не сможем присвоить значение var и получим ошибку. В этом случае можно исп. 'значение по умолчанию'.
	<?php
		if (isset($_POST["username"])) {				// если ключ содержит значение,
			$username = $_POST["username"];		// сохраним его в var.
			} else {										// если не содержит, то
			$username = "";							// зададим default
		}
		if (isset($_POST["password"])) {
			$password = $_POST["password"];
			} else {
			$password = "";
		}
		echo "{$username}: {$password}";
	;?>

Есть более компактный синтаксис с тернарным оператором:
	<?php
		$username = isset($_POST["username"]) ? $_POST["username"] : "Name";
		$password = isset($_POST["password"]) ? $_POST["password"] : "Pass";
		echo "{$username}: {$password}";
	;?>

Есть вариант еще лучше: можно проследить, происходит ли отправка формы или нет. Для этого кнопка должна иметь атрибуты 'name' и 'value'.
    if (isset($_POST["submit"])) {  // если кнопка нажата, ее значение включено в []
        echo "Form was submitted" . "<br/>";
    }

----------------------------------------------------------------------------------------
Т.к. незаполненное поле возвращает пустую строку, я доработал условие, чтобы получать default:

    if (isset($_POST["username"]) && $_POST["username"] != "") {
        $username = $_POST["username"];
    } else {
        $username = "Default";
    }
----------------------------------------------------------------------------------------
Если форма заполнена, мы увидим данные ключей, если нет - увидим значения по умолчанию. В блоке else {} мы объявляем var, иначе при выполнении echo PHP выдаст ошибку "Undefined variable".

	<?php
		if (isset($_POST["submit"])) {
			echo "Form was submitted"."<br/>";
			$username = isset($_POST["username"]) ? $_POST["username"] : "";
			$password = isset($_POST["password"]) ? $_POST["password"] : "";
		} else {
			$username = "Default";
			$password = "Default";
		}
	;?>
	<?php
		echo "{$username}: {$password}";
	?>

__________________________________________________________________________________

ОДНОСТРАНИЧНАЯ ОБРАБОТКА ФОРМЫ

На 1 странице может содержаться как сама форма, так и ее обработка.

Одно из преимушеств - проще заполнять поля уже введенными данными.

__________________________________________________________________________________

ВАЛИДАЦИЯ ЗНАЧЕНИЙ ФОРМЫ

Параметры:
1. Присутствие.
2. Длина строки.
3. Тип данных.
4. Включенность в набор.
5. Уникальность.
6. Формат.

1. Присутствие.
Для проверки присутствия можем исп. isset().
	if (!isset($value)) {		// если значение не задано, то
		echo "Validation failed";
	}
Есть важный нюанс:
если нам отправят пустую строку ($value = ""), то значение все равно будет задано, т.е. if(isset($value)) будет true, соответственно if( !isset($value)) будет false. Пустое поле создаст ключ в $_POST, поэтому проверку следует дополнить функцией empty(), кот.
	$value = "";
	if (!isset($value) || empty($value)) {
		echo "Validation failed";
	}
Т.о. isset() проверяет существование var, а empty() - наличие присвоенного значения.

2. Длина строки.
Для этого есть strlen($var), возвращающая целое число.
	// * string length
	// minimum length
	$value = "abcd";
	$min = 3;
	if (strlen($value) < $min) {
		echo "Validation failed.<br />";
	}
	// max length
	$max = 6;
	if (strlen($value) > $max) {
		echo "Validation failed.<br />";
	}

3. Тип данных.
<!> Когда отправляем значение из формы в PHP, всегда получаем строку. Если нужно получить что-то другое, придется  делать преобразование типа.

4. Включенность в набор.
	$value = "1";
	$set = ["1", "2", "3", "4"];
	if ( !in_array($value, $set) ) {		// если $value нет в массиве $set, то
		echo "Validation failed.";
	}

5. Уникальность.
Проверка на уникальность нуждается в БД. Основная идея в том, что когда отправляется значение, мы берем его и спрашиваем у БД: "У тебя есть такое значение?". Если получаем ответ 'Есть', то выдаем ошибку валидации (ведь значение не уникально).

6. Формат.
Есть функция про уровня preg_match($regex, $subject), кот. применяет регулярное выражение для проверки на совпадение.
	if (preg_match("/PHP/", "PHP is fun.")) {
		echo "A match was found.";
	} else {
		echo "A match was not found.";
	}
--------------------------------------------------
	$mail = "vo1-khaproff@mail.ru";
	if ( !preg_match("/@/", $mail) ) {
		echo "Validation failed.";
	}

Однако, preg_match() не самый быстрый способ. Иногда strstr() или strpos() будет куда быстрее.
    $value = "nobody@nowhere.com";
	if (strpos($value, "@") === false) {		// ===, если strpos вернет позицию 0
		echo "Validation failed.<br />";
	}

__________________________________________________________________________________

ПРОБЛЕМЫ С ЛОГИКОЙ ВАЛИДАЦИИ

Есть правила, по кот. PHP осущ. сравнение типов:
- strings vs. null: converts null to ""
- boolean vs. other: converts other to boolean
- number vs. other: converts other to number

'empty()'
Функция empty() рассматривает "", 0, "0", null, false и array() как EMPTY. Обрати внимание, что empty("0") рассматривается как ПУСТОЕ значение. Если надо передать 0 как значение, данную функцию исп. не следует.

Если $value=" " (содержит 1 и более пробелов ), то empty() в виду своей особенности вернет true. Чтобы обойти это, исп. trim(), кот. обрежет пробелы по краям. Также убедимся, что $value является числом.
    <?php
		$value = trim("  ");		// trim() обрезает пробелы
		if (!isset($value) || empty($value && !is_numeric)) {
		// если var не установлена или пустая и не является числом, то echo
			echo "Validation failed";
		}
    ?>

Можно не исп. empty(), заменив это ($value === ""). В этом случае, получив пустую строку, мы выполним нужную инструкцию.
	$value = trim("");
	if (!isset($value) || $value === "") {
		echo "Validation failed";
	}


Можно написать свою empty() и самим решить, какое значени считать пустым.

__________________________________________________________________________________

ВЫВОД ОШИБОК ВАЛИДАЦИИ

Мы не хотим сообщать ничего пользователю, как только нашли первую ошибку. Мы хотим найти все ошибки, отправить их пользователю и сказать: "У тебя здесь пять ошибок. Исправь их все."

Если пользователь ошибся при заполнении формы, мы можем сообщить ему об этом. После исправления, пользователь вновь отправит форму, но тут мы обнаружим вторую ошибку, до которой не дошли в первый раз, и попросим пользователя исправить уже ее. Нам ни к чему этот утомительный пинг-понг. Лучше собрать все ошибки и разом представить их.

Лучший способ сделать, создать массив и поместить в него все ошибки:
	$errors = []
Когда процесс валидации закончится, мы можем решить, как поступить с [].
Если ни одно из полей на заполнено, то:
	$errors = [];
	if ( !isset($value) || $value === "" ) {
		$erros['value'] = "Value can't be blank";
	}

Чтобы проверить существование ключа в массиве array_key_exists():
	if (array_kay_exists($errors, "name")) {
		echo ... ;
	}

__________________________________________________________________________________

ПОЛЬЗОВАТЕЛЬСКИЕ ФУНКЦИИ ВАЛИДАЦИИ

Создадим файл с функциями, кот. будут проверять формы на наличие незаполненных полей.

__________________________________________________________________________________

COOKIES

Это небольшие кусочки данных, кот. сайт просит ваш браузер временно хранить. Куки дают нам, как разработчикам, хранить данные о состоянии: кто этот пользователь и какие данные производил? Без куки веб-сервер не смог бы распознать, что несколько разных страниц запрашиваются одним пользователем.
Куки браузера предоставляют точки последовательности. Сервер может посмотреть на куки и узнать, что этот браузер, кот. сделал запрос, это тот же самый браузер, что сделал предыдущие три.
Процесс начинается тогда, когда пользователь отправляет запрос веб-серверу. Сервер не может прочитать куки, пока не пришел запрос. Вы не можете отправлять или получать куки, если нет входящего запроса или обратного ответа, потому что они отправляются в заголовках запросов.

Супер-глобальная var $_COOKIE.

Функция для установки значения:
	setcookie($name, $value, $expire);

"Cookies нужны, чтобы запоминать данные пользователя от страницы к странице".

ЧТЕНИЕ ЗНАЧЕНИЙ КУКИ

PHP берет все значения куки, отправляет их в заголовок запроса и помещает в массив, привязанный к супер-глобальной $_COOKIE. Данный ассоциативный [] может содержать данные от неск кукис. Получить доступ к значениям $_COOKIE можно с помощью ключей для извлечения их из [].

__________________________________________________________________________________

РАБОТА С СЕССИЯМИ

Сессии стартуют с отправкой кукис, а завершаются с закрытием браузера.

Функция session_start() говорит PHP взять куки, связанные с сессией, найти файл сессии, открыть его, взять оттуда данные и поместить их в $_SESSION. Если файла нет, то файл создается и подготавливается ссылка для отправки ее пользователю, с куками для возможности послед. доступа. Все это в фоновом режиме.

Сессия исп. куки, а куки - заголовки.

Поработаем со значениями. Заметьте, что нам не требуется подобие setcookie().
	<?php
		$_SESSION["first_name"] = "Kevin";
		$name = $_SESSION["first_name"];
		echo $name;
	?>

В отличие от кук, нам не нужно обращаться к браузеру пользователя, чтобы установить или извлечь значение.

Пока user отправляет нам ИД сессии, мы будем обеспечивать ему доступ посредством этих значений.

__________________________________________________________________________________






MySQL

Когда сложность вашего сайта возрастает, вы сталкиваетесь с ограниченностью возможностей PHP и быстро понимаете, что имеет смысл подключить БД.

- БД позволяет как читать, так и записывать данные. С PHP мы в основном читали данные, кот. кодировали долгое время. Запись данных не возможна силами одного PHP.
- БД позволяет хранить множество данных упорядоченно.
- БД ускоряет доступ к данным и упрощает управление ими.
- БД позволяет устанавливать отношения между разными данными, поэтому их называют 'реляционными БД'.

Колонки в БД опр. то, какие данные будут храниться (имя, город и т.д.). Ряды - это индивидуальные записи. БД может устанавливать и отслеживать отношения между таблицами данных, но для этого нужно задать команды для взаимодействия с БД.

Термины
'БД' - это набор таблиц. Обычно на 1 приложение приходится 1 БД.
'Таблица' состоит из колонок и рядов. 1 таблица = 1 тип инфы. 1 тип - это единый блок в нашем приложении, например: товары, клиенты, заказы, страны и т.д.
'Колонки' - это набор данных 1 опр. типа (имя, фамилия, пароль).
'Ряды' - единая запись данных.
'Поле' - пересечение колонки и ряда.
'Индекс' - это структура данных в таблице, кот. увеличит скорость поиска по этой таблице. Это как указатели в конце книги: вы находите нужное в списке и смотрите, куда оно ссылается.
'Внешний ключ' - колонка в таблице, чье значение отсылает к ряду другой таблицы. С помощью него устанавливаются взаимосвязи в реляционных БД.
'CRUD' - create, read, update, delete.

__________________________________________________________________________________

API - посредник между разными программами, объединенными одной задачей. В обычных условиях эти программы не смогли бы взаимодействовать, но благодаря API им удается понимать друг друга и координировать свои действия.

Вся суть создания БД в том, чтобы возвращать данные и делать с ними что-нибудь.

__________________________________________________________________________________

ЭКРАНИРОВАНИЕ СТРОК ДЛЯ MYSQL

Экранирование одинарных кавычек - это способ защититьс от SQL-иньекций.

Способ 1: Backslash before single-quote.
	$menu_name = "Today\'s Widget Trivia";
Когда MySQL наткнется на backslash, он скажет: "Так, у след. символа особое поведение. Это не закр. кавычка, а обычная."

Чтобы не вставлять / вручную, PHP предлагает функцию: 'addslashes($string)'. Она пройдется по строке и добавит backslash перед нужными символами. В PHP 3 эта функция была включена по умолчанию, но в PHP 5.4 ее удалили из-за проблем возникаемых с Magic Quotes. Вместо addslashes() придумали 'mysqli_real_escape_string($db, $string)'.
	$menu_name = ("Today's Widget Trivia");
	$menu_name = mysqli_real_escape_string($connection, $menu_name);


"ПЕРЕСМОТРИ ЗНАКОМСТВО С ПОДГОТОВЛЕННЫМИ ЗАПРОСАМИ"
Там про годный способ защиты от SQL-иньекций.

__________________________________________________________________________________

ОБЩИЙ ПЛАН ПРИЛОЖЕНИЯ

Основная идея CMS иметь приватные веб-страницы, кот. помогут управлять контентом публичного веб-сайта. Другими словами, пользователи обычно просто просматривают наш контент, т.е. читают из БД, но есть область администрирования, и админы могут делать CRUD.

Первым этапом на старте любого веб-проекта явл. создание детального плана (blueprint).

Сайт будет состоять из 2 частей: публичной и админ. Админ-часть будет защищенной зоной с управлением контентом, кот. отображается в публичной части.

---------------------------------------------------------------------------------------

В добавок к плану проекта полезно отобразить, как будет выглядеть наша таблица. Этот этап - 'моделирование данных', потому что мы планируем, какого типа данные у нас будут, как их хранить и какие между ними будут отношения.

__________________________________________________________________________________

РЕЛЯЦИОННЫЕ БД

Для внешних ключей нужн создавать индексы:
	INDEX (subject_id)


__________________________________________________________________________________

СОЕДИНЕНИЕ ПРИЛОЖЕНИЙ С БД

Есть 5 шагов:
1. Создаем соединение.
2. Формируем запрос БД.
3. Работаем с возвращенными данными, если есть.
4. Отпускаем/освобождаем данные.
5. Завершаем соединение.

----------------------------------------------------------------------------------------
1. Создание соединения:

	$dbhost = "localhost";
	$dbuser = "widget_cms";
	$dbpass = "secretpassword";
	$dbname = "widget_corp";
	$connection = mysqli_connect($dbhost, $dbuser, $dbpass, $dbname);
----------------------------------------------------------------------------------------
Проверка соединения на ошибки:

	if (mysqli_connect_errno()) {		// проверка соединения на ошибки
		die("Database connection failed: " .
		mysqli_connect_error() .
		"(" .mysqli_connect_errno() . ")"
		);
	}
----------------------------------------------------------------------------------------
2. Запрос БД:

	$query = "SELECT * ";
	$query .= "FROM subjects ";
	$query .= "WHERE visible = 1 ";
	$query .= "ORDER BY position ASC ";
	$result = mysqli_query($conenction, $query);
	if(!result) {
		die("Database query failed.");
	}
----------------------------------------------------------------------------------------
3. Использование возвращенных данных:

	<ul>
		<?php
			while($subject = mysqli_fetch_assoc($result)) {
		?>
		<li><?php echo $subject["menu_name"] ."(" . $subject["id"] .")"; ?></li>
		<?php>
			}
		?>
	</ul>

Т.о. у нас будет список внутри навигации.
----------------------------------------------------------------------------------------
4. Отпустим возвращенные данные (Release Returned Data)
	mysqli_free_result($result);
----------------------------------------------------------------------------------------
5. Закроем соединение с БД:
	mysqli_close($conenction);

Хотя PHP в силах самостоятельно завершить соединение. Хорошей практикой считается проверка, было ли установлено соединение.
	if ( isset($connection) ) {
		mysqli_close($conenction);
	}
----------------------------------------------------------------------------------------

При установлении соединения с БД лучше исп. постоянные вместо var.
	$dbuser = "widget_cms";    =>    define("DB_NAME", "widget_corp");

__________________________________________________________________________________

Рефакторинг - корректировка уже существующего кода по изменению его структуры или внешнего вида, но без изменения его поведения. Выполнять он будет то же самое, мы просто подправим его.

Рефакторинг кода преследует опр. задачи, как то: упрощение, ясность, легкость в обслуживании, эффективность, большая гибкость (повторное исп-е, функциональная расширяемость).

Функции, зачастую, отличный способ улучшить код, потому что у кода остаются те же задачи, но они не мешают нам, потому что располагаются отдельно.

__________________________________________________________________________________

	<?php if ($subject) {...}; ?>		// если $subject был задан, то


Защита от SQL-иньекций:
	$safe_subject_id = mysqli_real_escape_string($connection, $subject_id);
	...
	if ( $subject = mysqli_fetch_assoc($subject_set) ) {
		return $subect;
	} else {...}


"Если у нас есть $page_array и id страницы = ["id"] $page_array, то"
	if ($page_array && $page["id"] == $page_array["id"]) {...}


Счетчик из #107
	for ($count=1; $count <= $subject_count; $count++) {
		echo "<option value=\"{$count}\">{$count}</option>";
	}


Ситуация:
Нужно передать данные формы некой странице, кот. произведет их обработку. Для этого странице обработки не нужен HTML, но нужны соединение с БД и функции:
	<?php require_once("../includes/db_connection.php") ; ?>
	<?php require_once("../includes/functions.php") ; ?>


"Он скажет: это POST-запрос из формы, где есть отправленное значение. Если мы его не получаем, значит, это был GET-запрос: кто-то открыл браузер, набрал в строке URL и просто нажал ВВОД, не отправляя форму. Этого мы не хотим разрешать, поэтому на такой случай зададим редирект и вернемся на new_subject.php".
	if ( isset($_POST['submit']) ) {

	} else {
		// This is probably a GET request
		redirect_to("new_subject.php");
	}

Не забывай про приведение типов:
	$position = (int) $_POST["position"];
	$visible = (bool) $_POST["visible"];

"Когда мы проверяем, были ли изменены к-нибудь ряды, мы проверяем, чтобы из кол-во = 1".
	if ($result && mysqli_affected_rows($connection) == 1)
Но, если ничего не было имзменено, то вернется 0:
	if ($result && mysqli_affected_rows($connection) == 0)
Поэтому нужно сказать, что кол-во дб >= 0, и если изменение не удалось, если это реальная ошибка, мы получим -1.
	if ($result && mysqli_affected_rows($connection) >= 0)		// -1
Так делать лучше, ибо позволяет нам учитывать ситуацию, при кот. данные окажутся прежними.

__________________________________________________________________________________

Все публичные сайты обычно располагаются на index.php - это страница по умолчанию, кот. обслуживает сервер.









Loftblog
__________________________________________________________________________________

Для проверки типа данных var в PHP есть функция 'gettype()'.
	$a;
	gettype($a);	// NULL
__________________________________________________________________________________

Еще раз про разницу в кавычках.

	$a = "Строка 1";
	$b = 'Строка 2';
	echo "В этом тексте есть $a<br>";		// В этом тексте есть Строка 1
	echo 'В этом тексте есть $a<br>';		// В этом тексте есть $a
	echo 'В этом тексте есть '.$a;			// В этом тексте есть Строка 1
'print' - синоним echo:
	print "В этом тексте есть {$a}<br>";	// В этом тексте есть Строка 1
	print 'В этом тексте есть {$a}<br>';	// В этом тексте есть {$a}
	print 'В этом тексте есть'. {$a}; 		// Ошибка

'print_r($array)' лаконичный вывод содержимого массива. Для наглядности оборачивается в <pre>.
	[0]=>Value
'var_dump($array)' расширенный вывод содержимого массива. Пример:
	0 => string  'Value'  (length=5)
__________________________________________________________________________________

К слову, в PHP && и || можно заменить на and и or соответственно.
__________________________________________________________________________________

$a != $b	равно	  $a <> $b
__________________________________________________________________________________

Функция 'count()' считает посчитает кол-во элементов в массиве.
__________________________________________________________________________________

Функция, кот. поочередно извлекает значения всех элементов массива.
	function show_elements($array) {
		foreach($array as $element);
		echo $element"";
	}
--------------------------------------------------------------------------------------
То же самое, но учитывается условие, если массив пустой.
	$array = ["Jan", "Feb", "Mar", "Apr", "Jun"];
	function get_elements($array = null) {
		if(is_null($array)) {
			echo "Данных нет";
		} else {
			foreach ($array as $element) {
				echo $element.'<br/>';
			}
		}
	}
	get_elements($array);	// месяцы
	get_elements();			// Данных нет
__________________________________________________________________________________

'Циклы' предназначены для многократного исполнения набора инструкций.
__________________________________________________________________________________

В PHP '&' - это передача по ссылке. Чтобы это не означало.
__________________________________________________________________________________

Функция 'array_keys()' собирает все ключи из [] и выводит их в виде отдельного массива.
__________________________________________________________________________________

В PHP число элементов [] опр. функцией count(). length из JS не канает.
	for ($i = 0; $i < count($arr); $i++) {
		echo $arr[$i] . '<br>';
	}
Но удобнее foreach.
__________________________________________________________________________________

Чтобы получить файл в PHP:
	$text = file_get_contents('data/1.txt');

Данные (например, формы) можн выгрузить в файл.
	if(count($_POST) > 0) {
		$name = $_POST['name'];
		$phone = $_POST['phone'];
		file_put_contents('apps.txt', "$name $phone\n", FILE_APPEND);
		// чтобы инфа записывалась в конец файла
	}
__________________________________________________________________________________

Функция 'nl2br($text)' преобразует обычные переносы в <br>.
__________________________________________________________________________________

date("Y-m-d H:i:s");
__________________________________________________________________________________

explode('separator', $string) - разрывает строку по разделителю и возвращает массив.
__________________________________________________________________________________

Framework - это готовая архитектура и готовый набор полезных библиотек, который организует вас правильно писать код в рамках опр. критериев.
__________________________________________________________________________________

'var_dump' - отладочная функция, кот выводит тип данных элемента и пытается распечатать его внутреннее содержимое.
__________________________________________________________________________________

\n - перенос строки в Windows
\r\n (*nix/Mac) - перенос строки + возврат каретки в начало
__________________________________________________________________________________

РАБОТА С ФАЙЛАМИ

file_get_contents('file.txt')
echo file_put_contents('file.txt', "text")
echo file_exists('file1.txt')			// существует ли файл?		// 0 или 1
echo filesize('file.txt')					// размер файла в байтах
rename('original.txt', 'new.txt')		// переименование файла
unlink('new.txt')						// удаляет файл с сервера

----------------------------------------------------
<?php
	$f = fopen("1.txt", "r");

	while(!feof($text)) {
		$firstChar = fread($text,1);
		echo $firstChar;
	}

	$length = filesize("1.txt");
	$str = fread($f, $length);
	echo nl2br($str);
	// После открытия файла, его обязательно следует закрыть.
	fclose($f);
?>
----------------------------------------------------

ЧТО ПОД КАПОТОМ У  'file_get_contents()':
	function my_file_get_contents($path) {
		$f = fopen($path, 'r');
		$length = filesize($path);
		$str = fread($f, $length);
		fclose($f);
		return $str;
	}
	echo my_file_get_contents('1.txt');

----------------------------------------------------

<?php
	$file = fopen('a.txt', 'a');
	$date = date("Y-m-d H:i:s");
	fwrite($file, nl2br("$date\r\n"));
	fclose($file);

	echo file_get_contents('a.txt');
?>

__________________________________________________________________________________

Применение внутри HTML:
<body>
   <?php foreach ($jokes as $joke): ?>
      // HTML-код для вывода каждого элемента $joke
      <p><?php echo htmlspecialchars($joke, ENT_QUOTES, 'UTF-8'); ?></p>
   <?php endforeach; ?>
</body>

<form action="?" method="post"></form>>
// Данная форма отправляет запрос к сгенерировавшему ее скрипту. Чтобы URL-адрес не содержал строку запроса, зададим атрибуту action значение "?", чем обнулим ее
при отправке формы.

<p><a href="?addjoke">Добавьте собственную шутку</a></p>
Как и форма, ссылка указывает на сгенерировавший ее PHP-скрипт, но при этом добавляется строка запроса '?addjоkе'. Контроллер определяет наличие этой строки и использует ее как сигнал, чтобы вывести форму.

if (isset($_GET['addjoke'])) {
   include 'form.html.php';
   exit();
}
if проверяет, включает ли строка запроса $addjоkе (опр. нажатие ссылки пользователем). Но даже если в '?addjоkе'' не содержится значения, $ все равно будет создана и выражение isset($_GET['addjoke']) позволяет в этом убедиться.
__________________________________________________________________________________

ОТПРАВКА ПОЧТЫ НА EMAIL
	$message = "Обычное сообщение";
	$to = "name@mail.ru";
	$from = "vo1-khaproff@mail.ru";
	$subject = "Тема сообщения";
	$subject = "=?utf-8?B?".base64_encode($subject)."?=";	// для Mail.ru
	// $headers - заголовки очень важны, т.к. без них почтовые сервисы не смогут корректно обрабатывать сообщения
	$headers = "From: $from\r\nReply-to: $to\r\nContent-type: text/plain; charset=utf-8\r\n";
	mail ($to, $subject, $message, $headers);
	// Остается записать функцию mail(), кот. передает команду в приложение SendMail. Сам PHP ничего не отправляет, он делегирует.
__________________________________________________________________________________

SMTH ИЗ OPENCART

<?php
    if(isset($_POST['submit'])) {
        $fio = htmlspecialchars($_POST['fio']);
        $tel = htmlspecialchars($_POST['tel']);
        $comment = htmlspecialchars($_POST['comment']);
    }
;?>

Подтверждение удаления из модуля Корзины:
<td class="remove"><img src="catalog/view/theme/palioxis/image/remove-small.png" alt="<?php echo $button_remove; ?>" title="<?php echo $button_remove; ?>" onclick="(getURLVar('route') == 'checkout/cart' || getURLVar('route') == 'checkout/checkout') ? location = 'index.php?route=checkout/cart&remove=<?php echo $product['key']; ?>' : confirm('Удалить товар? Вы уверены?') && $('#cart').load('index.php?route=module/cart&remove=<?php echo $product['key']; ?>' + ' #cart > *');" /></td>

Отображение корректного URL для главной.
\system\library\response.php
в функцию public function output() { с самого начала дописываем:
if (!defined('HTTP_CATALOG')) $this->output = str_replace('index.php?route=common/home', '', $this->output);
__________________________________________________________________________________




Как нетрудно догадаться, оператор  += для массивов делает примерно то же, что и оператор  += для чисел, а именно — добавляет в свой левый операнд элементы, перечисленные в правом операнде-массиве, если они еще не содержатся в массиве слева.
Итак, в массиве никогда не может быть двух элементов с одинаковыми ключами, потому что все операции, применимые к массивам, всегда контролируют, чтобы этого не произошло.

$persons = array_merge($names, $dates);

<?php ## Перебор ассоциативного массива
   $birth = [
      "Thomas Anderson" => "1962-03-11",
      "Keanu Reeves" => "1962-09-02",
   ];
   for (reset($birth); ($k = key($birth)); next($birth))
      echo "$k родился {$birth[$k]}<br />";
?>
Представленная конструкция опирается на еще одно свойство ассоциативных массивов в PHP. А именно, мало того, что массивы являются направленными, в них есть еще и такое понятие, как текущий элемент. Функция  reset() просто устанавливает этот элемент на первую позицию в массиве. Функция  key() возвращает ключ, который имеет текущий элемент (если он указывает на конец массива, возвращается пустая строка, что позволяет использовать вызов  key() в контексте второго выражения  for ). Ну а функция next() перемещает текущий элемент на одну позицию вперед.
На самом деле, две простейшие функции —  reset() и  next() , — помимо выполнения своей основной задачи, еще и возвращают некоторые значения, а именно:
• функция  reset() возвращает значение первого элемента массива (или  false , если
массив пуст);
• функция  next() возвращает значение элемента, следующего за текущим (или  false ,
если такого элемента нет).

Цикл foreach перед началом своей работы выполняет копирование массива. Это позволяет, например, использовать вместо переменной-массива результат работы некоторой функции или даже сложное выражение. Работа с копиями в большинстве случаев оказывается удобной, однако она не позволяет изменять перебираемые элементы.
В PHP существует разновидность цикла  foreach, позволяющая изменять итерируемый массив. Выглядит она очень просто и естественно — используется ссылочный оператор &, указанный перед именем переменной-элемента.
   <?php ## Изменение элементов при переборе
      $numbers = [100, 313, 605];
      foreach ($numbers as &$v) $v++;
         echo "Элементы массива: ";
      foreach ($numbers as $elt) echo "$elt ";
   ?>
Вы можете теперь убедиться, что новая версия программы действительно изменяет массив $numbers, а не работает с его копией.
ВНИМАНИЕ !
Ссылочная переменная $v — это полноценная жесткая ссылка, которая не уничтожается после завершения работы цикла foreach! Таким образом, если вы попытаетесь что-то присвоить переменной $v в конце программы, изменения затронут последний элемент массива $numbers — ведь именно он соответствовал $v на последней итерации цикла! Как раз по этой причине мы используем переменную $elt, а не все ту же $v, в последнем цикле вывода листинга: иначе бы последний элемент массива $numbers, которому соответствует жесткая ссылка $v, "затирался" при последующей итерации по массиву.

Для открытого файла (точнее, файлового дескриптора) система хранит определенную величину - текущую позицию ввода/вывода или указатель файла.