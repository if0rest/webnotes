Т.к. на 1 IP-адресе могут работать неск. веб-серверов, обслуживающих разные доменные имена.

Перед вами небольшой life-hack – в PHP вы можете использовать скобочки {} для выделения некой логики в блоки, при этом никакой функциональной нагрузки они не несут, а вот читаемость кода – повышают.

В чем разница между движками MySQL - InnoDB и MyISAM? Каковы их слабые и сильные стороны?

http://itif.ru/otlichiya-myisam-innodb/

UNSIGNED - задает беззнаковые числа.
FLOAT - Число с плавающей точкой небольшой точности.
DOUBLE - Число с плавающей точкой двойной точности.
REAL - Синоним для DOUBLE.
DECIMAL - Дробное число, хранящееся в виде строки.
NUMERIC - Синоним для DECIMAL.

Введение в хранимые процедуры MySQL 5
https://ruseller.com/lessons.php?id=1189

https://ru.wikipedia.org/wiki/ACID

https://habrahabr.ru/post/47031/

http://www.softtime.ru/bookphp/gl12_4.php

Репликация — одна из техник масштабирования баз данных. Состоит эта техника в том, что данные с одного сервера базы данных постоянно копируются (реплицируются) на один или несколько других (называемые репликами). Для приложения появляется возможность использовать не один сервер для обработки всех запросов, а несколько. Таким образом появляется возможность распределить нагрузку с одного сервера на несколько.
https://ruhighload.com/post/%D0%A0%D0%B5%D0%BF%D0%BB%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F+%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85
https://habrahabr.ru/post/56702/

Движки MySQL
https://wiki.dieg.info/mysql
https://habrahabr.ru/post/64851/

binlog
https://habrahabr.ru/sandbox/22772/

MySQL кластер
https://toster.ru/q/115775
https://habrahabr.ru/post/253869/

Если предложение WHERE определяет предикат для фильтрации строк, то предложение HAVING применяется после группировки для определения аналогичного предиката, фильтрующего группы по значениям агрегатных функций. Это предложение необходимо для проверки значений, которые получены с помощью агрегатной функции не из отдельных строк источника записей, определенного в предложении FROM, а из групп таких строк. Поэтому такая проверка не может содержаться в предложении WHERE.

SQL-Урок 5. Символы подстановки и регулярные выражения (LIKE)
http://moonexcel.com.ua/%D1%83%D1%80%D0%BE%D0%BA%D0%B8-sql5-%D1%80%D0%B5%D0%B3%D1%83%D0%BB%D1%8F%D1%80%D0%BD%D1%8B%D0%B5-%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F-like_ru





==================================================
СУБД И БАЗЫ ДАННЫХ
==================================================

'БД' - взаимосвязанная информация (данные) об объектах, кот. организована спец. образом и хранится на к-либо носителе.
'СУБД' - совокупность программных и лингвистических средств общего или специального назначения, обеспечивающих управление созданием и использованием БД.

Работа с вашими данными не с помощью программирования, а с помощью описания, декларативного синтаксиса. Софт, кот. решает все эти проблемы, называется СУБД (система управления).
Собственно, 'БД' - это данные, хранящиеся в опр. формате, связанные между собой, кот. описывают к-то приложение. 'СУБД' - это софт, кот. поддерживает эти данные в правильном состоянии, кот. позволяет с ними легко работать.

Функции СУБД:
- управление данным во внешней памяти
- управление данными в оперативной памяти
- обеспечение целостности и надежности хранения данных (журнализация изменений, резервное копирование и восстановление БД после сбоев)
- поддержка языков БД (язык опр. данных, язык манипулир. данными)

'Реляционные БД' характеризуются тем, что хранят данные в виде таблиц.

Кортеж = строка, Атрибут = столбец

Выражение или expression - это то, у чего есть значение: a+b
Утверждение или statement: с=a+b

Существует 'язык SQL' (Structured Query Language) - структурированный язык запросов. БД реализует язык SQL, кот. позволяет производить различные операции. SQL - это декларативный язык, т.е. он не содержит инструкций или алгоритмов, как нужно делать к-то вещи. Он содержит описание того, что нужно сделать, а БД сама решает, как нужно делать. Т.о., язык SQL состоит из т.н. стейтментов. Язык SQL состоит из 3 частей:
DDL (Data Definition Language) - опр. структуры отношений.
DML (Data Manipulation Lang) - изменение хранимых данных.
DQL (Data Query Lang) - запросы.

'Агрегация данных' - это вычисление к-то значения для группы строк. При А атрибуты делятся на 2 типа: по которым идет группировка и для кот. выбираются агрегатные функции.

*** ВЫБОРКА ***
	SELECT id, name, length(name) AS len
// позволяет задать поля(атрибуты, столбцы), кот. будем выбирать
	FROM users
// из какой таблицы делать выборку, со сколькими таблицами работаем
	WHERE email like '%@mail.ru' AND age>10
// способ осуществить выборку; указ. условие, по кот. будет выбирать кортежи
	ORDER BY name DESC
	LIMIT 10 OFFSET 15
*** ВЛОЖЕННЫЕ ЗАПРОСЫ ***
	SELECT title
	FROM article t1
	JOIN (
		SELECT rubric_id, MAX(id) max_id
		FROM article
		GROUP BY rubric_id LIMIT 5
	) t2
	ON t1.id = t2.max_id;

INSERT INTO users (name, age) VALUES ('petr', 10);
// INSERT INTO users - указывается имя таблицы, в кот. добавляем данные
// (name, age) - атрибуты, в кот. записываем дата
// VALUES ('petr', 10) - указ. значения, кот. записываем в соотв. атрибуты
UPDATE users SET age = 10 WHERE name = 'petr';
UPDATE users SET age = age + 1;
// UPDATE - обновляет набор строк
// users - имя таблицы, кот. обновляем
// SET age=10 - установить колонке age значение 10
// WHERE - условие
<!> UPDATE может обновить сразу неск. строк.
DELETE FROM users WHERE name = 'masha';
DELETE FROM users WHERE age > 150;
// удаляются строки, кот. подходят под условие
DROP TABLE useless;	// удаление таблицы
-----------------------------
ALTER TABLE users
	ADD COLUMN language enum('ru', 'en')
	NOT NULL DEFAULT 'ru' after name;

ALTER TABLE users DROP COLUMN language;

ALTER TABLE users ADD INDEX ('name');

ALTER TABLE users
	CHANGE nickname fullname varchar(255) NOT NULL;
// изменение таблицы. Оператор изменения позволяет к существующей, наполненной данными таблице добавлять и удалять столбцы. Как правило, операторы изменения таблиц работают очень долго: вам требуется перезаписать таблицу, чтобы в ней появилась новая строчка.
-----------------------------
CREATE DATABASE test;

Общее правило хранения БД: каждый факт должен храниться в 1 месте БД, данные не должны дублироваться. Если данные дублируются, есть шанс, что они разойдутся, плюс увеличивается объем. Чтобы избежать этого, была предложена реляционная алгебра с ее операторами SELECT и JOIN/UNION. Идея этого в том, чтобы разделить все данные на мелкие таблицы и хранить их так, а результаты запросов строить с помощью объединения этих таблиц вместе.
Проблема понятна: избыточность данных и противоречивость (в 1 месте обновили, в др. - нет, и данные разошлись).
Задача проектирования: "Сокращение избыточности и дублирования данных, обеспечение целостности, исключений противоречий в содержании и потери данных".

'Ключ' в таблице - это минимальный набор атрибутов, обеспечивающий уникальность.
'Внешний ключ' - набор атрибутов в к-то таблице, кот. ссылается на ключевые атрибуты др. таблицы.

При проектировании БД, если нужно N:M (один ко многим) - делаем внешний ключ, если M:M (многие ко многим) - промежуточная таблица.
Смысл проектирования - разделить на маленькие таблицы, а потом с помощью SELECT собирать и получать нужные результаты.

"БД обеспечивают структуру для хранения таблиц". Следующая по важности вещь, кот. хранится в СУБД - это индекс.

Форма - это способ отправить к-то данные на сервер.

====================================================================


SQL -> СУБД (MySQL) -> БД
--------------------------------------------------

INSERT — вставка строк в таблицу.
DELETE — удаление строк из таблицы.
UPDATE — модификация данных в таблице.
SELECT — выборка данных из таблиц по запросу.

-------------------------------------------------------------
SELECT DISTINCT authorname, authoremail
FROM joke

Слово DISTINCT предотвращает вывод дублирующихся строк. Например, если Джоан Смит добавила на сайт 20 записей, то благодаря этому параметру ее имя появится в общем списке всего один раз, а не 20.

Используемая в примере структура базы данных подразумевает хранение двух
видов сущностей (шуток и авторов), поэтому здесь наиболее подходит вариант с двумя таблицами. Всегда руководствуйтесь данным принципом при проектировании баз данных: каждый тип объекта (или сущность), должен располагаться в отдельной таблице.
-------------------------------------------------------------
COUNT(expr) - возвращает число, равное количеству величин ехрr со значением не NULL в несгруппированном результирующем наборе. Запись COUNT(*) вернет количество строк в группе, независимо от того, содержат они значения NULL или нет.
-------------------------------------------------------------
SELECT столбца
FROM таблица1 INNER JOIN таблица2
ON условие(я) связанности данных
-------------------------------------------------------------
База данных - это совокупность связанных между собой данных, сохраняемая в двумерных таблицах к-либо инф. системы. БД - это организованный набор таблиц. Каждая таблица - это неупорядоченный массив, состоящий из однородных элементов (записей). Каждая запись может содержать 1 и > именованных полей. Каждое поле содержит опр. тип данных.
---------------------------------------------------------------------
• Извлечь записи опр. дипазона:
WHERE id > 5 AND id < 30 или WHERE id BETWEEN 5 AND 30;
• или наоборот - записи вне диапазона:
WHERE id NOT BETWEEN 5 AND 30;
• Извлечь конкретные записи:
WHERE id IN (1,3,5,7);
• обратная ситуация 'ВЕРНУТЬ ВСЕ, КРОМЕ':
WHERE id NOT IN (1,3,5,7);
---------------------------------------------------------------------
UPDATE и REPLACE
REPLACE похожа на INSERT. Если из-за столбца, отмеченного как PRIMARY
KEY или UNIQUE, новая строка станет конфликтовать с уже имеющимся значением, команда REPLACE заменит старую запись.

REPLACE INTO my_table VALUES(конфликтующая (например, с тем же id) запись с PRIMARY KEY или UNIQUE, новые параметры)
---------------------------------------------------------------------
TRUNCATE TABLE быстрее DROP
---------------------------------------------------------------------

Условие:
Выбрать студентов, имеющих балл от 82 до 90. Студенты должны быть отсортированы в порядке убывания балла.
Запрос:
	SELECT fam FROM student WHERE ball BETWEEN 81 AND 91 ORDER BY ball DESC;
Комментарий:
Как видно из SQL примера, чтобы выбрать студентов, которые имеют балл от 82 до 90, мы используем условие BETWEEN. Чтобы отсортировать в убывающем порядке DESC.
--------------------------------------------------
CREATE TABLE `table2` (
	phone_id INT(5) NOT NULL AUTO_INCREMENT,
	user_id INT(5) NOT NULL,
	phone_number INT(10) NOT NULL,
	PRIMARY KEY (phone_id),
	INDEX(user_id, phone_number)
);
# AUTO_INCREMENT - при создании каждой записи, значение в этом поле создаётся автоматически и увеличивается на единицу, к тому же оно является первичным ключём.
 # PRIMARY KEY представляет собой один из примеров уникальных индексов и применяется для уникальной идентификации записей таблицы.
 # Кортеж - конструкция типа "(поле1/значение1, ...)".
 # ORDER BY используется для сортировки по одному из полей, указанных после оператора SELECT.
 # LIMIT выводит строки в указанном диапазоне (нижняя граница не включается). Если первый аргумент не указан, то он считается равным 0.

Справка по операторам операций объединения:
------------------------------------------------
table1, table_2	-> WHERE | ничего
'JOIN' 			   -> USING | ON | WHERE | ничего
'LEFT|RIGHT JOIN' -> USING | ON [WHERE]
------------------------------------------------

+==========================+
|    ОБЪЕДИНЕНИЕ ТАБЛИЦ    |
+==========================+

JOIN связывает таблицы в одно целое по указанным столбцам. Объединения позволяют извлекать данные из нескольких таблиц без создания временных таблиц и за один запрос. MySQL позволяет 3 типа объединения:
1. INNER JOIN (CROSS JOIN) — внутреннее (перекрёстное) объединение
2. LEFT JOIN — левостороннее внешнее объединение
3. RIGHT JOIN — правостороннее внешнее объединение
--------------------------------------------------
`INNER JOIN` позволяет извлекать строки, которые ОБЯЗАТЕЛЬНО присутсвуют во всех объединяемых таблицах:
SELECT table3.room_number FROM table1
INNER JOIN table2 USING(user_id)
INNER JOIN table3 USING(phone_id)
WHERE table1.username = 'qux';
С помощью оператора 'USING' мы указываем поле, по которому будут связаны таблицы. Его использование возможно только если поля имеют одинаковое название. В противном случае необходимо использовать ON:
--------------------------------------------------
Помимо конструкции 'INNER JOIN' внутреннее объединение можно объявить так же через 'CROSS JOIN', 'JOIN' и запятую в объявлении 'FROM'. Следующие запросы вернут одинаковый результат:
SELECT * FROM nomenclature INNER JOIN description;
SELECT * FROM nomenclature CROSS JOIN description;
SELECT * FROM nomenclature JOIN description;
SELECT * FROM nomenclature, description;
# Если объединять таблицы через запятую, то нельзя использовать конструкции ON и USING, условие мб задано только в конструкции WHERE:
SELECT * FROM nomenclature, description
WHERE nomenclature.id = description.id;

И так, внутреннее объединение можно задать следующими способами:
SELECT * FROM Таблица1, Таблица2 [WHERE Условие1];
SELECT * FROM t1 [INNER|CROSS] JOIN t2 [ON Условие1 | USING(Поле)]
Результатом будет декартово произведение всех таблиц, на которое можно накладывать условия выборки, используя ON, USING и WHERE.
--------------------------------------------------
'LEFT JOIN' извлекает данные из таблицы, дополняя их по возможности данными из другой таблицы. Если их нет, то NULL.
SELECT table3.room_number FROM table1
LEFT JOIN table2 ON table1.user_id = table2.user_id
LEFT JOIN table3 ON table2.phone_id = table3.phone_id
WHERE table1.username = 'quuz';
"Новый пользователь получил user_id=5. Это значение отсутствует в других таблицах, поэтому в результате мы получили NULL. При INNER JOIN результат был бы пустой, так как выводятся только значения, которые есть во всех таблицах. При LEFT/RIGHT JOIN таблицы table1 и table2 дополняются значением из table3, даже если его и нет."

Выборка наименований без описаний:
SELECT id, name FROM nomenclature LEFT JOIN description
USING(id) WHERE description IS NULL;
--------------------------------------------------
'RIGHT JOIN' отличается от левостороннего объединения тем, что данные берутся из второй таблицы, которая находится справа от констркуции 'JOIN', и сравниваются с данными, которые находятся в таблице, указанной перед конструкцией.
#Правосторонняя выборка:
SELECT * FROM nomenclature RIGHT JOIN description USING(id);
+----+---------------------+----------+
| id | description         | name     |
+----+---------------------+----------+

Во всех случаях RIGHT JOIN можно переписать на LEFT JOIN, просто поменяв таблицы местами. Следующие два запроса равнозначны:
SELECT * FROM nomenclature LEFT JOIN description USING(id);
SELECT * FROM description RIGHT JOIN nomenclature USING(id);

"По сути, основное назначение внешних запросов - показывать расхождение данных 2 таблиц. При таком объединении обязательно условие, задаваемое через ON или USING, иначе ошибка".

--------------------------------------------------

+================================+
|     МНОГОТАБЛИЧНЫЕ ЗАПРОСЫ     |
+================================+

Испольузуя JOIN, можно объединять гораздо больше таблиц, нежели 2 (MySQL5.0 до 61). MySQL позволяет объединять таблицу саму с собой, однако из-за возможного конфликта имен следует исп. alias (синонимы, псевдонимы) для имён таблиц и столбцов.
#Объединение таблицы саму на себя:
SELECT * FROM nomenclature AS t1 JOIN nomenclature AS t2;
+----+-----------+----+-----------+
| id | name      | id | name      |
+----+-----------+----+-----------+
|  1 | Книга     |  1 | Книга     |
+----+-----------+----+-----------+

MySQL не накладывает ограничений на использование разных типов объединений в одном запросе, поэтому можно формировать довольно сложные конструкции:
#Пример сложного объединения таблиц
SELECT * FROM nomenclature AS t1
JOIN nomenclature AS t2
LEFT JOIN nomenclature AS t3
ON t1.id = t3.id AND t2.id = t1.id;

Помимо выборок использовать объединения можно также и в запросах 'UPDATE' и 'DELETE'. Следующие запросы проделывают одинаковую работу:
UPDATE nomenclature AS t1, nomenclature AS t2 SET t1.id = t2.id WHERE t1.id = t2.id;
UPDATE nomenclature AS t1 JOIN nomenclature AS t2 [USING(id)] SET t1.id = t2.id;
DELETE t1 FROM nomenclature AS t1 JOIN nomenclature AS t2 USING(id) WHERE t2.id > 10; - не понял, почему 'DELETE t1 FROM', но работает только так.

Следует помнить, что при использовании многотабличных запросов на удаление или обновление, нельзя включать ORDER BY и LIMIT. Впрочем, это ограничение обходится при помощи временных таблиц.

+-----------------------------------------+
# Пример реального многотабличного запроса
SELECT SQL_CALC_FOUND_ROWS
    pft.udate,
    dgs.dogovor_name,
FROM
	billing_profit pft
		LEFT JOIN
			billing_dogovors dgs
		USING( dogovor_id )
		LEFT JOIN
			billing_profit_types ptt
		ON
			pft.profit_type = ptt.type_id
WHERE
	pft.udate > CURDATE() - INTERVAL 7 DAY
ORDER BY
	pft.udate DESC,
	dgs.dogovor_name ASC
LIMIT 0, 30;
+-----------------------------------------+

+-----------------+-------------------------------+
| 'table1, table2'  | WHERE или ничего            |
+-------------------------------------------------+
| 'JOIN'            | USING, ON, WHERE или ничего |
+-----------------+-------------------------------+
| 'LEFT|RIGHT JOIN' | USING, ON [WHERE]           |
+-----------------+-------------------------------+






=================================================
LoftBlog
=================================================
База данных - набор сведений, хранящихся некоторым упорядоченным способом.

СУБД - совокупность языковых и програмных средств, кот. осуществляет доступ к данным, позволяет их создавать, менять и удалять, обеспечивает безопасность данных и т.д.

SQL - задача: предоставление простого способа считывания и записи инфы в БД.

+=================+
|     КОМАНДЫ     |
+=================+

Вставка данных. Добавит записи в таблицу со следующими значениями:
INSERT INTO table_name (id, name, ...) VALUES (1, 'Petr');
Выборка данных:
SELECT * FROM table WHERE field_1 = 2;
SELECT id, name FROM table WHERE field_1 != 2;
SELECT * FROM table WHERE field_1 > 2;
Изменение данных:
UPDATE table SET filed_1='new_value';
UPDATE table SET age=24, sex='female' WHERE name='Maria';
Удаление данных:
DELETE FROM table_name; - удалит все записи
DELETE FROM table_name WHERE id=15;
Сортировка данных:
SELECT * FROM table_name ORDER BY age DESC;

+===============================+
|     РЕДАКТИРОВАНИЕ ТАБЛИЦ     |
+===============================+

Все запросы редактирования таблиц начинаются с ALTER TABLE.
1. Добавление поля:
ALTER TABLE имя_таблицы ADD COLUMN имя_поля BOOLEAN NOT NULL DEFAULT TRUE;
2. Удаление поля:
ALTER TABLE имя_таблицы DROP COLUMN имя_поля;
3. Переименование и смена типа поля:
ALTER TABLE имя_таблицы CHANGE COLUMN старое_поле новое_поле BOOLEAN NOT NULL DEFAULT TRUE;
4. Смена типа (данных) поля:
ALTER TABLE имя_таблицы MODIFY имя_поля VARCHAR(255) NOT NULL DEFAULT 'значение';
5. Переименование таблицы:
ALTER TABLE имя_таблицы RENAME TO новое_имя_таблицы;

СРАВНЕНИЕ СТРОК
SELECT * FROM имя_таблицы WHERE имя_поля LIKE 'значение';
SELECT * FROM имя_таблицы WHERE имя_поля LIKE 'знач%';
SELECT * FROM имя_таблицы WHERE имя_поля LIKE '%ение';
ОПЕРАТОРЫ AND и OR
AND сужает поиск, OR - расширяет.
SELECT * FROM имя_таблицы WHERE поле_1 = 1 AND поле_2 > 3;
ИСКЛЮЧЕНИЕ ПОВТОРЯЮЩИХСЯ ДАННЫХ
SELECT DISTINCT имя_поля FROM имя_таблицы; - вернет уникальные записи указанного поля.
ГРУППИРОВАНИЕ ЗАПИСЕЙ
Делает с помощью оператора GROUP BY, кот., как правило, исп. с агрегатными функциями COUNT(), MIN(), MAX() и SUM().
SELECT field_1, COUNT(field_1) FROM имя_таблицы GROUP BY field_1;
- сгруппировать записи по полю field_1 и вывести уникальные значения field_1 и кол-во их дубликатов.
SELECT field_1, COUNT(field_1) FROM имя_таблицы GROUP BY field_1 HAVING COUNT(field_1) > 3;
- выведет сгруппированные записи, у кот. кол-во дубликатов > 3.
SELECT author, COUNT(title) FROM books GROUP BY author HAVING author LIKE '%ro%';
- выводит список уникальных авторов, в имени кот. есть %ro%, и суммарное кол-во их произведений.

+====================================+
|     ЧАСТО ИСПОЛЬЗУЕМЫЕ ФУНКЦИИ     |
+====================================+

COUNT(X) - возвращает кол-во величин Х, со значением != NULL.
SUM(X) - возвращает сумму величин в аргументе X.
MIN(X) - возвращает мин. величину X.
MAX(X) - возвращает макс. величину X.
ROUND(X) - возвращает X, округленный до ближайшего целого.
RAND(X) - возвращает случайную величину float от 0 до 1.0.
# Больше всего Ф в PostgreSQL.
ЧАСТЫЕ ФУНКЦИИ ДЛЯ СТРОК
LENGTH(X) - возвращает длину строк X.
TRIM(X) - удаляет пробелы в начале и конце строки X.
LOWER(X) - приводит строку X к нижнему регистру.
UPPER(X) - приводит строку X к верхнему регистру.
SUBSTR(X,N) - возвращает подстроку X с позиции N.
REPLACE(X,Y,Z) - возвращает строку X, где все вхождения Y заменены на Z.
REVERSE(X) - вернет строку X с обратным порядком символов.
MD5(X) - вернет md5 хеш строки X.
	SELECT md5('pass');
SHA2(X,N) - вернет sha2 хеш строки X разрядностью N.
NOW() - возвращает текущую дату и время в формате
UNIX_TIMESTAMP() - возвращает временную метку unix.

КОПИРОВАНИЕ ДАННЫХ ИЗ ОДНОЙ ТАБЛИЦЫ В ДРУГУЮ:
INSERT INTO table_2 SELECT id, name FROM table_1 ORDER BY id DESC;

---------------------------------------------------------------
Реляционная БД - в кот. таблицы связаны между собой отношениями.
НОРМАЛИЗАЦИЯ - разбиение таблицы, чтобы избавиться от избыточности данных.

+=====================+
|     CONSTRAINTS     |
+=====================+

Constraints - ограничения типов данных.
NOT NULL - поле обязано быть заполненным.
UNIQUE - добавляет ограничение на повторяющиеся значения. Искл. дубликаты.
DEFAULT - если надо, чтобы поле было заполнено, но в него не было передано никакого значения. Задает значение по умолчанию.
PRIMARY KEY - уникальный индекс, кот. исп. для идентификации записи. При его добавлении поле автоматически наследует NOT NULL и UNIQUE + создается индекс, кот. позволяет быстрее осуществлять поиск данных по записи.

Чтобы сослаться на поле другой таблицы, исп. внешние ключи.
CREATE TABLE IF NOT EXISTS table_name(
	field_1 INT PRIMARY KEY,
	field_2 VARCHAR NOT NULL UNIQUE,
	field_3 INT NOT NULL,
	FOREIGN KEY(fieled_3) REFERENCES other_table(filed_name)
)
FOREIGN KEY указывает, какое поле нашей таблицы явл. внешним ключом, а REFERENCES - на какое поле другой таблицы оно ссылается (поле дб первычным, иначе ошибка).

Выборка из нескольких таблиц.
SELECT * FROM table_name LEFT JOIN other_table
ON (table_name.field_2 = other_table.field_name);
- вывести все записи таблицы table_name слева от таблицы other_table, у которых совпадают значения полей field_2 и field_name.

+==================+
|     ТРИГГЕРЫ     |
+==================+

ТРИГГЕР - это хранимая в БД процедура, автоматически вызываемая при соответствующих условиях (исполняемая при модификации записей в таблице). Момент запуска опр. ключевыми словами BEFORE, AFTER, INSTEAD.

#Пример триггера в MySQL:
DELIMITER $$
CREATE TRIGGER trigger_name AFTER INSERT ON table_name
 FOR EACH ROW
 BEGIN
   INSERT INTO other_table(field) VALUES (NEW.other_field);
 END $$
DELIMITER;
- создаст триггер для таблицы 'table_name', кот. будет срабатывать после вставки и добавлять новую запись в таблицу 'other_table', со значением поля 'other_field' таблицы 'table_name'.

DATETIME('now') - в sqlite задает текущие дату-время.
NOW() - задает текущие дату-время в MySQL.


+====================+
|     ТРАНЗАКЦИЯ     |
+====================+

ТРАНЗАКЦИЯ - это группа последовательных запросов, кот. должна выполниться как одно целое или не выполниться вообще.
ТРАНЗАКЦИЯ - это группа последовательных операций, кот. представляет собой логическую единицу работы с данными.

Пример транзакции в SQLite и PostgreSQL | MySQL:
BEGIN | START TRANSACTION;
	UPDATE table_name SET field.1 = NULL WHERE id = 5;
	DELETE FROM other_table WHERE id = 17;
COMMIT; - выполнит группу операций как одно целое, запрос на изменения поля и удаления записи не вступят в силу, пока мы не подтвердим операции, ключевым словом COMMIT.
ROLLBACK; - отмена транзакции: запрос на изменение поля и удаление записи не вступят в силу, и таблицы останутся без изменений.

Контрольные точки SAVEPOINT:
BEGIN;
	UPDATE table_name SET field.1 = NULL WHERE id = 5;
	DELETE FROM other_table WHERE id = 17;
 SAVEPOINT point_name;
	DELETE FROM test_table WHERE id = 75;
 ROLLBACK TO SAVEPOINT point_name;
COMMIT; - в результате данной транзакции будет выполнено только два запроса: изменение записи в таблице table_name и удаление записи из таблицы other_table.



'==============================================================
=============================================================='


SELECT book_title FROM table WHERE column2='value';
SELECT column1 AS 'pseudo' FROM table WHERE column2 LIKE '%value%';

WHERE id > 3 AND id < 10  <===>  WHERE id BETWEEN 3 AND 10

SELECT books.title AS "Title", borrowings.returndate AS "Return Date"
FROM borrowings JOIN books ON borrowings.bookid=books.bookid
WHERE books.author='Dan Brown';



UPDATE books SET stock=0 WHERE author='Dan Brown';
# Синтаксис запроса UPDATE семантически совпадает с запросом на чтение. Отличие в том, что вместо выбора колонок SELECTом, мы задаем значения SETом.
#Вместо SELECT используем SET

DELETE FROM books WHERE author='Dan Brown';
# DELETE это просто запрос SELECT или UPDATE без названий колонок.

Insert

INSERT INTO x (a,b,c) VALUES (x, y, z);
# Где (a,b,c) это названия колонок, а (x,y,z) - значения, которые нужно вставить в эти колонки, в том же порядке.
INSERT INTO books (bookid,title,author) VALUES
	(1,'Scion of Ikshvaku','Amish Tripathi'),
	(2,'The Lost Symbol','Dan Brown');

==============================================================
================================================================

СУБД - это то, что позволяет взаимодействовать с БД. Она расшифровывает SQL-запрос и производит описанные в нем операции.

PHPmyAdmin - веб-интерфейс для администрирования СУБД.

Взаимодействие с БД происходит при помощи СУБД, которая расшифровывает запросы и производит операции с информацией в БД.
В реляционных БД данные собраны в таблицы, которые состоят из столбцов и строк, на пересечении которых расположены ячейки. Запросы к таким БД возвращают таблицу, которая повторно может участвовать в следующем запросе. Данные в одних таблицах, как правило, связаны с данными других, откуда пошло название "реляционные".

Особенности реляционной БД:
• Данные хранятся в таблицах, состоящих из столбцов и строк;
• На пересечении каждого столбца и строчки стоит в точности 1 значение;
• У каждого столбца есть своё имя, которое служит его названием, и все значения в одном столбце имеют один тип;
• Столбцы располагаются в определённом порядке, который определяется при создании таблицы, в отличие от строк, которые располагаются произвольно;
• Запросы к БД возвращают результат в виде таблиц, которые тоже могут выступать как объект запросов.

------------------------------------------------------------
• БД - это набор таблиц, каждая из кот. содержит набор связанных данных.
• ТАБЛИЦЫ - это набор данных, организованных как строки и столбцы. Таблицы мб связаны отношениями с др. таблицами.
• SQL - это язык описания реляционных БД и запросов. Каждый SQL-запрос начинается ключевым словом и заканчивается ';'.
	Чтобы вывести другие заголовки столбцов вместо родных, исп. AS:
		SELECT Nick AS Name FROM ...		// при выводе имя столбца изменится на Name
	Хотя AS необяательно, все и так прекрасно работает:
		SELECT Nick Name FROM ...			// при выводе имя столбца изменится на Name
	Чтобы посчитать строки:
		SELECT COUNT(*) FROM table;
		SELECT COUNT(*) FROM table WHERE population > 1000000;
	Удалить строку:
		DELETE FROM customer WHERE id=4;
	Выразить численность в миллионах%
		SELECT Name, Population / 1000000 AS PopMM ...
	Удалить строку, где одна из ячеек содержит NULL (пуста)
		DELETE * FROM table WHERE Name IS NULL;
	Выбрать строку, где 1 из ячеек содержит пустую строку:
		SELECT * FROM table WHERE Name = '';
	Добавить столбец в таблицу:
		ALTER TABLE test ADD field TEXT DEFAULT 'panda';
<!> Если id с PRIMARY KEY, то AUTO_INCREMENT не нужен.
	Показать все страны, названия кот. содержат 'island':
		SELECT * FROM table WHERE Name LIKE '%island%' ORDER BY Name;

	Оператор IN исп. для отбора записей, соответ. значениям из списка:
		... WHERE Continent IN ('Europe', 'Asia') ORDER BY Name;
		// запрос вернет строки, где поле Continent содерж. 1 из значений в ( )
	Оператор DISTINCT не выводит дубликаты:
		SELECT DISTINCT Continent FROM Country;
	Условное выражение и CASE:
		SELECT
				CASE WHEN a THEN 'true' ELSE 'false' END as boolA;
				FROM booltest
		;
JOIN
Природа БД такова, что некоторые таблицы содержат инфу, связанную с другими таблицами. Оператор JOIN позволяет эффективно извлекать связанные данные из неск. таблиц. Как правило, для создания отношений исп. поля уникальных ИД. Если нужен результат, включающий связанные строки из неск. таблиц, нужно исп. запрос с соединением.
Чаще всего исп. самое простое соединение - ВНУТРЕННЕЕ. Оно применяется по умолчанию, если указано только JOIN. В результат внутреннего соединения включаются строки из обеих таблиц, соотв-щие условию соединения.
ЛЕВОЕ ВНЕШНЕЕ соединение (LEFT JOIN) включает строки, соотв. условию + все строки из левой таблицы. ПРАВОЕ ВНЕШНЕЕ - аналогично, но считается спец. случаем и не поддерж. многими СУБД.
ПОЛНОЕ ВНЕШНЕЕ соединение вкл. все строки из обеих таблиц + те, для кот. условие выполняется.

	SELECT l.description AS left, r.description AS rigth
		FROM left as l
		JOIN rigth as r
			ON l.id = r.id
	;

------------------------------------------------------------
