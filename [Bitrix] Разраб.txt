Разработчик должен учитывать специфику проекта и правильно выбирать тип таблиц: InnoDB или MyISAM .

if (defined('BX_COMP_MANAGED_CACHE') && is_object($GLOBALS['CACHE_MANAGER']))
if (strlen($cp->getCachePath()))
if (!empty($item['PREVIEW_PICTURE']['SRC']))
$sIdTextArea = (isset($arParams['TEXTAREA_ID']) == false) ? '' : $arParams['TEXTAREA_ID']
if ('' == trim($sIdTextArea)) $sIdTextArea = 'content'
$PathInstall = substr($PathInstall, 0, strlen($PathInstall)-strlen("/index.php"))
if (isset($_GET['noinit']) && !empty($_GET['noinit']))
if(!(defined("CHK_EVENT") && CHK_EVENT===true))
---------------------------------
var href = window.location.href, matches, taskId; 
var href = href + (href.indexOf('?') === -1 ? '?' : '&') + 'task=' + taskId + '&' + 'pdf=1&sessid=' + BX.bitrix_sessid();


инстанцируется класс =  инициализируется объект 

технология отложенных функций / кеширования
система событий
механизм urlrewrite

Создание шаблона сайта для Bitrix Framework по готовой верстке заключается в выделении блоков и размещении вместо этих блоков компонентов. Далее эти компоненты настраиваются на источник данных и для них редактируются шаблоны вывода в соответствии с версткой сайта.
Компонент получает данные откуда-то и выводит их в нужном виде. За правильный вывод отвечает шаблон компонента. У одного компонента может быть несколько шаблонов, по-разному выводящих информацию.

В Unix-подобных операционных системах поддерживаются три вида прав - чтение, запись и выполнение, которые присваиваются каждому файлу или директории. Права эти повторяются три раза: для владельца файла, для группы пользователей, к которой владелец принадлежит, и для всех остальных пользователей. Как правило, права указываются в числовом формате: 
4 - чтение; 
2 - запись; 
1 - выполнение. 
В PHP все права задаются в виде восьмеричных чисел, поэтому их надо задавать с обязательным указанием префикса - 0. Пример: 0755.

Производительность. Скорость работы системы зависит от качества настройки ее элементов, то есть в большей степени на производительность влияет уровень подготовки разработчика проекта, возможности хостинга. 

MVC (Model-view-controller, «Модель-представление-поведение», «Модель-представление-контроллер») — архитектура программного обеспечения, в которой модель данных приложения, пользовательский интерфейс и управляющая логика разделены на три отдельных компонента, так, что модификация одного из компонентов оказывает минимальное воздействие на другие компоненты.
• Модель (Model). Модель предоставляет данные (обычно для Представления), а также реагирует на запросы (обычно от Контроллера), изменяя своё состояние. 
• Представление (View). Отвечает за отображение информации (пользовательский интерфейс). 
• Поведение (Controller). Интерпретирует данные, введённые пользователем, и информирует модель и представление о необходимости соответствующей реакции. 
Важно отметить, что как Представление, так и Поведение, зависят от Модели. Однако Модель не зависит ни от Представления, ни от Поведения. Это одно из ключевых достоинств подобного разделения. Оно позволяет строить Модель независимо от визуального Представления, а также создавать несколько различных Представлений для одной Модели.

Компонент - это контроллер и представление для использования в публичном разделе. Компонент с помощью API одного или нескольких модулей манипулирует данными. Шаблон компонента (представление) выводит данные на страницу.
Компоненты входят в состав модулей, но решают более узкую, частную задачу — например, выводят список новостей или товаров. Вносить свои изменения в код продукта рекомендуется на уровне компонентов. Программист может модифицировать их как угодно, использовать свои наработки и использовать неограниченное число шаблонов на каждый из компонентов. На одной странице сайта может располагаться несколько компонентов, кроме того, их можно включать в шаблон сайта. Таким образом, программист имеет возможность собрать сайт как конструктор, после чего доработать необходимые компоненты для получения желаемого результата как в функциональном, так и в визуальном плане.
Чтобы работать с API нужно просто понять структуру компонентов Bitrix Framework.
Примечание: Модуль - это набор каких-либо сущностей. Компонент - это то, что этими сущностями управляет. 
Посмотрим на примере модуля Инфоблоки. Этот модуль представляет собой совокупность таблиц в базе данных и php-классов, которые могут проводить какие-либо операции с данными из таблиц (например, CIBlockElement::GetList() или CIBlockElement::GetByID ()). Компонентом является уже, например, Новость детально, который имеет собственные настройки (показывать дату, картинку и т.д. и т.п.) и работает с методами php-классов модуля.

Динамическая информация (новости, каталог товаров, статьи) сохраняются в БД модулем Информационные блоки. Тогда для вывода, например, десятка тысяч товаров в интернет-магазине используется одна единственная физическая страница (файл). В этом файле вызывается компонент инфоблоков, который в свою очередь выбирает и выводит товары из базы данных.

Благодаря технологии отложенных функций часть визуальных элементов, выводимых в прологе, может быть задана в теле страницы, это такие элементы как:
• заголовок страницы (выводится функцией CMain::ShowTitle); 
• навигационная цепочка (выводится функцией CMain::ShowNavChain); 
• CSS стили (выводятся функцией CMain::ShowCSS); 
• мета-теги (выводятся функцией CMain::ShowMeta); 
и др. 
Принципиальной особенностью данной технологии является то, что она позволяет отложить исполнение некоторых функций, выполняя их в эпилоге, а результаты их выполнения подставляя в вышележащий код.

В самом начале загрузки каждой страницы (непосредственно перед открытием сессии и событием OnPageStart) система автоматически проверяет, есть ли агент, который нуждается в запуске и в случае необходимости - исполняет его.

Если функция-агент не принадлежит ни одному из модулей, то ее необходимо разместить в файле /bitrix/php_interface/init.php. Этот файл автоматически подключается в прологе.

Агенты выполняются в однопоточном режиме. Новый вызов агента возможно только после того, как отработает предыдущий вызов.

Технология позволяет создавать отложенные функции с помощью метода CMain::AddBufferContent.

namespace Bitrix\Main\IO;
\Bitrix\Main\IO\SomeClass::SomeMethod();

Каждый стандартный модуль определяет в пространстве имен Bitrix свое подпространство, совпадающее с именем модуля. Например, для модуля forum пространством имен будет Bitrix\Forum, а для модуля main - Bitrix\Main.

Вместо 
	\Bitrix\Main\Class::Function()
можно писать
	Main\Class::Function().

Также допустимо и использование синонимов, вместо длинных пространств имен. Для этого необходимо использовать use. Например, мы имеем длинную конструкцию:
	\Bitrix\Main\Localization\Loc::getMessage("NAME");
Чтобы сократить ее, объявим в начале файла синоним и далее уже будем использовать сокращенный вариант вызова:
	use \Bitrix\Main\Localization\Loc;
	...
	Loc::getMessage("NAME");

В handled_errors_types, exception_errors_types, assertion_error_type необходимо передать тип ошибки. Тип ошибки представляет из себя числовой код. Но коды знать и помнить не нужно. Что означает данная запись: E_ALL & ~E_NOTICE & ~E_WARNING & ~E_STRICT & ~E_USER_WARNING & ~E_USER_NOTICE & ~E_COMPILE_WARNING?
Для начала обратимся к уровням ошибок интерпретатора PHP. Есть определенные значения и определенные константы, которые им соответствуют. В нашем же случае данная запись означает, что E_ALL (значение константы 2047), побитовое и не E_NOTICE, и не E_WARNING и не E_STRICT и не E_USER_WARNING и не E_USER_NOTICE и не E_COMPILE_WARNING. То есть E_ALL за исключением далее указанных констант, которые определяют тот или иной уровень ошибок интерпретатора PHP.

Основным фактором качества исходного кода программы является его читаемость и понятность. Необходимо формализовать правила написания кода, которые сделают чужой код читабельнее и понятнее. 

Форматирование подчиненности
Подчиненный код должен быть сдвинут от главного ровно на один символ табуляции. Подчиненный код не может находиться на той же строке, что и главный. Отступ более чем пятого уровня может служить указанием, что код стоит вынести в отдельный блок.

substr($APPLICATION->GetCurPage(), 0, strlen(BX_ROOT."/admin/"))

Если в имени содержится аббревиатура, лучше вместо всех заглавных оставить только первую букву заглавной, а остальные написать строчными. Т.е. лучше задать имя getHtmlStatistic, а не getHTMLStatistic.

Имена переменных могут иметь префиксы, если требуется явно указать тип переменной: ar - для массивов, db - для наборов данных из базы и т.п.

В коде не должно быть магических чисел. Пример плохого кода:
$task->Update($taskId, array('STATUS' => 3), 1);
Пример хорошего кода: 
$task->Update($taskId, array('STATUS' => CTaskStatus::New), TASK_PERMISSIONS_WRITE); 

При выводе ошибки на экран (если режим отладки отсутствует), подключается файл /error.php. В этом файле вы можете вывести ошибку в дизайне сайта, а также установить код статуса HTTP (например, "500 Internal Server Error").

При обновлении и удалении записей их можно будет идентифицировать только по первичному ключу.

Метод onBeforeAdd, определенный в сущности, автоматически распознается системой как обработчик события "перед добавлением", и в нем можно изменить данные или провести дополнительные проверки.

Валидация задается параметром (поля) 'validation' в конструкторе поля и представляет собой callback, который возвращает массив валидаторов.

Очень часто разработчики сталкиваются с реализацией счетчиков, где для целостности данных предпочтительно рассчитывать новое значение на стороне БД, вместо выборки старого значения и пересчете его на стороне приложения.

В объектах действует строгое приведение значений к типу поля.

...\ScalarField - тип поля сущности.

При этом объект запоминает свои исходные значения. С этого момента доступ к текущему значению осуществляется через основной "геттер" get, а к изначальному, актуальному для базы данных значению, через вспомогательный "геттер" remindActual:
	$book->getTitle(); // текущее значение
	$book->remindActualTitle(); // актуальное для базы данных значение

Для "сеттеров" тоже есть универсальные варианты вызова с именем поля в качестве аргумента:
	$book->set('TITLE', "New title");

Что касается новых объектов, есть два пути их создания.
Наиболее читаемый способ — через прямое инстанциирование:
	$newBook = new \Bitrix\Main\Test\Typography\Book;
Более универсальный и обезличенный метод создавать новые объекты — через фабрику сущности:
	$newBook = \Bitrix\Main\Test\Typography\BookTable::createObject();
По умолчанию, в новом объекте устанавливаются все значения по умолчанию, описание в "маппинге" getMap. Абсолютно чистый объект можно получить, передав соответствующий аргумент в конструктор:
	$newBook = new \Bitrix\Main\Test\Typography\Book(false);
	$newBook = \Bitrix\Main\Test\Typography\BookTable::createObject(false);

Если вам нужно дозаполнить несколько объектов ( $author->fill(); ), то категорически не рекомендуется выполнять эту команду в цикле - это приведет к большому количеству запросов к базе данных. Для работы с несколькими объектами одного типа одновременно следует использовать аналогичный метод Коллекции.

Коллекция - это умный массив, позволяющий оптимизировать групповые операции с однотипными объектами.

Для получения конкретных объектов, содержащихся в коллекции, предусмотрен метод getByPrimary:
	// 2. пример с составным первичным ключом
	$booksToAuthor = \Bitrix\Main\Test\Typography\BookAuthorTable::getList()->fetchCollection();
	$bookToAuthor = $booksToAuthor->getByPrimary(
		['BOOK_ID' => 2, 'AUTHOR_ID' => 18]
	);
	// будет присвоен объект отношения книги ID=2 с автором ID=18

Доступ к объекту сущности Publisher реализуется через "геттер" getPublisher(). Таким образом, можно подключать более глубокие цепочки отношений, и так же по цепочкам "геттеров" добираться до конечных объектов.

В конструктор передаются название поля и класс партнерской сущности. В случае примитивных отношений достаточно вызвать метод configureTableName с указанием имени таблицы, где хранятся связующие данные.

В памяти автоматически создается временная сущность для работы с промежуточной таблицей.

Это не более чем типовая сущность с референсами (направленными отношениями 1:N) к исходным сущностям-партнерам. 

В процессе выполнения команды производится сканирование модулей, а именно всех файлов из папок bitrix/modules/[module]/lib. Если в файле обнаруживается "маппинг" сущности (класс Table, подкласс Bitrix\Main\ORM\Data\DataManager), то анализируется ее карта (список полей).

Самая частая задача - это выборка данных с различными условиями фильтрации, группировки и сортировки.

Чтобы новое API выглядело для разработчика менее пугающим и более знакомым, сохранено имя самого популярного метода: getList. Но если раньше каждый getList имел свой набор параметров и зашитое непрозрачное поведение, то теперь этот метод един для всех сущностей и подчиняется одним законам. Даже при желании у разработчика сущности сделать "костыль" в getList ничего не выйдет.

Какие параметры принимает метод ClassTable::getList:
ClassTable::getList(array(
	'select'  => ... // имена полей, которые необходимо получить в результате
	'filter'  => ... // описание фильтра для WHERE и HAVING
	'group'   => ... // явное указание полей, по которым нужно группировать результат
	'order'   => ... // параметры сортировки
	'limit'   => ... // количество записей
	'offset'  => ... // смещение для limit
	'runtime' => ... // динамически определенные поля
));
::getList всегда возвращает объект DB\Result, из которого можно получить данные с помощью метода fetch().
	$rows = BookTable::getList($parameters)->fetchAll();

runtime
Упоминаемые в 1-й части вычисляемые поля (ExpressionField) часто нужны не столько в описании сущности, сколько при выборке для различных вычислений с группировкой. Самый простой пример, подсчет количества записей в сущности.

В секции `runtime` можно регистрировать не только Expression поля, но и поля любых других типов. Механизм `runtime` работает таким образом, что к сущности добавляется новое поле, будто оно было описано в ней изначально в методе `getMap`. Но такое поле находится в зоне видимости только в рамках одного запроса - в следующем вызове getList такое поле уже будет недоступно, потребуется заново его зарегистрировать.

Все параметры getList, getRow и другие передаются вместе, при этом сразу же выполняется запрос и возвращается результат: все происходит за один вызов. Но существует и альтернативный способ конфигурации запроса и контроля за его выполнением - это объект Entity\Query.
Такой подход может быть удобным, когда необходима гибкость в построении запроса. Например, если параметры запроса заранее неизвестны и формируются программно, можно вместо множества разных аргументов использовать один объект Query, накапливая в нем параметры запроса.

В первую очередь нужно добавить числовое поле AUTHOR_ID, в котором будет храниться ID автора. На основе этого поля конфигурируется связь между сущностями через новый тип поля - ReferenceField. Это виртуальное поле, не имеющее фактического отражения в БД.
class BookTable extends Entity\DataManager
{
	...
	public static function getMap()
	{
		return array(
			...
			new Entity\IntegerField('AUTHOR_ID'),
			new Entity\ReferenceField(
				'AUTHOR',
				'SomePartner\MyBooksCatalog\Author',
				array('=this.AUTHOR_ID' => 'ref.ID'),
			)
		);
	}
	...
}

array('=this.AUTHOR_ID' => 'ref.ID') - описывает, по каким полям связаны сущности.

название сущности-партнера, с которым формируется отношение

Как выбрать автора книги понятно, поскольку в сущности Книги есть указание на связь с сущностью автора. 

Предыдущая выборка была "схлопнута" по уникальным значениям REGION, и для каждого такого значения было подсчитано количество "схлопнувшихся записей".

Именно так выглядела выборка перед тем, как началась группировка. Похоже, MySQL просто взял первые попавшиеся значения для каждого округа. Что это дает разработчику? Совершенно ничего - эти числа не имеют никакого смысла, их значения непредсказуемы. 

Важное правило: Если в выборке есть агрегация или группировка (агрегация по уникальному значению) хотя бы для одной колонки, то все остальные колонки из SELECT и ORDER BY должны быть так же агрегированы или сгруппированы.

Все дело в том, что сортировка происходит уже после группировки/агрегации данных. Неважно, что поле ID есть в исходной таблице - после группировки мы получаем новую виртуальную таблицу с агрегированными данными.

Исключением из правил именования классов и файлов являются классы сущностей ORM (наследников класса Bitrix\Main\Entity\DataManager). Имена таких классов формируются с суффиксом Table. (Например: CultureTable, LanguageTable.) А имя файла не содержит суффикса table. Такие классы также подключаются автоматически.

Примечание: Существует возможность вручную зарегистрировать класс в системе автозагрузки с помощью метода void 
	Bitrix\Main\Loader::registerAutoLoadClasses(
		$moduleName,
		array $arClasses
	)
Это можно использовать для объединения маленьких классов в один файл. 

Нестандартные классы (классы партнеров), должны находиться в собственных пространствах имен, совпадающих с названиями соответствующих партнеров. Каждый партнерский модуль определяет в пространстве имен партнера свое подпространство, совпадающее с именем модуля без имени партнера. Например, для модуля mycompany.catalog партнера "Mycompany" пространством имен будет MyCompany\Catalog. Остальные правила совпадают с правилами для стандартных модулей.
Для подключения модуля в новом ядре используется инструкция: 
	mixed Bitrix\Main\Loader::includeModule($moduleName);

Конкретные классы формирования SQL запросов, наследующие Bitrix\Main\DB\SqlHelper. Они помогают сформировать запрос не опускаясь до синтаксиса конкретной базы данных. 
Эти классы позволяют работать с базами данных на низком уровне, но это необходимо в небольшом числе случаев. Предпочтительно работать через ORM, которая позволяет программировать только на уровне бизнес-логики.

Получить соединение можно через приложения, которое, кроме всего прочего, является точкой входа. С этой точки входа можно получить экземпляры "звездных" объектов для данного приложения, которые нужны всем (или почти всем) страницам или компонентам данного приложения.

ПОДДЕРЖКА НОВОГО ТИПА БД
В редких случаях возникает необходимость подключения баз данных к которым невозможно использовать встроенный драйвер для PHP (например, у заказчика чрезвычайно устаревшая (или наоборот, слишком свежая) версия СУБД. Чтобы добавить в Bitrix Framework поддержку нового типа БД, необходимо:
Создать класс подключения (наследник Bitrix\Main\DB\Connection). В нем определить все базовые операции с БД: подключение, отключение, выполнение произвольного запроса, работу с транзакциями. 
Создать класс SQL-хелпер (наследник Bitrix\Main\DB\SqlHelper) и возвращать его экземпляр в методе createSqlHelper. Класс предназначен для самой низкоуровневой работы с БД: добавляет экранирование, работает с датами, предоставляет доступ к базовым SQL-функциям и так далее. 
Создать класс для результата выборки (наследник Bitrix\Main\DB\Result). В нем требуется определить методы-обертки над традиционными функциями работы с результатом выборки. 

Выполнение запроса, без получения результата. Это нужно в случае INSERT, UPDATE, DELETE.

Они подготавливают данные к выводу в html и в xml. Происходит преобразование специальных символов в html сущности.

Примечание: Кроме модуля Highload-блоки, в ядре D7 реализована возможность обращения к БД через HandlerSocket для всех сущностей ORM.

О ПРОИЗВОДИТЕЛЬНОСТИ И РЕСУРСАХ
Highloadblock - это прослойка между пользователем и ORM. ООП само по себе ведет к бо́льшему потреблению памяти и CPU, предлагая взамен более удобную и эффективную разработку. Highloadblock предназначены для высоких нагрузок. Их преимущества лежат в области архитектуры, то есть на них проще достичь масштабируемости, проще управлять разработкой, проще учитывать риски.
Выигрыш будет именно при работе с БД. Разработчик получает:
• отдельные таблицы для сущностей (что может стать заметным на больших объемах), 
• возможность легко расставлять индексы для нужных вам выборок, 
• возможность прозрачно использовать handlersocket, который может заметно снизить нагрузку на СУБД. 

Поскольку модуль Highload-блоки работает на новом ядре, то доступ к данным будет предоставляться на основе ORM.

В модуле Highload-блоки добавлена поддержка концепции NoSQL на основе базы данных MySQL. Соединение с базой данных предусмотрено как с помощью расширения handlersocket для MySQL, так и без него.
HandlerSocket позволяет клиентскому приложению подключаться напрямую к движку данных MySQL для устранения избыточной нагрузки, характерной для традиционных запросов через интерфейс SQL (SQL-клиент) и неприемлемой для высоконагруженных БД.

Разница между обращением через MySQL-клиент и через HandlerSocket заключается в том, что во втором случае минуется парсинг, открытие таблиц, оптимизация планов исполнения. То есть обращение происходит напрямую. Нагрузка на MySQL резко снижается. Запросы не выполняются быстрее, они меньше нагружают сервер.

Подключение HandlerSocket задаётся в файле настроек параметров ядра. Установить сам плагин можно либо скачав исходники MySQL и собрав плагин, либо установить PerconaServer или MariaDB, в которых он включён по умолчанию.

Веб-дизайн – это прежде всего разработка интерфейса, среды взаимодействия пользователя с информацией, а не просто «красивая картинка». Надо учитывать особенности веб-среды, такое понятие как удобство использования (usability), направленность на цели создания сайта. Важно учесть основные сценарии поведения пользователя, особенности целевой аудитории.

• файл .styles.php – описания стилей для визуального редактора страниц; 
• файл template_styles.css – стили шаблона (стили применяемые в самом шаблоне дизайна сайта); 
• файл styles.css – стили для контента и включаемых областей. Эти стили можно применять в визуальном редакторе. 

Для удобства отладки верстки, рекомендуется отключить сжатие и объединение css и js файлов. 

Примечание: Крайне не рекомендуется использование комплексных компонентов в шаблоне дизайна. Так как в этом случае правила переписывания адресов начинают работать для всего сайта. Это может отражаться на работе ЧПУ других компонентов и страницы /404.php. Комплексные компоненты должны находиться в #WORKAREA.

Шаблоны страниц и редактируемых областей хранятся в папке /page_templates/, находящейся в каталоге соответствующего шаблона сайта или в папке /bitrix/templates/.default/, если предполагается использование одинаковых шаблонов страниц для всех шаблонов сайта.

<link rel="icon" type="image/x-icon" href="<?=SITE_TEMPLATE_PATH;?>/images/favicon.ico" />

ОСОБЕННОСТИ РАБОТЫ С AJAX
Использование режима ajax имеет свои особенности. Чтобы строка навигации в открываемой по ajax странице имела в цепочке навигации своё название, необходимо, что бы в шаблоне обязательно присутствовал элемент с id="navigation". Это необязательно должен быть div, это может быть span, h1, p и так далее.
Аналогично, для заголовка обязательно наличие элемента с id="pagetitle".

Перейти к форме выполнения перевода языковых сообщений можно также непосредственно со страницы, на которой эти сообщения используются (как в публичной, так и административной части сайта). Для этого в адресную строку страницы нужно добавить параметр show_lang_files=Y.

Важно! Файл с включаемой областью должен быть сохранен в той же директории, что и страница, для которой он был создан. Включаемая область для раздела - в папке этого раздела. 

Обратите внимание, что параметр mbstring.func_overload определяется в глобальном файле настроек php.ini (или для виртуального сервера в httpd.conf), а кодировку можно переопределить в .htaccess.

Внимание! Если в качестве включаемой области будет использоваться вариант из файла, то необходимо проверить, что файл подключен из системы, а не вызван напрямую. Делается это с помощью следующей строки: 
	<?if(!defined("B_PROLOG_INCLUDED") || B_PROLOG_INCLUDED!==true)die();?>. 
Пример содержимого включаемого файла: <?if(!defined("B_PROLOG_INCLUDED") || B_PROLOG_INCLUDED!==true)die();?>
  <div class="bx-main-title">World Book</div>
  <span class="bx-main-subtitle">Все книги мира</span>

В самом общем случае на сайте существует одно "основное" меню, соответствующее самому верхнему уровню иерархии и отображаемое во всех разделах сайта. Также в системе часто используется "второстепенное" меню (или меню второго уровня), включающее ссылки на подразделы и документы текущего раздела.

Например, т.к. основное меню (в демо-версии продукта, это меню типа top) должно выводиться во всех разделах, то файл данного меню помещается только в корневой каталог сайта.
Соответственно меню второго уровня (в демо-версии продукта, это меню left) выводится отдельно для каждого раздела сайта. Поэтому в папке каждого раздела создается свой файл для данного типа меню.

Если в одном из каталогов найдено меню, то поиск останавливается и в последующих каталогах уже не ищется. 

Система Bitrix Framework позволяет также создавать меню динамического типа. Т.е. массив данных таких меню генерируется автоматически на основании некоторых данных, получаемых с помощью программного кода. Данный код должен храниться в папке соответствующего раздела сайта в файле с именем .<тип меню>.menu_ext.php. Основная задача подобных файлов - это манипуляция массивом $aMenuLinks.

Реализует меню с выпадающими пунктами меню нижнего уровня, что сохраняет легкость восприятия структуры сайта посетителем, характерное для древовидного меню, но при этом не растягивает дизайн при разветвленной структуре.

Быстрый доступ к редактированию шаблона каждого типа меню можно осуществить в режиме Правки с помощью пункта Редактировать шаблон компонента меню команд кнопки по управлению компонентом. 

Меню будет создано для раздела, папка которого открыта в данный момент в Менеджере файлов. 
... создается файл данных меню
... редактировать пункты меню в визуальном режиме

• набор дополнительных ссылок, которые соответствуют этому же пункту меню. В данном поле задается набор ссылок на страницы, при переходе на которые будет также подсвечиваться данный пункт меню. Например, чтобы при просмотре любой страницы раздела Каталог книг подсвечивался пункт меню Каталог книг, в данном поле нужно указать ссылку на папку, содержащую все страницы раздела (или перечислить необходимые страницы): /e-store/books/; 
• дополнительные параметры – набор произвольных параметров, которые могут быть обработаны в шаблоне показа меню и представлены соответствующим образом. Например, если пункт меню является заголовком секции, это может быть указано в параметрах пункта так: название параметра - SEPARATOR, значение - Y. При разработке шаблона можно проверять значение этого параметра и при показе выделять данный пункт меню разделителем. 
Параметры хранятся в ассоциированном массиве $PARAMS в виде пар имя => значение. При построении меню по шаблону, в самом шаблоне может быть добавлена проверка параметра, например:
	if ($PARAMS["MY_PARAM"]=="Y");
Примечание: При желании количество дополнительных параметров в форме можно увеличить с помощью соответствующей опции в настройках модуля Управление структурой, секция Настройки для сайтов.

Древовидное меню создается на базе статических и динамических элементов: разделов, страниц и инфоблоков.

Необходимо иметь два типа меню. Одно (первичное) будет применено как основное меню в разделе, другое (вторичное) – как источник формирования собственно выпадающего меню.

КАК СДЕЛАТЬ, ЧТОБЫ ОТДЕЛЬНЫЙ ПУНКТ МЕНЮ ОТКРЫВАЛСЯ В НОВОМ ОКНЕ?
Для этого нужно в расширенном режиме редактирования меню прописать у нужных пунктов следующие дополнительные параметры:
	Название: target 
	Значение: target="_blank"
В шаблоне меню, после вывода элемента меню, необходимо заменить код: 
	<a href="<?=$arItem["LINK"]?>"><?=$arItem["TEXT"]?></a>
на следующий:
	<a href="<?=$arItem["LINK"]?>" <?=$arItem["PARAMS"]["target"]?>><?=$arItem["TEXT"]?></a>

Для этого в расширенном режиме редактирования меню в поле Тип условия необходимо выбрать опцию Для папки и файла, а в поле Условие указать путь.

Примечание: Условие Для папки и файла лучше всего применять для статических страниц и для динамических страниц с компонентами на ЧПУ. На динамических страницах без ЧПУ он не будет работать, так как производит проверку по части адреса, а в динамических страницах всегда будут присутствовать выбранные значения. Для динамических URL удобнее применять условие Параметр в URL.

Для этого можно использовать тип условия Параметр в URL. Пункт будет отображен на страницах с определенным параметром в URL. Параметр работает с URL, в которых есть символ ?. То есть, с динамическими страницами. 

Само меню "выводится" в футере, если свойство hide_menu не установлено в значение Y. Но оно не выводится на самом деле в футере, а отправляется в свойство menu, которое "выше" по коду можно показать "отложенно" через ShowProperty. Если меню запрещено, то в значении свойства menu будет пусто и ничего не покажется в шаблоне. Если не запрещено, то для этого примера - там, где прописано $APPLICATION->ShowProperty('menu'), будет выведена фраза проверка отложенного меню!.
(c. 104)

Именно заголовки разделов берутся для создания пунктов навигационной цепочки.

В системе функция
	$APPLICATION->SetPageProperty('title','Альтернативный заголовок');
имеет приоритет над функцией
	$APPLICATION->SetTitle("Заголовок страницы");
поэтому в заголовке браузера и страницы будет отображено именно ее содержимое: 'Альтернативный заголовок'.
Если передать параметр false
	$APPLICATION->ShowTitle(false);
значение свойства страницы SetPageProperty('title','Альтернативный заголовок') будет игнорироваться и в качестве заголовка страницы будет использован заголовок, установленный функцией SetTitle().

Обратите внимание! Значения свойств, заданные для папки, по умолчанию будут использоваться для всех страниц и подразделов соответствующего раздела сайта (если для них не заданы собственные значения этих свойств).

Если для самой страницы значение свойства не задано, то будет взято значение свойства вышестоящего раздела (рекурсивно до корня сайта). Если значение свойства не определено, то значение соответствующего мета-тэга останется незаданным. Свойства страницы могут быть установлены динамически из кода компонентов, расположенных на странице. Например, для страниц показа информации каталога или новостей свойства страницы могут быть установлены в соответствии с определенными свойствами элементов инфоблоков:
	$APPLICATION->SetPageProperty("description",$arIBlockElement["PROPERTIES"][$META_DESCRIPTION]["VALUE"]);
В данном случае в качестве значения свойства страницы description будет использовано значение свойства элемента информационного блока с кодом meta_description. Таким образом, можно создавать свойства keywords и description для элементов каталога и динамически подставлять их в код страницы.

Таблицы стилей для представления внутреннего содержания страниц сайта хранятся в файлах вида styles.css папки соответствующего шаблона.

В продукте добавлен механизм, позволяющий осуществлять раздельное хранение стилей: 
• стили, используемые в шаблоне дизайна, хранятся отдельно в файле template_styles.css. Это - основной CSS-файл шаблона. 
• стили, используемые при оформлении контента страниц (стили сайта), хранятся в файле styles.css. Стили из этого файла выводятся в выпадающем списке стилей при редактировании страниц в визуальном редакторе. 
Разграничивать назначение этих файлов можно условно, исходя из контекста. Точнее в файле styles.css возможно располагать те стили, которые должны формировать отображение контента не только для всего шаблона, но и для визуального редактора.

Файлы на странице сайта подключаются в таком порядке:
	styles.css 
	template_styles.css 

Важным элементом при создании таблицы стилей страниц является создание названий стилей. Названия следует создавать только для тех стилей, которые планируется использовать при редактировании страниц в режиме визуального HTML-редактора (секция Описания стилей). Заданные здесь названия будут храниться в файле идентификатор_шаблона>/.styles.php (файл с именами стилей).

Чтобы подключать сторонние стили в визуальном редакторе, например Bootstrap и Font Awesome, нужно прописать данную возможность в файле description.php, находящемся в папке шаблона сайта:
	"EDITOR_STYLES" => array (
			'/bitrix/css/main/bootstrap.css',
			'/bitrix/css/main/font-awesome.css',

Функция ShowCSS() выполняет подключение файла стилей из текущего шаблона сайта, а также всех дополнительных стилей определенных для данной страницы функцией SetAdditionalCSS().

Примечание: Служебный код, вставляемый автоматически несколько устарел. Правильнее будет заменить
	<?$APPLICATION->ShowCSS();?>
	<?$APPLICATION->ShowHeadStrings()?>
	<?$APPLICATION->ShowHeadScripts()?>
на
	<?$APPLICATION->ShowHead()?>

Лучше размещать картинки в специальной папке самого шаблона (/bitrix/templates/test/images/). 

Чем шире применяются компоненты, тем более трудоемка и сложна работа по созданию сайта, но проще его поддержка.

Примечание: Если у вас включено кеширование компонентов, то возможна ситуация, когда после внесения изменений в шаблоны компонента или его файл стилей вы не заметите этих изменений. В этом случае надо просто обновить кеш компонента воспользовавшись кнопкой Обновить на Административной панели. А лучше отключить кеширование на период работы с дизайном совсем.

Примечание: Обратите внимание на определенную логику расположения информации в файлах компонента. Вот она: system.auth.form/auth/lang/ru/. Эта структура типична для всех компонентов системы: имя_компонента/применяемый_шаблон/языковая_папка/конкретный_язык. В папке конкретного языка расположены все текстовые значения, используемые в этом шаблоне. Так вы можете поменять тексты в любом компоненте.

/bitrix/templates/test/images/login.gif
<input type="image" src="<?=$templateFolder?>/images/login.gif" alt="<?=GetMessage("AUTH_LOGOUT_BUTTON")?>">

Ведь в разных разделах сайта может потребоваться вывод разных данных в этой колонке. Если такая потребность возникнет, то придётся создавать новый шаблон с новым компонентом (и соответственно впоследствии поддерживать его). Мы поступим по-другому. Создадим в этом месте Включаемую область и при необходимости будем наполнять её нужным контентом в нужном разделе.

Для создания полноценного сайта необходимо интегрировать в шаблон компоненты. Для этого необходимо выделить в дизайне сайта блоки, которые содержат динамическую информацию (вместо них будет размещен вызов компонентов) и блоки, информация в которых должна изменяться пользователем без изменения шаблона (это будут включаемые области). 

Компоненты версии 2.0 подключаются в коде страницы с помощью функции IncludeComponent(). В качестве параметров функции используется:
• название компонента в форме <пространство_имен>:<название_компонента>. Причем название компонента рекомендуется строить иерархически, начиная с общего понятия и заканчивая конкретным назначением компонента. Например, catalog, catalog.element, catalog.section.list и т.п. 
• название шаблона. Шаблон компонента "по умолчанию" можно задавать пустой строкой, также можно явно определять .default 
• массив параметров компонента Array(...) 

"PATH" => $APPLICATION->GetTemplatePath("include_areas/company_name.php")

В файле включаемой области не требуется подключать пролог и эпилог (файлы header.php и footer.php). Необходимо лишь проверить, что файл включаемой области подключен из системы, а не вызван напрямую.
	<?if(!defined("B_PROLOG_INCLUDED") || B_PROLOG_INCLUDED!==true)die();?>

Проверка, вызван ли этот файл напрямую или нет. Если напрямую – прекратить работу.
	<?if (!defined("B_PROLOG_INCLUDED") || B_PROLOG_INCLUDED!==true)die();?>
Если массив с пунктами меню $arResult не пуст, то выполнять дальнейшие действия
	<?if (!empty($arResult)):?>

В строке 5а ввели переменную $cnt с единственной целью – отследить первый элемент списка.

Кроме того, у нас нет необходимости в специализированных стилях и картинках для этого шаблона. Поэтому нужно удалить из каталога /bitrix/templates/.default/components/menu/top_menu/ файл style.css и папку /images/. 

При создании структуры нельзя забывать про служебные страницы - поиск и карту сайта.

Информационные блоки представляют собой очередной уровень абстракции над обычными таблицами СУБД, своеобразная "база данных в базе данных". Инфоблоки - сущность, которая в физической структуре БД создает 4 таблицы, не меняющиеся при изменении структуры данных: типы объектов, экземпляры объектов, свойства объектов и значения свойств объектов.

Штатные средства модуля Информационные блоки достаточно обширны. Не ограничено ни количество типов инфоблоков, ни число самих инфоблоков, ни количество свойств каждого инфоблока, ни количество разделов или элементов.

Свойства, задаваемые для инфоблока, различаются по своим типам. Каждый тип свойств характеризуется собственным набором параметров, настраиваемых в соответствующих формах. Свойства могут быть множественными, обязательными для заполнения.

Примечание: начиная с версии модуля 14.0.5, уровень глубины вложенности разделов для CSV-экспорта/импорта определяется настройками модуля Информационные блоки. 

Примечание: если нужно осуществить экспорт инфоблока как торгового каталога, то необходимо воспользоваться путем Магазин > Настройки > Экспорт данных. Возможен и импорт из файла формата CSV: в качестве торгового каталога. В этом случае необходимо воспользоваться путем Магазин > Настройки > Импорт данных.

При редактировании свойств (смена признака множественности или типа свойства) для свойств в выделенном хранилище выполняются дополнительные операции по управлению таблицами. Такие как удаление/добавление колонок, вставка/обновление или удаление большого количества записей. Без настоятельной необходимости лучше избегать этого. Наилучшей методикой будет менять тип или множественность одного свойства за один раз. Причем для единичных свойств предпочтительнее сначала сделать его множественным а потом сменить тип, а для множественных наоборот - сначала тип, и уже потом делать его единичным.

Оценить возможность использования PROPERTY_* в сочетании с инфоблоками 2.0. Инфоблоки 2.0 хранят свои свойства в отдельной таблице. Эта таблица при упоминании PROPERTY_* присоединяется на этапе выборки. И до выборки значения свойств присоединение этих свойств не происходит. 

"><" - между;

Столь впечатляющих результатов при использовании фасетного индекса удалось добиться за счет того, что работа по выборке данных, их группировке и анализу большей частью проводится в момент индексации.

API модуля Инфоблоки состоит из нескольких высокоуровневых функций для выборки данных в публичном разделе сайта и набора классов с низкоуровневыми методами для более специализированной работы.

Перед использованием модуля Инфоблоки необходимо проверить, установлен ли он, и подключить его при помощи конструкции:
	if(CModule::IncludeModule("iblock"))
	{
	   //здесь можно использовать функции и классы модуля
	}

Классов для работы с типами инфоблоков, инфоблоками, элементами, разделами, полями. 

Теперь символьный код свойства является ключом ассоциативного массива $PROPS, то есть, если вам нужно значение свойства с кодом price, то оно будет храниться в $PROPS['price'].

В $ITEMS хранятся значения множественного свойства, которое нужно забить.

foreach($ITEMS as $item)
{
	$VALUES[]['VALUE'] = array(
		'TYPE' => 'text', // или html
		'TEXT' => $item,
	);
}


Задача 4: Заполнить множественное свойство типа Файл. Довольно часто при добавлении элемента в инфоблок может понадобиться привязать к нему несколько файлов. Для этого удобно создать у инфоблока множественное свойство типа Файл и хранить файлы в нём. Пример заполнения свойства:
	$arFiles = array();
	for($i = 1; $i < 10; $i++)
	{
		if(file_exists($_SERVER['DOCUMENT_ROOT'].'/images/image_'.$i.'.jpg'))
		{
			$arFiles[] = array('VALUE' => CFile::MakeFileArray($_SERVER["DOCUMENT_ROOT"]
			.'/images/image_'.$i.'.jpg'), 'DESCRIPTION' => '');
		}
	}
После этого массив $arFiles передается как значение свойства при добавлении элемента.

При использовании любого метода на ключ массива обновления идет символьный код свойства, а значение - новое значение.

И любое свойство, тип которого предполагает форматирование значения перед выводом, будет соответствующим образом преобразовано.

При манипуляциях с данными таблички b_iblock_iproperty (когда мы шаблон изменяем, удаляем, добавляем) никаких вычислений не производится, выполняется только сброс вычисленных ранее дочерних значений. Операция вычисления откладывается до момента востребования (чтения) значений. В этот момент происходит поиск шаблонов снизу вверх по иерархии инфоблоков (для элемента это будут шаблоны собственно элемента, его разделов вверх до корневого и шаблоны инфоблока). Затем шаблоны вычисляются и полученные значения сохраняются в таблицы кеша, откуда и будут браться при последующих операциях чтения

Создаем экземпляр класса

Чтобы выбирать данные, которые вычисляются в процессе выборки по заданным шаблонам, используем метод getValues (его можно встретить в компонентах инфоблоков, чтобы SEO свойства выбрать и поставить их на странице).

if (\Bitrix\Main\Loader::includeModule('iblock'))
if (strlen($_POST['DETAIL_TEXT'])<=0)
if(($ar = $dbr->Fetch()) && $ar['DETAIL_PICTURE']>0)

//метод htmlEncode формирует безопасный html
echo \Bitrix\Main\Text\HtmlFilter::encode(
	//Вычисляем значение по шаблону.
	Template\Engine::process($entity, $template) 
);

Конструктор объекта _CIBlockError принимает три параметра: степень серьезности ошибки, произвольный идентификатор и текст ошибки. Если на странице редактирования определить переменную $error со значением этого объекта, то сохранения внесённых изменений не произойдет. Для того чтобы значения, пришедшие из формы, не потерялись, после инициализации переменной $error также инициализируйте переменную $bVarsFromForm=true. Переменная $bVarsFromForm как раз указывает, что значения в полях необходимо показывать те, которые пришли из формы.

Если для публикации информационного блока используются простые компоненты, то можно сделать фильтрацию элементов без использования компонента Фильтр и без кастомизации компонента, с помощью которого выводится список элементов. Такая фильтрация основана на использовании параметра Имя массива со значениями фильтра для фильтрации (FILTER_NAME) и доступна в следующих компонентах: bitrix:catalog.section, bitrix:catalog.sections.top и bitrix:news.list.

//FILES - символьный код множественного свойства типа файл;

//Эту строчку можно раскомментировать и посмотреть содержимое arResult
//того компонента под который будет адаптирован этот модификатор
//echo "<pre>",htmlspecialchars(print_r($arResult, 1)),"</pre>";

Компоненты делятся на простые (одностраничные) и комплексные (многостраничные). Простой компонент реализует вывод на одной физической странице, доступной под конкретным URL. Комплексный заменяет собой набор простых компонентов. Например, создание новостного раздела можно реализовать несколькими простыми компонентами, размещаемыми каждый на отдельной физической странице, а можно - одним комплексным, размещенным на одной физической странице.
Простые (обычные, одностраничные) компоненты создают какую-либо область на одной странице. Их удобно использовать, когда на одной странице требуется разместить данные из различных модулей (блоги и инфоблоки, например) или данные из разных инфоблоков (новости и каталог товаров).
Комплексные компоненты создают разделы сайта. Например, компонент каталога создает на сайте весь раздел каталога. То есть, комплексный компонент состоит из набора динамических страниц при просмотре сайта, но из одной статической страницы на физическом уровне. Комплексные компоненты строятся на основе простых компонентов, используя их логику. Преимущество комплексных компонентов в автоматической компоновке параметров одностраничных компонентов и отсутствии необходимости их связывать.

Алгоритм работы комплексного компонента таков:
1. на основании действий посетителя сайта (например, переход по пунктам меню) комплексный компонент определяет, какая страница должна быть показана пользователю, и подключает свой шаблон компонента для этой динамической страницы; 
2. шаблон страницы подключает обычные компоненты, автоматически настраивая необходимым образом их свойства; 
3. обычные компоненты выполняют свою работу: запрашивают данные у ядра системы, форматируют их и выводят посетителю, а также предоставляют пользователю различные элементы управления (ссылки, формы, кнопки и т.п.); 
4. пользователь с помощью каких-либо элементов управления, посылает новый запрос комплексному компоненту

Страницы шаблона комплексного компонента будут содержать подключение соответствующих обычных компонентов с правильной настройкой их входных параметров. Обычные компоненты будут выполнять свои обычные функции: им все равно, кто их вызвал и зачем. Для обычных компонентов важна только правильная настройка их входных параметров.

Комплексный компонент служит для организации целого раздела сайта (форум, каталог и т.п.). Для вывода данных он подключает обычные компоненты. По сути, он является контроллером (менеджером) простых компонентов. Комплексный компонент определяет на основании HTTP запроса страницу, которую требуется вывести посетителю, и подключает шаблон этой страницы. 

ТАКИМ ОБРАЗОМ РЕАЛИЗУЕТСЯ ПАТТЕРН MVC:
• на комплексный компонент новостей (controller) приходит HTTP запрос (действия пользователя); 
• комплексный компонент новостей (controller) проверяет, установлен ли через HTTP запрос код новости и подключает из своего шаблона страницу списка новостей или страницу детальной новости (view); 
• подключенная страница, в свою очередь, подключает соответствующий обычный компонент, устанавливая при этом его входные параметры соответствующим образом; 
• обычный компонент выполняет свою работу: запрашивает данные у ядра (model), форматирует их и выводит посетителю, а также отображает элементы управления (ссылки, формы, кнопки и т.п.); 
• пользователь с помощью элементов управления посылает новый HTTP запрос на комплексный компонент новостей (controller); 
• процедура повторяется по мере надобности. 

Название подпапки директории /bitrix/components/ образует пространство имен (namespace) компонентов.

<?$APPLICATION->IncludeComponent(
	$componentName,				// имя компонента
	$componentTemplate,			// шаблон компонента, пустая строка если шаблон по умолчанию
	$arParams=array(),			// параметры
	$parentComponent=null,		// null или объект родительского компонента
	$arFunctionParams=array()
);?>
Внутри компонента (файл component.php) доступны следующие предопределенные переменные: 
$arParams – входные параметры компонента (т.е. параметры с которыми вызывается компонент). Параметры доступны так же по их именам. 
...
$this — естественно ссылка на текущий вызванный компонент (объект класса CBitrixComponent), можно использовать все методы класса. 
Кроме того, в компоненте объявлены глобальными переменные $APPLICATION, $USER, $DB.

Примечание: Компонент получает все параметры вызова следующим образом: 
1. В ключах, начинающихся с ~, данные содержатся в исходном виде (т.е. без всякой обработки). 
Если это комплексный компонент или в шаблоне компонента вызывается другой и часть параметров передается ему, то необходимо передавать значение ключей с ~. 
2. В ключах без ~ данные приведены к безопасному виду с помощью метода htmlspecialcharsEx. Если ключ содержит массив, то будут обработаны строковые ключи массива (тоже с помощью htmlspecialcharsEx). 

Файл component.php, который содержит логику (код) компонента. Задача этого файла - сформировать из полученных параметров ($arParams) массив $arResult, который впоследствии попадет в шаблон компонента.

В папке /lang для каждой языковой версии создаётся папка с названием языка (например, /ru, /en и т.п.), в которой и размещаются файлы языковых сообщений. Рекомендуется называть файл языковых сообщений для какого-либо файла компонента так же, как называется этот файл. В этих файлах находятся массивы, ключами для которых являются идентификаторы констант, а значениями - сами константы, переведенными на соответствующий язык.

В файле - массив $MESS, в котором ключами являются параметры компонента c добавлением суффикса _TIP, значениями - подсказки:
	$MESS["IBLOCK_TYPE_TIP"] = "Это подсказка для типа инфоблока";

Страница детальной информации об элементе инфоблока (например, карточки товара).

Входной параметр с предопределённым именем SEF_FOLDER имеет смысл в том случае, если компонент работает в режиме ЧПУ. В этом случае он содержит путь, по которому работает компонент. Путь может быть виртуальным (т.е. физически он может не существовать). Например, компонент из примера может лежать в файле /fld/n.php, при этом он работает в режиме ЧПУ и входной параметр SEF_FOLDER равен /company/news/. Тогда компонент будет откликаться на запросы по адресам /company/news/index.php, /company/news/25.php и т.п. 

CComponentEngine::ParseComponentPath(
	$arParams["SEF_FOLDER"],
	$arUrlTemplates, $arVariables
);
Метод на основании параметра $arParams["SEF_FOLDER"] и массива шаблонов путей (который вернул метод MakeComponentUrlTemplates) определяет, какому шаблону пути соответствует запрошенный адрес. Если шаблон был найден, возвращается его код, иначе возвращается пустая строка. Кроме того, в переменной $arVariables возвращается массив переменных компонента, который был восстановлен из шаблона пути без параметров.
Например, если массив шаблонов путей (который получился из массива $arDefaultUrlTemplates404 после переопределения всех или части шаблонов через входные параметры компонента) имеет вид:
	$arUrlTemplates = array(
		"list" => "index.php",
		"element" => "#IBLOCK_ID#/#ELEMENT_ID#.php?SID=#SECTION_ID#"
	);
Если входной параметр SEF_FOLDER равен /company/news/, а запрошенный адрес равен /company/news/15/7653.php?SID=28, то метод ParseComponentPath вернет строку "element" (код соответствующего шаблона), а массив $arVariables будет иметь вид:
	$arVariables = array(
		"IBLOCK_ID" => 15,
		"ELEMENT_ID" => 7653
	)

Массив переменных, которые компонент может принимать в HTTP запросе и которые могут иметь псевдонимы.

В случае работы компонента в режиме ЧПУ на основании кода шаблона пути и переменных из HTTP запроса (а в случае не-ЧПУ адресов, только на основании переменных из HTTP запроса) компонент определяет, какая страница из шаблона компонента должна подключится, и передает ее имя в вызов метода: 
	$this->IncludeComponentTemplate($componentPage);
На страницах шаблона комплексного компонента подключаются обычные компоненты и настраиваются их входные параметры на основании входных параметров комплексного компонента, некоторых вычисляемых значений и констант. Например, страница "element" шаблона компонента из примера (файл типа /templates/.default/element.php относительно папки компонента) может иметь вид типа: 
	<?if(!defined("B_PROLOG_INCLUDED") || B_PROLOG_INCLUDED!==true)die();?>
	<?$APPLICATION->IncludeComponent(
		"bitrix:news.detail",
		"",
		Array(
			"IBLOCK_ID" => $arParams["IBLOCK_ID"],
			"ELEMENT_ID" => $arResult["VARIABLES"]["ELEMENT_ID"],
			"SECTION_ID" => $arResult["VARIABLES"]["SECTION_ID"],
			"CACHE_TIME" => $arParams["CACHE_TIME"],
		),
		$component
	);?>
Последний параметр $component в подключении компонента - объект, представляющий текущий компонент. Он передается в вызов подключения компонента. Таким образом, подключаемый компонент будет знать, что он подключается из комплексного компонента. Соответственно, он сможет пользоваться ресурсами комплексного компонента, вызывать его методы и т.п.

Только комплексные компоненты могут работать в режиме ЧПУ или переопределять переменные HTTP запроса.

"PATH" - расположение компонента в виртуальном дереве компонента в визуальном редакторе.

Если необходимо, производится выборка каких-либо дополнительных данных.

Код группы "SEF_MODE" - группа для всех параметров, связанных с использованием ЧПУ. 

arPropList[$arProp['ID']] = $arProp['NAME'];

В ядре D7 есть элемент управления, позволяющий указывать цвет (COLORPICKER). Для этого укажите в файле параметров компонента .parameters.php:
	$arComponentParameters["PARAMETERS"]["COLOR"]  = Array(
		"PARENT" => "BASE",
		"NAME" => 'Выбор цвета',
		"TYPE" => "COLORPICKER",
		"DEFAULT" => 'FFFF00'
	);

При копировании шаблона компонента средствами системы, они будут расположены по следующему пути:
/local/templates/шаблон_сайта/components/namespace/название_компонента/название_шаблона. 

Шаблоны компонента определяются по именам. Шаблон по умолчанию имеет имя .default. Если в настройках параметра компонента не указывается имя шаблона, вызывается шаблон по умолчанию.

Шаблоны компонента могут быть папками или файлами. Если шаблону не требуется перевод на другие языки, собственные стили и прочие ресурсы, такой шаблон можно расположить в файле. В противном случае шаблон следует располагать в папке.

$arResult – массив результатов работы компонента. 
$arParams – массив входящих параметров компонента, может использоваться для учета заданных параметров при выводе шаблона. 
$templateData — массив для записи, обратите внимание, таким образом можно передать данные из template.php в файл component_epilog.php, причем эти данные попадают в кеш, т.к. файл component_epilog.php исполняется на каждом хите. 

Путь относительно корня сайта к папке шаблона комплексного компонента, в составе которого подключается данный компонент.

• result_modifier.php подключается непосредственно перед шаблоном компонента. Он получает на вход массив результатов работы компонента $arResult и массив входных параметров вызова компонента $arParams. Таким образом, можно, например, изменить массив результатов работы компонента под конкретный шаблон. 
• component_epilog.php подключается после исполнения шаблона. 
• .description.php название и описание шаблона для визуального редактора. 
• .parameters.php содержит описание дополнительных входных параметров шаблона для визуального редактора. 

КАК СИСТЕМА ИЩЕТ ШАБЛОН:
• Если используется шаблон сайта из папки \local , то система сначала ищет шаблон компонента в папке /local/templates/текущий_шаблон_сайта/components/.
• Если там шаблон не найден, то берётся папка /local/templates/.default/components/. Если шаблон найден, то поиск прекращается.
• Если используется шаблон сайта из папки /bitrix/templates/, то берется папка /bitrix/templates/текущий_шаблон_сайта/components/. В этой папке в пути /пространство_имен_компонента/название_компонента/ проверяется последовательно наличие файла или папки с именем шаблона. Если таковых нет, то проверяется наличие файла имя_шаблона.ext, где в качестве ext берутся последовательно все доступные расширения всех установленых на сайте движков шаблонизации. Если шаблон найден, то алгоритм завершается.
• Если на шаге 1 шаблон не найден, то берется папка /bitrix/templates/.default/components/. И применяется алгоритм, описанный в шаге 1. Если шаблон найден, то алгоритм завершается.
• Если на шаге 2 шаблон не найден, то производится поиск среди системных (т.е. поставляемых с компонентом) шаблонов.
ОСОБЕННОСТИ ПОИСКА:
• Если имя шаблона не задано, то ищется шаблон с именем .default. 
• Если шаблон задан именем папки, то в случае простого компонента в этой папке ищется файл template.ext, а в случае комплексного - название_страницы.ext. Расширение ext сначала принимается равным php, а затем расширениям других доступных на сайте движков шаблонизации. 

В одной папке (например, /bitrix/templates/текущий_шаблон_сайта/components/) есть шаблоны двух компонентов, комплексного и простого:
• catalog (комплексный, в котором есть еще простой catalog.section) 
• catalog.section (простой) 
По условиям работы сайта необходимо чтобы для двух вхождений catalog.section использовался один единственный шаблон. В этом случае нужно, чтобы этот шаблон имел имя, отличное от .default, иначе он не будет подхвачен.

/local/templates/<имя шаблона сайта>/components/<namespace>/<имя компонента>/<имя шаблона>/template.php.

$templateData - массив для записи, передающий данные из template.php в файл component_epilog.php, данные кешируются, т.к. файл component_epilog.php исполняется на каждом хите.

В файле result_modifier.php можно запросить дополнительные данные и занести их в массив результатов работы компонента $arResult. Это может оказаться полезным, если требуется вывести на экран какие-либо дополнительные данные, но не хочется кастомизировать компонент и отказываться от его поддержки и обновлений.

Примечание: файл result_modifier.php запускается только перед подключением шаблона. В случае "обычного" кеширования шаблон не подключается. И через него не получится устанавливать динамические свойства типа: title, keywords, description.

Файл component_epilog.php подключается после исполнения шаблона. Аналогично файлам стилей, родительский компонент сохраняет в своем кеше список файлов эпилогов всех шаблонов дочерних компонентов (возможно вложенных), а при хите в кеш подключает эти файлы в том же порядке, как они исполнялись без кеширования. Точно так же при вызове дочерних компонентов в шаблоне нужно передавать значение $component.
В файле component_epilog.php доступны $arParams, $arResult, но эти значения берутся из кеша.

Файл component_epilog.php подключается непосредственно после подключения и исполнения шаблона. Таким образом, если в компоненте идёт подключение шаблона, а затем в коде компонента следуют ещё операции, то они будут выполнены уже после выполнения файла component_epilog.php.

Задача: языковые фразы компонента по результатам работы файла component_epilog.php должны быть иными, чем в самом компоненте. В этом случае надо учитывать что размещать текстовые фразы в /lang/ru/template.php для файла component_epilog.php нет смысла: при попадании в кеш языковый файл не подключается.
Решение: создавать файл /lang/ru/component_epilog.php и самостоятельно подключить его кодом:
	use \Bitrix\Main\Localization\Loc; 
	Loc::loadLanguageFile(__FILE__); 
	Loc::getMessage("MY_MESS");

В комплексные компоненты встроена функция генерации ЧПУ. У этих компонентов всегда есть входной параметр SEF_MODE, который может принимать значения Y и N. Если параметр SEF_MODE равен N, то компонент работает с физическими ссылками и все параметры передает через стандартные параметры HTTP запроса. Например:
	/fld/cat.php?IBLOCK_ID=12&SECTION_ID=371 
Если параметр SEF_MODE равен Y, то компонент генерирует и обрабатывает ссылки на основании шаблонов. Например, он может понять и обработать ссылку:
	/catalog/section/371.php?IBLOCK_ID=12, даже если сам он лежит в файле /fld/cat.php.
Если параметр SEF_MODE равен Y, то у компонента должен так же присутствовать параметр SEF_FOLDER, который должен содержать путь до папки, с которой работает компонент. Этот путь может как совпадать с физическим путем, так и не совпадать. Например, в компоненте bitrix:catalog, подключенном в файле /fld/cat.php, могут быть установлены параметры SEF_MODE = Y и SEF_FOLDER=/catalog/. Тогда компонент будет отвечать на запросы по пути /catalog/...

При сохранении страницы с компонентом, работающим в SEF режиме, в редакторе создается или обновляется запись в системе urlrewrite. Например, при сохранении файла /fld/cat.php, в котором лежит компонент bitrix:catalog, переключенный в SEF режиме с параметром SEF_FOLDER=/catalog/, в системе urlrewrite создается или обновляется запись типа:
	array( 
		"CONDITION" => "#^/catalog/#", 
		"ID" => "bitrix:catalog", 
		"PATH" => "/fld/cat.php" 
	),
• в CONDITION записывается значение параметра SEF_FOLDER, обрамленное символами «#^» и «#»; 
• в ID записывается название компонента; 
• в PATH записывается физический путь к файлу, который сохраняется. 
Если запись с таким PATH и ID уже есть, то она обновляется, если нет – добавляется.
В run-time при запросе физически не существующей страницы механизм urlrewrite производит поиск соответствующей записи по CONDITION и передает управление на страницу PATH.
Компонент на странице PATH на основании шаблонов путей выясняет запрашиваемую страницу и восстанавливает переменные, спрятаные в пути.

ОШИБКА: не удалось обнаружить код вызова компонента. Может возникать, если код вызова компонента не взят в отдельные <? ?>. 
РЕШЕНИЕ: проверить отделенность кода компонента от другого php-кода на странице.
Необходимо, чтобы было так:
<? php-код ?>
<? компонент ?>
<? php-код ?>

Таким образом, также можно реализовывать дополнительный функционал проекта. Этот способ рекомендуется использовать в крайнем случае. За правило должно браться изменение логики работы за счет кастомизации подходящего компонента, либо его шаблона.
Внимание! PHP-код непосредственно в теле страницы не рекомендуется!

Для ускорения обработки запроса клиента и уменьшения нагрузки на сервер компоненты должны использовать кеширование. Кешировать, как правило, необходимо ту информацию, которая не зависит от конкретного обратившегося человека. Например, список новостей сайта идентичен для всех посетителей. Поэтому нет смысла выбирать данные каждый раз из базы.

Чтобы обновить содержимое закешированных объектов на странице...

Это может делать только разработчик решения, основываясь на реальных потребностях конкретного проекта: необходимо указывать в настройках компонентов время кеширования, адекватное периодичности обновления информации.

Иначе кеш будет сброшен по истечении времени кеширования, кнопкой обновить кеш на панели инструментов публичной части или полной очисткой кеша из административной части.

***
В $arParams содержится набор параметров компонента, component.php работает с входными параметрами запроса и базой данных, формирует результат в массив $arResult. Шаблон компонента преобразует результат в текст HTML.
При первом хите сформированный HTML попадает в кеш. При последующих хитах запросов в базу не делается (или делается мало), данные читаются из кеша.

Типичная ошибка: в шаблоне компонента вызываются отложенные функции: $APPLICATION->SetTitle(), $APPLICATION->AddChainItem() и т.д. В этом случае они работают только при выключенном кешировании.
При разработке шаблонов собственных компонентов надо следовать простому правилу: задача шаблона - на основе входного массива $arResult сформировать текст HTML на выходе.

В модуле инфоблоков CIBlockElement::GetList и CIBlockSection::GetList возвращают объект класса CIBlockResult.

Не забудьте в параметрах подключения компонента указать свойство, в котором хранится видео, иначе оно выводиться не будет.

Для дополнения и неявного изменения (без вмешательства в код компонента) логики работы используйте технологию Событий.

Теперь надо найти файл, который подключает тот компонент, который нужно изменить. В нашем случае это index.php. Остальные файлы в шаблоне комплексного компонента, расположенного в шаблоне сайта, можно удалить. Комплексный компонент будет подключать эти файлы из ядра. А значит, они будут обновляться.

Напомним, что компонент – это выделенный в отдельный файл php-код с законченной функциональностью, файл регистрации компонента в системе и описания его параметров, а также файлы локализации.

Как вы могли заметить в каждом из файлов компонента в начале пишется строка if (!defined(“B_PROLOG_INCLUDED”) || B_PROLOG_INCLUDED!==true) die();. Она нужна для того, чтобы данные файлы нельзя было вызвать напрямую из окна браузера.

Метод $this->IncludeComponentTemplate(); подключает шаблон компонента и сохраняет в кеш-файл вывод и массив результатов $arResult. Все изменения $arResult и вывод после вызова метода подключения шаблона не будут сохранены в кеш.
Если при исполнении кода компонента мы не вошли в тело условия if ($this->StartResultCache()), то значит для данного компонента, страницы и входных параметров есть валидный кеш. После вызова этого метода HTML из кеша отправлен на вывод и мы имеем заполненный массив $arResult.

Кеш должен зависеть только от подготовленных параметров. То есть от параметров, которые инициализированы нужным образом, приведены к нужному типу (например, с помощью IntVal()) и т.д. В массиве $arParams содержатся как подготовленные параметры, так и исходные параметры (с тем же ключем, но с префиксом "~"). Если кеш будет зависеть от неподготовленных параметров, то злоумышленники смогут забить кешем все отведенное сайту дисковое пространство вызывая страницу с ID равными "8a", "8b", ... (которые после IntVal() дадут 8). 

В текущей реализации такими параметрами являются стили css шаблона, которые подключаются отложенными функциями, а значит не попадают в кеш.

С версии 15.5.1 появилась штатная поддержка вызова стороннего файла css. Под сторонним файлом понимается как локальный файл вне компонента так и файл на внешнем домене. Для подключения такого файла в template.php необходимо прописать:
	$this->addExternalCss("/local/styles.css");
	$this->addExternalJS("/local/liba.js");

Модуль - это модель данных и API для доступа к этим данным. Статические методы классов модуля могут вызываться в компонентах, шаблонах, других модулях. Также внутри контекста Bitrix Framework могут создаваться экземпляры классов.

Для экономии дискового пространства неиспользуемые модули рекомендуется удалить, при этом дистрибутив модуля остается в системе, и он в любое время может быть снова установлен. При деинсталляции некоторых модулей система предлагает сохранить накопленные модулем данные (таблицы модуля). Если вы в дальнейшем планируете использовать эти данные, то при удалении модуля необходимо отметить соответствующую опцию. 

Кнопка Настройки, расположенная на административной панели, позволяет перейти к настройкам модуля, страницы (формы) которого открыты в текущей момент в основной рабочей области.

ПРИМЕЧАНИЕ: Перед использованием модуля необходимо проверить установлен ли он и подключить его при помощи конструкции:
	if(CModule::IncludeModule("****"))
	{ 
		//здесь можно использовать функции и классы модуля
	}
где **** - идентификатор модуля.

Модули в Bitrix Framework представляют собой модели и контроллеры нижнего уровня (в понятиях MVC), а компоненты - контроллеры верхнего уровня, включающие представления, которые основаны на иерархии файловой структуры сайта. Весь функционал любого сайта, как правило, реализуется на стандартных модулях, но приходится кастомизировать компоненты (или написать свои) для формирования и вывода страниц и подключать их на соответствующих страницах сайта.

К примеру для скрипта /bitrix/modules/ID модуля/admin/body/my_script.php языковой файл должен быть расположен: /bitrix/modules/ID модуля/lang/ID языка/admin/body/my_script.php. И подключаться кодом:
	IncludeModuleLangFile(__FILE__);

Явное взаимодействие с помощью API. Подразумевает подключение модуля с помощью метода CModule::IncludeModule(указав в качестве параметра id модуля) с последующим непосредственным вызовом метода класса или функции модуля. Пример явного взаимодействия:
	// подключаем модуль mymodule
	if (CModule::IncludeModule("mymodule"))
	{
		// выполним его метод
		CMyModuleClass::DoIt();
	}

Событие - это какое-либо произвольное действие, в момент выполнения которого (до или после) собираются все обработчики этого события и выполняются по одному.

• Русский и английский без проблем работают с Windows-1251, если точно не будет потребности в других языках, то и нет потребности в UTF-8. 
• Проект на UTF-8 будет заведомо "тяжелее", в силу того что строки в этой кодировке занимают в два раза больше места, чем строки в однобайтной Windows-1251. Размер сайта и базы данных будет в 1,2 - 1,5 раз больше.

И мастерство работы с БД не играет существенной роли. Объективно в большинстве проектов нагрузка на sql (время исполнения) несущественна по сравнению с нагрузкой на процессор и затратами на интерпретацию скриптов. Тормозит не MySQL, а PHP.

Есть правило: главная страница сайта (обычно не самая простая) не должна отправлять запросы к БД при включенном кеше.

Есть миф, что длинный запрос долго исполняется. В действительности, всё зависит от того, какой объем данных приходится обработать базе для исполнения запроса. Разбор собственно запроса занимает ничтожно малую часть времени. Основное время занимает фильтрация и сортировка. Время фильтрации зависит от параметров фильтра и индексов, а сортировка - от числа записей в выборке.

В обработчике 404 ошибки необходимо "разобрать" переменную $_SERVER["REQUEST_URI"] на нужные идентификаторы. Для этого в PHP есть ряд полезных функций:
	preg_match 
	parse_url 
	pathinfo 
	strpos 
	parse_str 

При создании собственного компонента языковой путь должен выглядеть следующим образом:
/bitrix/templates/[шаблон_сайта|.default]/components/[пространство_имен]/[имя_компонента]/[имя_шаблона_компонента]/lang/[код_языка]/template.php

ПОДКЛЮЧЕНИЕ ЯЗЫКОВЫХ ФРАЗ НА НОВОМ ЯДРЕ D7
По умолчанию подстановка языковых фраз не работает в файле component_epilog.php шаблона компонента. Поэтому в нем языковые фразы подключаются следующим образом: 
	use \Bitrix\Main\Localization\Loc;
	Loc::loadLanguageFile(__FILE__);
	echo Loc::getMessage("SOMETHING_LANGUAGE_CONSTANT"); 
Сами языковые фразы, например, для русского языка должны быть заданы в файле lang/ru/component_epilog.php. Кроме того, при таком подключении языковые фразы будут работать как в кеше, так и "мимо" кеша.

Перед написанием js-кода встает резонный вопрос - где его хранить?
Существуют следующие варианты:
• Если вы разрабатываете JS-код для компонента и данный код больше нигде не применяется, разумнее расположить файл script.js в шаблоне самого компонента. 
• Если JS-код общий для всей публичной части, разумнее его разместить в шаблоне сайта. Как правило, такие JS-файлы хранятся в подпапке шаблона js/ и подключаются в самом шаблоне методом: Bitrix\Main\Page\Asset::getInstance()->addJs(); Но этот путь не подходит, если шаблонов сайта несколько, или вы разрабатываете код для административной части, или публичный шаблон запрещено менять по причине его обновлений компанией Битрикс (например, коробочный шаблон Битрикс24). 
• В таком случае применяется метод хранения файлов по пути /bitrix/js/<ваша уникальная папка>/file.js. Этот же метод размещения стоит избрать в случае создания вами своего модуля. 

Полная сигнатура BX.date.format:
	BX.date.format("формат", дата, текущее время, utc);

Выход: использовать методы AddHeadScript и SetAdditionalCSS. 

Используйте "ленивую" инициализацию (загрузку). Создавайте объекты, верстку, окна и прочее только тогда, когда это действительно нужно. Например, нет смысла заранее создавать BX.PopupWindow (а он вставляет в DOM новые узлы) до того момента, когда это действительно нужно (нажатие на ссылку или кнопку). Если интерфейс используется редко и некритично показать/не показать процесс загрузки, то лучше сделать ajax'ую подзагрузку. 

Метод генерирует Javascript, открывающий URL в popup-окне:
$APPLICATION->GetPopupLink(Array(
	"URL"=> "URL страницы, которая откроется в popup-окне",
	"PARAMS" => Array(
		"width" => 780,
		"height" => 570,
		"resizable" => true,
		"min_width" => 780,
		"min_height" => 400
		)
	)
);

Если тела всех частей инструкции состоят не более чем из одного выражения, то инструкция может записываться в виде:
if (условие) 
    действие1; 
else 
    действие2;

Перед логическими секциями кода желательно добавлять комментарии о том, что данная секция будет делать. Комментарии должны быть только на английском языке.

Основная задача веб-сайта (в 99% случаев) – это быстро вернуть посетителю запрошенную страничку и освободить ресурсы для обслуживания других посетителей. Именно для решения этой задачи существуют такие инструменты, как NGINX, lighthttpd, кэширование, PHP-акселераторы и другие. Для большинства сайтов с небольшой посещаемостью таких инструментов, имеющихся в наличии на практически каждом хостинге или почти в любой CMS, вполне достаточно.

Закладывая в ТЗ проекта интенсивное использование технологии кеширования, можно максимально ограничить нагрузку на базу данных. Это позволит нашему проекту выдержать в будущем значительные нагрузки.
Примечание: Возможность использования кеширования в проекте лучше заранее предусмотреть в ТЗ т.к. его внедрение после запуска проекта обходится значительно дороже и сложнее. 

Для реализации кеширования в системе созданы два класса:
• CPageCache - для кеширования HTML 
• CPHPCache - для кеширования HTML и PHP переменных 
Результаты кеширования сохраняются в виде файлов в каталоге /bitrix/cache/. Если время кеширования не истекло, то вместо ресурсоемкого кода будет подключен предварительно созданный файл кеша.
Правильное использование кеширования позволяет увеличить общую производительность сайта на порядок. Однако необходимо учитывать, что неразумное использование кеширования может привести к серьезному увеличению размера каталога /bitrix/cache/.

// если кеш есть и он ещё не истек то
if($obCache->InitCache($life_time, $cache_id, "/")):
    // получаем закешированные переменные
    $vars = $obCache->GetVars();
    $SECTION_TITLE = $vars["SECTION_TITLE"];
else :
    // иначе обращаемся к базе
    $arSection = GetIBlockSection($SECTION_ID);
    $SECTION_TITLE = $arSection["NAME"];
endif;

Лучше установить большее время кеширования, а актуальность данных в кеше поддерживать с помощью Тегированного кеширования. Тогда кеш будет обновляться только при изменении данных, а соответственно не будет лишней нагрузки на сервер, как в случае с малым временем, когда кеш создается по истечении указанного периода времени независимо от актуальности данных.
Достаточно часто в проектах многие используют вызов CIBlockElement::GetById. Простой, удобный метод, когда надо вытащить какое-то поле для элемента инфоблока. Но этот метод тянет все поля и все свойства элемента. В случае инфоблока с большим количеством свойств и большого числа посетителей на сайте этот простой запрос приводит к снижению производительности. А если таких запросов несколько десятков в различных result_modifier у разных компонентов? Оказывается, что в совокупности, несмотря на кеширование, эти вещи создают пиковые нагрузки в момент обновления кеша.
Если уж надо получить название элемента по ID, то лучше воспользоваться GetList с указанием конкретного вытаскиваемого поля элемента.
Единственное преимущество GetById перед GetList с точки зрения разработчика состоит в том, что GetById можно просто вызвать и все. Прямое использование GetList требует определенной работы с кодом (создание массива параметров). 

Примечание: GetByID внутри вызывает GetList. Разница только в том, что GetByID в любом случае тянет все поля и свойства, а в GetList этот перечень можно контролировать. 
Соответственно, разница в скорости выполнения будет сильно зависеть от того, что именно надо вытащить, а потому сравнивать надо не просто два метода, а конкретную бизнес-логику конкретного сайта. 
Также GetList позволяет выбрать сразу несколько записей, тогда как GetByID только одну.

Внимательно относитесь к элементам inline-block, перевод строки между ними будет отображен как пробел. Чтобы не писать теги в одну длинную строку, можно воспользоваться следующим приемом:
	<div class="inline-block-items"><?
		?><span class="inline-block-item">Inline Item 1</span><?
		?><span class="inline-block-item">Inline Item 2</span><?
		?><span class="inline-block-item">Inline Item 3</span><?
		?><span class="inline-block-item">Inline Item 4</span><?
	?></div>
Визуально теги разбиты и отделены отступами, а в результирующем HTML-коде будет одна строка. Другой прием с помощью HTML-комментариев:
	<div class="inline-block-items"><!--
		--><span class="inline-block-item">Inline Item 1</span><!--
		--><span class="inline-block-item">Inline Item 2</span><!--
		--><span class="inline-block-item">Inline Item 3</span><!--
		--><span class="inline-block-item">Inline Item 4</span><!--
	--></div>

Создавайте новую верстку по стандарту HTML5. В старых шаблонах по возможности избавляйтесь от XHTML (слешей в конце тегов <br />, <img />).

Держите структуру (разметка), оформление (стили) и поведение (скрипты) раздельно и постарайтесь свести взаимодействие между ними к минимуму. Убедитесь, что документы и шаблоны содержат только HTML, и что HTML служит только для задания структуры документа. Весь код, отвечающий за оформление, перенесите в файлы стилей, а код отвечающий за поведение - в скрипты.

HTML-атрибуты должны быть перечислены в следующем порядке:
1. class 
2. id 
3. атрибуты тега (src, href, title и другие.) 
4. data-* 

Если к элементу происходит обращение по классу через JavaScript, то такой класс должен иметь префикс js-. 

Не используйте кавычки с функцией url(), кроме случая, когда ссылка содержит пробел, либо формируется программно (обычно при использовании inline-стилей).
Плохо:
	.im-user-status {
		background: url("images/im-sprite.png");
	}
Хорошо:
	.im-user-status {
		background: url(images/im-sprite.png);
	}

Свойство без префикса всегда должно быть в конце.
Хорошо:
	.menu-item {
		-webkit-box-shadow:0 0 10px 20px #000;
		-moz-box-shadow:0 0 10px 20px #000;
		box-shadow:0 0 10px 20px #000;
	}

Избегайте использования модификатора приоритета !important.

Сортируйте свойства по принципу: свойства, сильно влияющие на элемент, в начале, а самые незначительно влияющие - в конце: 
	Display 
	Позиционирование (position/float) 
	Боксовая модель (width/height/margin/padding/border/box-sizing) 
	Цвета и типографика 
	Остальное 

Компонент - логически и функционально независимый компонент страницы, инкапсулирует в себе поведение (JavaScript), шаблоны и стили. Независимость компонентов обеспечивает возможность их повторного использования, а также удобство в разработке и поддержке проекта.

В Bootstrap рекомендуют кастомизировать стили в отдельном файле, обычно он называется bootstrap-theme.css. В случае с Bitrix Framework он называется template_style.css - для основного шаблона и style.css в каждом отдельном компоненте. В этом случает выше перечисленные файлы подключатся после основной библиотеки. 

Чтобы сообщить браузеру, что ваша страница адаптируется к любым устройствам, добавьте в заголовок документа такой метатег: 
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
Метатег viewport содержит инструкции для браузера по корректировке размеров и масштабированию страницы по ширине экрана устройства. Если этого элемента нет, мобильные браузеры по умолчанию показывают страницу для экрана компьютера (ширина которого обычно составляет около 980 пикселей, но это значение может отличаться у разных устройств). 

BORDER В 1PX
Часто дизайнеры требуют сделать границу блока шириной в 1 физический пиксель. Если присвоить блоку свойство border: 1px solid #000, на Retin'е это будет выглядеть жирной полосой в 2 физических пикселя. Раньше эту проблему решали путем создания картинки, которой обтягивали бордер с помощью свойства border-image. А это лишнее обращение к серверу. Начиная с iOS 8 и Android 4.4, стандартные браузеры на базе WebKit поддерживают дробные свойства border: .5px solid #000. На данный момент поддержка этого способа на используемых девайсах равна 97% на iOS и 75% на Android.

Динамическая информация во включаемых областях Если во включаемой области содержится какая-либо динамическая информация, то она может закешироваться, что скорее всего приведет к нежелательному результату. Лучше вообще не использовать динамическую информацию во включаемой области. 
	
Использованы события onUpdate и onAfterUpdate. Первое вызывается перед изменением записи в таблице, но уже после проверки данных и возможной отмены действия.

Также можно воспользоваться $_SESSION и записать переменные в массив переменных сессии.

Улучшить работу front-end можно уменьшив количество загружаемых ресурсов и их объём.

Используя кеширование ресурсов в браузере (Expires/Cache-Control: max-age, Last-Modified/E-tag). Нужно отдавать заголовки для картинок, css и js-скрипта. Если нет заголовков последней модификации или заголовка Expires, то на каждый хит браузер будет скачивать все ресурсы повторно. 
Если у вас есть дата последней модификации, то это уже хорошо. В этом случае на вторых и последующих хитах браузер будет делать conditional GET-запрос. То есть спрашивать: а не изменился ли этот ресурс вот с этой даты? И загружать только изменённые ресурсы. Правда и в этом случае приходится делать один дополнительный запрос. 
Чтобы избежать этого запроса достаточно настроить в Apache или NGINX выдачу заголовка Expires. Это, к сожалению, часто забывают сделать. 

Все картинки для шаблона должны быть в спрайтах. А для мелких картинок лучше вообще использовать Base64. 

ЗАЧЕМ НУЖНО СЖИМАТЬ ДАННЫЕ? 
Скорости передачи данных сейчас велики. Зачем сжимать данные, борясь за байты? Сжать css - файл уменьшается с 10 до 8 kb, сжатие картинки даёт 3 kb. Что даёт такой выигрыш? 
Ответ в протоколе TCP/IP и понятие Round Trip Time - время между отправкой запроса от клента серверу и получением обратного ответа. Когда браузер соединяется с сервером, они договариваются между собой о размере окна, в котором они будут обмениваться данными. У каждого клиента это окно разное, более того, оно может меняться в процессе передачи данных. Одно окно передаётся за один Round Trip Time. Если окно - 8 kb, а файл 10 kb, то нужно два Round Trip Time, то есть в два раза больше времени.
 
ДОПОЛНИТЕЛЬНЫЕ МЕРЫ
• Вынос ресурсов на разные домены, который позволяет обойти ограничение на 6 подключений. 
• Порядок подключения ресурсов на странице: CSS вверху, Javascript – внизу. Оба они блокируют рендеринг страницы до завершения собственной загрузки. Но если css мы не можем убрать в низ страницы: без него она просто не отобразится, то Javascript - вполне убрать вниз или же грузить асинхронно. 
