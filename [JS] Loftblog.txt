В JS все объект, кроме undefined и null.

this внутри функции - это ее контекст, а не объект, в кот. эта функция вызывается.

Миксин - подход, расширяющий функциональность экземпляра, не прибегая к прототипному наследованию. Суть подхода - добавить в прототип конструктора или прямо в экземпляр необходимые функции. Такие функции назыв. примесями.

====================================================

В JS имеются "обертки", кот. предусмотрены для примитивов: строка, число, булев. Обертки ПОЗВОЛЯЮТ примитивам ВЕСТИ СЕБЯ КАК объект. Знайте это, но пользоваться оберткой - BAD PRACTICE.

Преобразование типов данных:
	1. Строковое.
	2. Числовое.
	3. Логическое.
Есть явное и неявное преобразование:
Явное - с помощью объектов-оберток и методов:
	String(), Number(), Boolean()
	toString(), parseInt(), parseFloat()
Неявное:
	(5 + '1');		// string
	(2345 + '');	// быстро в string
	(+'2345');		// быстро в number
	(!!'123');		// быстро в boolean
	(+"");			// 0
	(+true);		// 1

Для обращения к свойствам исп. 2 нотации: точечную и с квадратными скобками.
	obj.prop
	obj[prop]
Причем в [] можно помещать имена var, кот. будут содержать значения, идентичные именам свойств и методов объекта, тем самым вызывая их.

Свойство или метод объекта (не прототипа) можно удалить:  delete obj.prop;

Элементы [] нужно удалять так:
	array.splice(1, 2);		// 1 - с какого индекса, 2 - сколько элементов удалить.

==========================================================
В JS для прогона [] исп. цикл for, для {} - for...in.

Прогон массива:
	var arr = [1, 2, 3],
		 len = arr.length;
	for (var i = 0; i < len; i++) {
		console.log( arr[i] );
	}

Прогон объекта:
	for (var prop in obj); 	// в отличие от PHP, где foreach ($array as $anyvar)
или так
	for (prop in obj) {
		if ( obj.hasOwnProperty(prop) ) {			// *
			console.log(prop + ':' + obj[prop]);		// prop1:one и т.д.
		}s
	}
* В JS при обходе объекта нужно делать проверку, т.к. цикл for...in обходит все свойства, включая свойства прототипа, но обычно нам нужны только свойства конкретного объекта.
==========================================================
Разница между Function Expression и Function Declaration в 'хойстинге'.
	function func1() {
		function funcExm() {
			return 'one';
		}
		return funcExm();

		function funcExm() {
			return 'two';
		}
	};
	console.log( func1() );	// two

	function func2() {
		var funcExm = function() {
			return 'one';
		}
		return funcExm();

		var funcExm = function() {
			return 'two';
		}
	};
	console.log( func2() );	// one
--------------------------------------------------------------------------------------------------
"Так работает функция обратного вызова, кот. передается в качестве аргумента другой функции и уже в теле другой Ф вызывается". (Основы Javascript 12 - Функции - 00:19:00)


Функции позволяют изолировать код.

BEST PRACTICE - объявлять все var в начале функции.

"Все var внутри функции - это свойства спец. объекта LexicalEnvironment"

=================================================
ОБЪЕКТ Window и BOM
=================================================

'location.toString()' выводит полный URL текущей страницы.

document.getElementsByTagName() работает быстрее, чем document.querySelectorAll(). Однако второй предлагает более гибкий поиск. Например,
	var includedParagraphs = document.querySelectorAll("div p").

Кэширование var положительно сказывается на скорости работы браузера.
	var doc = document,
	elem = doc.getElementById('#special');


Элемент, на кот. сработало событие - объект события (event object) передается в качестве первого аргумента функции (получается callback).
	var changeColor = function(e) {
		console.log(e.type);
		console.log(e.target);
		console.log(e.currentTarget);
		console.log(e);
	}




==============================================================
jQuery
==============================================================

$(document).ready(function() {...})   =   $(function() {...})

<!> Если работаем с событием, обязательно манипулируем объектом события. В функцию помещаем данный объект как аргумент.

Событие можно привязать к множеству элементов, заданных селектором, с помощью функции 'on'. В события в $ приводят к вызову функции 'on' с соответствующими параметрами. Наилучшей практикой по обработке событий явл. исп. функции 'on'. Она обеспечивает:
	- привязку любого срабатываемого события на выбранных элементах к обработчику события;
	- привязывает неск. событий к одному обработчику;
	- позвол. привязывать неск событий к неск. обработчикам на множестве выбранных элементов;

"Детали о событии внутри функции-обработчика доступны через подаваемого на вход обработчика аргумента 'e', кот. передается JS по умолчанию."
==============================================================


==============================================================
ДОБАВЛЕНИЕ ЭЛЕМЕНТОВ В $
==============================================================
	$(function() {
		$('<img>', {
			src: 'file.jpg',
			alt: 'Описание картинки',
			title: 'Основы jQuery',
			click: function(e) {
				$(this).toggleClass('selectedImg');
			}
		})
		.css({'border' : '1px solid black'})
		.appendTo('body')
	})
==============================================================


ВСТАВКА DIV + 2 СОБЫТИЯ НА НАВЕДЕНИЕ И УВЕДЕНИЕ.
	$(function() {
		$('<div></div>').appendTo('body');
		$('div').mouseover(function(e) {
			$(this).fadeTo(200, .5);
		})
		$('div').mouseout(function(e) {
			$(this).fadeTo(200, 1);
		})
	})


// Основы jQuery - 8 Базовые эффекты
$(function() {
	$('.someDiv').on('click', function(e) {
		var modal = $('#modalDiv');
		modal.css('top', (window.innerHeight - modal.height()) / 2);
		modal.css('left', (window.innerWidth - modal.width()) / 2);
		modal.css('background-color', $(e.target).css('background-color'));
		modal.show();
	})
	$('#modalDiv').on('click', function(e) {
		$(this).hide();
	});
})

АНИМАЦИЯ ВНЕ ОЧЕРЕДИ:
modal
	.animate({'height':400}, 300)
	.animate({'width':400}, {
		duration: 300,
		queue: false		// вне очереди
	})
	.animate({'top': (window.innerHeight - 400) / 2}, 300);
Или так:
	modal.animate(
		{'height':400, 'width':400,
			'top': (window.innerHeight - 400) / 2,
			'left': (window.innerHeight - 400) / 2},
		{duration:500, queue: false}
	);

AJAX-запрос
	<script>
	function show(){
		$.ajax({
			url: "time.php",
			cache: false,
			success: function(html){ $('#content_p').html(html)}
		})
	};
	setInterval(show, 1000);
	</script>



==============================================================
AJAX-ЗАПРОС С ФОРМОЙ:
==============================================================
/ -------------------------  HTML  ------------------------- /
<body>
	<p id="content_p"></p>
	<form id="mail_send">
		<input type="email" name="mail">
		<button type="submit">Отправить</button>
	</form>
</body>
/ -------------------------  JS  ------------------------- /
$('#mail_send').submit(function(){		// mail_send - форма
	var str = $(this).serialize();			// содержимое формы в виде строки
	$.ajax({
		type: 'POST',
		url: 'hello.php',
		data: str,
		success: function(html) {		// ОБЯЗАТЕЛЬНО принимаем ответ от серва
			$('#content_p').html(html)	// помешаем ответ в html-код
		}
	});
	return false; 			// прерываем дальнейшее выполнение функции
})
==============================================================